# 集合框架总结

## 概览

### 简介

图片说明：

- 虚线标识实现、实线标识继承
- 绿色背景是具体实现类,粉色背景是抽象接口
- 左上角`legacy`是遗留的,线程安全的集合
- ⭕圈圈颜色,标识集合底层实现。是数组、链表、二叉堆、哈希表还是红黑树

![img](集合框架总结.assets/java_collections_overview.png)



容器，就是可以容纳其他Java对象的对象。*Java Collections Framework(JCF)*为Java开发者提供了通用的容器，其始于JDK 1.2，优点是:

- 降低编程难度
- 提高程序性能
- 提高API间的互操作性
- 降低学习难度
- 降低设计和实现相关API的难度
- 增加程序的重用性

集合框架主要分为Collection接口和Map接口。

Java容器里只能放对象，对于基本类型(int, long, float, double等)，需要将其包装成对象类型后(Integer, Long, Float, Double等)才能放到容器里。很多时候拆包装和解包装能够自动完成。这虽然会导致额外的性能和空间开销，但简化了设计和编程。



### collection

- list接口
  - ArrayList基于动态数组实现,支持随机访问
  - LinkedList基于双向链表实现,只能顺序访问、不支持随机访问,但对插入友好
  - Vector  和ArayList相似,但是它线程安全(使用Synchronized保证)
- set接口
  - HashSet    基于HashMap实现
  - LnkedHashSet   基于双线链表+HashSet实现
  - TreeSet     基于红黑树实现
- queue接口
  - LinkedList   
  - PriorityQueue  优先级队列,基于二叉堆实现

### Map

- HashTable  和HashMap类似,但线程安全。遗留类,不应该被使用,没有线程安全的情况下使用HashMap,有线程安全的情况下使用ConcurrentHashMap。因为CHM引入了分段锁效率较高。

- HashMap  哈希表

- LinkedHashMap  双向链表+HashMap  牺牲空间保证Map节点的有序性。插入顺序和最近

- TreeMap 基于红黑树实现

  

## Iterable-Collection

### List

#### ArrayList

##### 继承关系

![image-20230310155855769](集合框架总结.assets/image-20230310155855769.png)

- Clonable

  > 实现此接口才可以重写Object的Clone()方法,利用Array.copy和System.ArrayCopy拷贝,这是个浅拷贝。
  >
  > 会将模数modCount置零,且拷贝时会忽略数组中的空对象

- Serializable

  > 实现此接口对象才可以序列化传输。JDK提供的ObjectOutputStream、ObjectInputStream。
  >
  > 序列化时会保存集合的size，并且忽略数组中的空对象,反序列化先读取size然后循环读取对象放到数组中

- RandomAccess

  > 标志性接口,没作用,表示支持随机访问。Vector也实现了此接口

- AbstractList

##### 底层及结构

> 对象数组Object[],可接受任意类型的对象。

##### 属性和方法

###### 属性：

> - 底层结构：对象数组，Object类型可接受任意类型元素
> - 对象数组使用transient修饰,不会参与序列化
> - size：数组元素个数,不是数组大小

```java
//序列号
private static final long serialVersionUID = 8683452581122892189L;
//默认初始容量
private static final int DEFAULT_CAPACITY = 10;
//空对象数组，初始化ArrayList如果size等于0的话，则初始化为该空数组
private static final Object[] EMPTY_ELEMENTDATA = {};
//默认空对象数组，ArrayList无参构造初锁始化的空数组
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
//对象数组,ArrayList底层结构,集合成员都存储在此
transient Object[] elementData; 
//元素个数、注意不是数组长度
private int size;
```

###### 构造函数

可定义容量,可拷贝

```java
public ArrayList(int initialCapacity);
public ArrayList();
public ArrayList(Collection<? extends E> c);
```

> 常用操作：

```java
new ArrayList(Arrays.asList(1,2,3));
```

###### 扩容

- ensureCapacity(int minCapacity);是一个public方法,供程序员使用,当我们提前知道集合大小,则可以指定集合容量
- 自动扩容,使用集合容器,一般不需要指定,他会自动扩容,ArrayList默认容量10,每次扩容1.5倍
- 扩容会调用Array.copyof()方法对原数组对象做一个浅拷贝

```java
public void ensureCapacity(int minCapacity);
private Object[] grow(int minCapacity);
```

###### 添加元素

- add(E e)
- add(int index,E e)
- addAll(Collection<? extends E> coll)
- addAll(int  index, Collection<? extends E> coll)

> 添加一个或多个元素,插入元素之前判断容量是否充足,不充足则扩容。
>
> 底层是一个对象数组，添加一个元素时,直接在下标size处插入元素即可。添加多个元素时通过数组拷贝的方式。
>
> 指定下标插入元素,需要首先数组后移,再插入元素。

###### 更新集合

- set(int  index, E e)      

  > 替换元素并返回旧值

- remove(int  index)

  > 移除指定下标处元素。通过数组拷贝前移来覆盖移除元素,并将尾部元素置为null

- remove(Object o)

  > 通过循环equals来找到待移除元素下标。通过数组拷贝前移来覆盖移除元素,并将尾部元素置为null

- removeAll(Collection<? extends E> c)

  > 移除所有元素,通过数组拷贝来实现

##### 小结论

- ArrayList底层是一个对像数组,添加拿取基本数据类型,会进行自动装箱拆箱
- ArrayList初始化默认容量为10,每次扩容1.5倍。扩容需要数组拷贝,性能消耗大头,如果知道容量大小则可以预先指定,避免频繁扩容。扩容数组拷贝是一个浅拷贝
- ArrayList优化了clone(),ArrayList拷贝会忽略集合中的null元素。
- ArrayList优化了序列化,Arraylist序列化会忽略集合中的null元素。
- ArrayList支持随机访问,访问性能较高。对插入不友好,对查询友好。



#### LinkedList



##### 继承关系

![image-20230313105545779](集合框架总结.assets/image-20230313105545779.png)

- Clonable

  > 实现此接口才可以重写Object的Clone()方法,这是一个浅拷贝。
  >
  > 拷贝逻辑：LinkedList的所有属性都是transient的。首先拷贝LinkedList引用,再循环调用add(E e)方法加入链表尾部,add(E e) 方法会创建新的节点添加到链表尾部。

- Serializable

  > 实现此接口对象才可以序列化传输。JDK提供的ObjectOutputStream、ObjectInputStream。
  >
  > 序列化时会保存链表的size，以及所有Node的item。

- Deque

  > 双向队列接口,LinkedList底层是一个双向链表,实现Dequue标准,加入链表就是入队。
  >
  > 提供 pop-入队   poll() 出队等操作。

##### 底层及结构

> LinkedList底层是一个双向链表,内存维护者一个个Node节点,Node节点中存储着前期和后继节点指针和链表元素值。
>
> LinkedList实现了List和Deque接口,也就是说LinkedList既可以作为链表也可以作为队列和栈使用。关于栈或队列,首选的就是ArrayDeque,它拥有更好的性能。
>
> LinkedList的实现结构,决定了所有跟有关下标的操作都是线性时间。

![image-20220412005701030](集合框架总结.assets/image-20220412005701030.png)

##### 属性和方法

###### 属性

> 所有属性都不参与序列化,手动写入size和每个node的item。

```java
// 集合元素个数
transient int size = 0;
// 头节点指针
transient Node<E> first;
// 尾节点指针
transient Node<E> last;

private static class Node<E>
// 元素值
E item;
// 前驱节点
Node<E> next;
// 后继节点
Node<E> prev;
```



###### 构造函数

> LinkedList没有容量限制

```java
public LinkedList()；
public LinkedList(Collection<? extends E> c)
```

###### 添加元素

- add( E  e)
- add(int index, E e)
- addAll(Collection c)
- addAll(int index，Collection c)

> add(E e)方法默认尾插法插入元素。
>
> add(int index, E e)方法,首先通过线性查找到具体插入位置,然后插入元素。
>
> addAll(Collection c) ==> addAll(size ,  c)
>
> addAll(int index，Collection c)不会循环调用add(int index, E e)，来实现。而是先将c中的元素组成一个链表,然后将链表拼接上去



###### 更新元素

- removeFirst()
- removeLast()
- remove(E e)
- remove(int  index)
- set(int index, E e)

> 移除首尾节点消耗的是常数时间
>
> 移除指定下标消耗的是线性时间

###### 查找

- indexOf(Object o)
- get(int index)

###### 队列相关操作

- peek()   返回队首元素,队列不做修改
- element()    返回队首元素,队列不做修改
- poll()  出队
- remove()  出队
- offer(E  e)  入队



- offerFirst(E e)    入队,first之前
- offerLast(E  e)   入队,last之后
- peekFirst()
- peekLast()
- pollFirst()
- pollLast()
- push()    入队,(入栈),,first之前
- pop()      出队,(出栈)



##### 小结论

- LinkedList底层是一个双向链表,实现了Deque和List接口,它既可以作为链表使用也可以作为队列和栈使用。(使用队列和栈首选ArrayDeque)
- LinkedList是链表,内存不连续,不用提前申请内存,长度没有限制
- LinkedList优化了clone()方法,clone()方法只拷贝链表的大小(size)和各个Node的item,避免存储Node造成空间浪费
- LinkedList优化了序列化,首先LinkedList的所有属性都是Transient的,不参与序列化,序列化只存储链表的大小(Size)和Node节点的item避免存储Node造成空间浪费
- LinkedList对插入友好对查找不友好,因为其实现是链表，和下标有关的操作都是线性的。但是LinkedList也做了优化，比如查找下标index小于size的一半从头节点开始变量,如果大于一半则从尾节点开始遍历



#### Vector

> 和ArrayList类似,线程安全。

### Set

> 不重复集合

#### HashSet

> 基于HashMap实现

##### 继承关系

![image-20230314141554041](集合框架总结.assets/image-20230314141554041.png)



##### 底层结构

> 基于HashMap实现,HashMap的key为元素,value为固定的new Objject()对象。

##### 属性和方法

###### 属性

> map：HashSet底层使用HashMap实现
>
> PRESENT： HashSet的元素都作为HashMap的KEY,那么Hash Map的value使用present填充

```java
private transient HashMap<E,Object> map;

private static final Object PRESENT = new Object();
```

###### 构造方法

> HashSet是基于HashMap实现的,HashSet的构造函数就是对HashMap的初始化。
>
> 其中HashSet(Collection<? extends E> c)这个构造函数有一个关于容量的计算:`(c.size()/.75f) + 1`,这是为了防止HaashMap频繁扩容。

```java
public HashSet() {
    map = new HashMap<>();
}
public HashSet(Collection<? extends E> c) {
    map = new HashMap<>(Math.max((int) (c.size()/.75f) + 1, 16));
    addAll(c);
}
public HashSet(int initialCapacity, float loadFactor) {
    map = new HashMap<>(initialCapacity, loadFactor);
}
```



###### 状态方法

- size()
- isEmpty()
- contains(Object o)

###### 添加元素

- add(E e)       调用的是 `map.put(e, PRESENT)`方法,set的元素值作为hashMap的key，hashmap的value则用PRESENT填充。

```java
public boolean add(E e) {
    return map.put(e, PRESENT)==null;
}
```

###### 更新集合

- remove(Object o)
- clear()

```java
public boolean remove(Object o) {
    return map.remove(o)==PRESENT;
}
```

##### 小结

- HashSet基于HashMap实现,HashMap的key作为HashSet的元素,HashMap的value使用固定对象填充
- HashSet的元素不允许重复可以为null。判重逻辑是首先判断hashCode是否相等,在使用equals进行安全校验
- 拷贝优化：不直接浅拷贝HashSet共享同一个hashMap,而是同时拷贝HashMap，这样拷贝对象不会影响到原型对象
- 序列化优化：序列化写入元素个数(size)、容量、加载因子、HashMap的Key。



#### LinkedHashSet

> LinkedHashSet  基于 LinkedHashMap实现，LinkedHashSet = HashSet + 双向链表。
>
> LinkedHashMap的节点(内部类Node是HashMap.Node的子类),比HashMap.Node的节点多了前后指针。

#### TreeSet

> TreeSet基于红黑树实现，内部维护一个TreeMap。TreeSet天然具有排序功能，可添加可排序的元素，或自定义集合比较器。

### Queue & Deque

> `Queue`是`Collection`的子类，除了具有集合相关方法外，还扩展了队列相关方法。
>
> `Queue` 是单端队列，即只能从一端插入元素，另一端删除元素，实现上一般遵循 **先进先出（FIFO）** 规则。
>
> `Deque` 是双端队列，在队列的两端均可以插入或删除元素,`Deque` 继承了 `Queue` 接口, 增加了在队首和队尾进行插入和删除的方法

#### queue

```java
boolean add(E e);//添加到队列尾部。 一般借助offer方法实现，在存在有容量限制的队列,当队列满了再插入元素可能会抛出IllegalStateException("Queue full")异常
boolean offer(E e); // 添加元素到队列尾部,此方法比add()方法好
E remove(); // 检索并删除此队列的头部。此方法与poll()的唯一不同之处在于，如果队列为空，则抛出异常。
E poll();// 检索并删除此队列的头部，如果此队列为空则返回null。
E element();//检索但不删除此队列的头。此方法与peek方法的唯一不同之处在于，如果队列为空，则抛出异常。
E peek();//检索但不删除此队列的头部，如果此队列为空则返回null。
```



##### ArrarQueue

> 遗留类，单向循环队列。
>
> 底层维护一个数组，两个指针`head`、`tail`分别对应队头、队尾，从tail入队，head出队，当head == tail时（也就是容量不足时），任然进行添加元素操作会报异常（full queue）。
>
> 它并没有实现Queue接口。

##### PriorityQueue

> 优先级队列，入队出队顺序和队列内元素优先级有关，高优先级的元素优先出队，PriorityQueue可添加实现了Comparable接口的元素或者自定义比较器。
>
> PriorityQueue是一个二叉堆，默认小顶堆，可自定义比较器变为大顶堆。

> PriorityQueue底层是一个数组:
>
> - 任意父节点 （下标为m），大于或小于其两个子节点(下标为2m+1,2m+2)
> - 堆顶元素为极值(最大值或最小值)，所以借助PriorityQueue可以找出第几大元素

![image-20220502012546564](集合框架总结.assets/image-20220502012546564.png)

> 添加元素逻辑：
>
> - 添加元素到数组尾部，记录下标为k
> - 找到下标为k的节点的父节点，(k-1)/2 
> - 父节点和此节点进行比较
>   - 大于父节点，父节点后移
>   - 小于父节点一切都不用做





#### deque

> 此接口是queue接口的子接口,是双向队列的抽象标准。双向链表LinkedList就实现了此接口。
>
> 因为是双向队列，提供了从头部入队、从尾部入队、头部出队、尾部出队等丰富方法。

##### LinkedList

> LinkedList双向链表实现了Deque接口。

##### ArrayDeque

> 双向循环队列，实现了Deque接口。
>
> 底层维护一个数组，数组长度为2的幂次方，两个指针(head、tail)分别对应队头、队尾。
>
> 容量不足时(tail == head)会自动扩容，扩2倍。

> 一些算法，和HashMap很相似

- 计算数组长度,也就是队列容量

  > 一步步移位或运算

- 计算入队元素下标

  > 由于队列容量为2的幂次方，可以使用与运算计算

![image-20220501180729544](集合框架总结.assets/image-20220501180729544.png)

#### 其他

> 其他的一些队列：
>
> - BlockingQueue  阻塞队列等

## map



### HashTable

> - 遗留类，实现Map接口，key-value数据结构。
> - 线程安全，synchronized保证
>
> 理解它有助于理解HashMap，HashMap是HashTable单线程环境下的优化。

![image-20220520003443203](集合框架总结.assets/image-20220520003443203.png)

> 缺点

- 没有扰动函数，当遇到糟糕的哈希算法时，容易发生哈希冲突
- 通过算数取余的方式确认散列下标，相较于位运算效率较低

> 好的地方:确认散列下标有一个于运算，是为了防止出现负数下标

`(hash & 0x7FFFFFFF) % tab.length;`







### Properties



### HashMap



### LinkedHashMap

















































