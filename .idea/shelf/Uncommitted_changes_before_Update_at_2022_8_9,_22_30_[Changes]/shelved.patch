Index: foot/jvm/class文件二进制组成形式.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>### java如何运行\n\n> java文件由程序员编写，但是不能直接运行，需要经历如下阶段才可以运行。\n\n`.java`文件  ----经历`java`编译器 ` javac`编译 ，此过程会对我们代码进行自动优化   ------------  》`.class`文件 (又叫`java`字节码文件) ---------`java`虚拟机解释----->机器码   ------》交给操作系统运行\n\n> `.class`文件又叫字节码文件，它只面向`java`虚拟机，不面向任何操作系统。这里学习一下`.class`文件的组成结构\n\n\n\n<hr>\n\n\n\n###  如何查看.class文件信息\n\n> `.class`文件是字节码文件，一字节八位，我们采用16进制查看。使用`NotePad++`、`UltraEdit`或其他支持工具。\n\n#### 查看字节码\n\n- 写一个java类，编译一下生成class文件\n\n> 简单的Person类加两个属性\n\n```java\npublic class Person {\n    private String name;\n    private int age;\n    //getter and setter\n}\n```\n\n> 编译生成的class文件没什么大的区别，只不过会给我们自动生成无参构造函数\n\n```java\npublic class Person {\n    private String name;\n    private int age;\n    public Person() {\n    }\n}\n```\n\n- 使用`NotePad++`打开\n\n> 这是16进制的形式，可确定每2个数字代表一个字节，并且内存连续。\n\n<img src=\"class文件二进制组成形式.assets/image-20220804161050110.png\" alt=\"image-20220804161050110\" style=\"zoom:67%;\" />\n\n####  javap\n\n> `javap`是`java  class`文件的分离器，可以对`class`文件进行简单解释，使得程序员不用直接面对字节码。\n\n> 基本上使用  javap  -v    classpath\\classname.class 来查看\n>\n> 当然如果`class`文件过大，终端显示不友好，可以将信息输出到文件查看。\n>\n> 使用命令：javap   -v   classpath\\classname.class   >  filename\n\n 会输出如图所示的内容,相对于字节码令人更有食欲一些.\n\n<img src=\"class文件二进制组成形式.assets/image-20220804162500618.png\" alt=\"image-20220804162500618\" style=\"zoom:67%;\" />\n\n#### jclasslib\n\n> 使用`idea`插件`jclasslib`分析class文件。\n\n安装：\n\n设置 -->Plugins->到Marketplcae搜索下载\n\n使用：\n\nview ->首位 bytecode with JclassLib\n\n<img src=\"class文件二进制组成形式.assets/image-20220807175157830.png\" alt=\"image-20220807175157830\" style=\"zoom:50%;\" />\n\n\n\njclasslib为我们友好的分了类：\n\n![image-20220807175316455](class文件二进制组成形式.assets/image-20220807175316455.png)\n\n\n\n<hr>\n\n\n\n### class文件内容\n\n\n\n#### class文件字节码结构\n\n示意图：\n\n![image-20220807010445339](class文件二进制组成形式.assets/image-20220807010445339.png)\n\n##### 魔数\n\n> 魔数(magic)，是`JVM`用于识别是否是`JVM`认可的字节码文件。\n>\n> 所有由`java`编译器生成的class字节码文件的首四个字节码都是CA FE BA BE。\n\n当`JVM`准备加载某个`class`文件到内存的时候，会首先读取该字节码文件的首四位字节码，判断是否是CA FE BA BE,如果是则JVM认可，如果不是JVM则会拒绝加载该字节码文件。\n\n> Class文件不一定都是由`.java`文件编译而来的，`Kotlin`以及其他java虚拟机支持的都可以。\n\n比如：\n\n使用Kotlin写一个类：\n\n![image-20220804174802920](class文件二进制组成形式.assets/image-20220804174802920.png)\n\n编译过后查看其字节码：\n\n也是cafebabe开头的\n\n![image-20220804174837725](class文件二进制组成形式.assets/image-20220804174837725.png)\n\n\n\n##### 版本号\n\n> 版本号包括主版本号(major_version)和副版本号(minor_version)。\n>\n> 我们一般只需要关注主版本号，平常所说的java8其实是java1.8。副版本号主要是对主版本的一个优化和bug修复。目前java版本都来到了17了。\n>\n> 主版本号占用7、8两个字节，副版本号占用5、6两个字节。JDK1.0的主版本号为45，以后版本每升级一个版本就在此基础上加一，那么JDK1.8对应的版本号为52，对应16进制码为0x34。\n>\n> 一个版本的JVM只可以加载一定范围内的`Class`文件版本号，一般来说高版本的`JVM`支持加载低版本号的`Class`文件，反之不行。`JVM`在首次加载`class`文件的时候会去读取`class`文件的版本号，将读取到的版本号和`JVM`的版本号进行对比，如果`JVM`版本号低于`class`文件版本号，将会抛出`java.lang.UnsupportedClassVersionError`错误。\n\n我们修改一下`Person.class`关于版本号的数据，提高`class`文件的版本号为0x39 ,为10进制57，jvm版本为java1.13。\n\n通过`java <classpath>.classname`运行一下：\n\n![image-20220805114144243](class文件二进制组成形式.assets/image-20220805114144243.png)\n\n![image-20220805114453890](class文件二进制组成形式.assets/image-20220805114453890.png)\n\n> 说我们的jvm只支持运行`java`版本最高为52的`class`文件，也就是`java1.8`。\n\n> 同时也可以通过`javap`命令查看当前`class`文件支持的最低`jvm`版本。\n\n![image-20220805133137424](class文件二进制组成形式.assets/image-20220805133137424.png)\n\n\n\n##### 常量池计数器(constant_pool_count)\n\n> 紧跟于版本号后面的是常量池计数器占两个字节。记录整个class文件的字面量信息个数，决定常量池大小。\n>\n> `constant_pool_count` =  常量池元素个数 + 1。  只有索引在 （0，constant_pool_count）范围内才会有效，索引从1开始。\n\n\n\n##### 常量池数据区(constant_pool)\n\n> 常量池类似于一张二维表，每一个结构项代表一条记录，包含`class`文件结构及其子结构中引用的所有字符串常量、类、接口、字段和其他常量。且常量池中每一个元素都具备相似的结构特征，每一个元素的第一字节用做于识别该项是哪种数据类型的常量，称为`tag byte`。\n\n\n\n##### 访问标志(access_flags)\n\n> 用于表示一个类、接口、以及方法的访问权限。占用两个字节。\n\n| 标记           | 值（0x） | 作用                                   |\n| -------------- | -------- | -------------------------------------- |\n| ACC_PUBLIC     | 0x0001   | 公共的                                 |\n| ACC_FINAL      | 0x0010   | 不允许被继承                           |\n| ACC_SUPER      | 0x0020   | 需要特殊处理父类方法                   |\n| ACC_INTERFACE  | 0x0200   | 标记为接口，而不是类                   |\n| ACC_ABSTRACT   | 0x0400   | 抽象的，不可被实例化                   |\n| ACC_SYNTHETIC  | 0x1000   | 表示由编译器自己生成的，比如说桥接方法 |\n| ACC_ANNOCATION | 0x2000   | 表示注解                               |\n| ACC_ENUM       | 0x4000   | 表示枚举                               |\n|                |          |                                        |\n\n- ACC_SYNTHETIC\n\n> 由编译器自己生成的代码，比如一些桥接方法，我们写一个类实现一个范型接口\n>\n> 然后使用javap -v查看字节码信息\n\n```java\npublic class AboutACCSYNTHETIC implements Comparator<String> {\n    @Override\n    public int compare(String o1, String o2) {\n        return 0;\n    }\n}\n```\n\n> 会发现编译器会为我们生成一个桥接方法，类型是Object的，且访问标志存在  ACC_SYNTHETIC\n\n```bash\n  public int compare(java.lang.String, java.lang.String);\n    descriptor: (Ljava/lang/String;Ljava/lang/String;)I\n    flags: ACC_PUBLIC\n    Code:\n      stack=1, locals=3, args_size=3\n         0: iconst_0\n         1: ireturn\n      LineNumberTable:\n        line 16: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       2     0  this   Lcom/roily/jvm/day01/AboutACCSYNTHETIC;\n            0       2     1    o1   Ljava/lang/String;\n            0       2     2    o2   Ljava/lang/String;\n\n  public int compare(java.lang.Object, java.lang.Object);\n    descriptor: (Ljava/lang/Object;Ljava/lang/Object;)I\n    flags: ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC\n    Code:\n      stack=3, locals=3, args_size=3\n         0: aload_0\n         1: aload_1\n         2: checkcast     #2                  // class java/lang/String\n         5: aload_2\n         6: checkcast     #2                  // class java/lang/String\n         9: invokevirtual #3                  // Method compare:(Ljava/lang/String;Ljava/lang/String;)I\n        12: ireturn\n      LineNumberTable:\n        line 12: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      13     0  this   Lcom/roily/jvm/day01/AboutACCSYNTHETIC;\n```\n\n\n\n- ACC_ENUM\n\n> 表示这个类是一个枚举类\n\n其实可以看出枚举在编译的时候会被当做一个普通类处理，只不过会继承`Enum`\n\n![image-20220806212914672](class文件二进制组成形式.assets/image-20220806212914672.png)\n\n\n\n- ACC_INTERFACE\n\n> 表示是一个接口，而不是一个类。如果一个`class`文件被标识了ACC_INTERFACE那么他一定他也是抽象的，也就是得标志上ACC_ABSTRACT。\n>\n> 并且一个接口拿来就是为了实现的，那么就不能被标志上ACC_FINAL。\n>\n> 也不可以设置为ACC_ENUM和ACC_SUPER\n\n![image-20220806213718774](class文件二进制组成形式.assets/image-20220806213718774.png)\n\n\n\n- ACC_ANNOTATION\n\n> 表示为一个注解，被ACC_ANNOTATION标识就必须被ACC_INTERFACE标识。\n\n![image-20220806214256368](class文件二进制组成形式.assets/image-20220806214256368.png)\n\n- ACC_SUPER\n\n> 被ACC_SUPER标识的类，调用父类的方法会特殊处理。所有版本的编译器都应该设置这个标志（除了一些低版本的编译器）。jdk1.0.2及其之前版本的编译器生成的`class`文件标志位都没有ACC_SUPER标志。\n>\n> 目前来说我们接触到的编译器都会为我们生成ACC_SUPER标识。\n\n特殊处理指的是什么呢？\n\n子类在调用父类的方法的时候会使用一个叫`invokespecial`指令。\n\n> 每一个方法都有一个`CONSTANT_Methodref_info` 结构来描述这个方法，而这个结构是编译期就决定的，如果此刻类上面没有`ACC_SUPER`标识，那么 `invokespecial`指令就会按照编译器生成的`CONSTANT_Methodref_info`结构来进行父类的调用。\n\n举个例子：以下三个类存在如下继承关系，SonSon的`super.parentMethod();`肯定调用的`Parent`的方法，那么\n\n`SonSon`的`CONSTANT_Methodref_info`结构内肯定存着这么一个信息。\n\n```java\npublic class Parent {\n    void parentMethod() {\n        System.out.println(\"parentMethod\");\n    }\n}\nclass Son extends Parent {\n\n}\nclass SonSon extends Son {\n    void sonSonMethod() {\n        super.parentMethod();\n    }\n}\n```\n\n那么如果此刻如果我们对`Son`进行更新，添加一个`parentMethod`会怎么样呢？（不对SonSon进行重编译），只对Son重编译。如果没有ACC_SUPER标志那么SonSon调用的还是Parent的方法。如果存在ACC_SUPER标识则会特殊处理，去寻找最近的父类进行调用对应的方法。\n\n```java\nclass Son extends Parent {\n    @Override\n    void parentMethod() {\n        System.out.println(\"SonMethod\");\n    }\n}\n```\n\n小结：\n\n> access_flags占用两个字节也就是16位，每一位可以表示一个ACC_FLAG，一个类存在多个ACC_FLAG会通过按位与的方式进行保存。\n>\n> 那么以上只有8个标志，那么还剩余的是为了以后预留的。\n\n\n\n##### 类索引(this_class)\n\n> 类索引的值必须是constant_pool表中的一个有效索引值。constant_pool表在这个索引处的项必须是CONSTANT_CLASS_INFO类型的常量，表示这个Class文件所定义的类或接口。\n\n\n\n##### 父类索引(super_class)\n\n> 父类索引\n>\n> 对于类来说，super_class的值必须为0或者是constant_pool表中的一个有效索引值。如果super_class的值不为0，那么constant_pool表在这个索引处的项必须是CONSTANT_CLASS_INFO类型的常量，表示这个Class文件所定义的直接父类。==当前类的直接父类以及他的所有间接父类的access_flag都不可以带有ACC_FINAL标识==。\n>\n> 对于接口来说也是一样super_class必须为constant_pool表中的一个有效索引。且constant_pool在此索引处的项必须为代表java.lang.Object的CONSTANT_CLASS_INFO类型的常量。\n>\n> 如果class文件的`Super_class`的值为0，那么它只能定义为`java.lang.objec`类，只有它没有父类。\n\n\n\n##### 接口计数器(interfaces_count)\n\n> 标识当前类直接接口的数量\n\n\n\n##### 接口信息数据区\n\n> Interfaces[interface_coount]。接口信息表Interfaces[]中的每一个成员的值都必须为constant_info表中的一个有效的索引值。constant_pool在对应索引处的项必须是CONSTANT_CLASS_INFO类型的常量。\n>\n> 且接口信息表中的索引值是有序的，即编译器生成的class文件实现接口的顺序。\n\n\n\n##### 字段计数器(fields_count)\n\n> 字段计数器，表示当前类声明的类字段和实例字段（成员变量）的个数。\n\n\n\n##### 字段信息数据区(fields[])\n\n> 字段表，长度为fields_count。字段表fields[]中的每一个成员都是`fields_info`结构的数据项，用于描述该字段的完整信息。\n>\n> 字段表`fields[]`用于记录当前接口或类声明的所有字段信息，但不包括从父类或父接口中继承过来的部分。\n\n\n\n##### 方法计数器(method_count)\n\n> 方法计数器，表示当前类定义的方法个数。\n\n\n\n##### 方法数据区(methods[])\n\n> 方法表，长度为method_count。方法表methods[]中的每一个成员都是`method_info`结构的数据项，用于描述该方法的完整信息。\n>\n> 如果一个`method_info`结构中的`access_flags`既不包含`ACC_NATIVE`也不包含`ACC_ABSTRACT`标识。那么标识当前方法可以被`jvm`直接加载，而不需要依赖其他类。\n>\n> 方法表`methods[]`记录着当前接口或接口中定义的所有方法，包括静态方法、实例方法、初始化方法(init 、cinit)。不包括从父类或父接口中继承过来的方法。\n\n\n\n##### 属性计数器\n\n> 属性个数\n\n\n\n##### 属性数据区\n\n> `attributes[]`。属性表中的每一项都是一个`Attribute_info`结构\n\n\n\n### 小结\n\n\n\n> 根据以上总结，一个class文件可以表示为\n\n```java\nclassFile{\n  u4          \t\t\tmagic;//魔数\n  u2         \t\t\t\tminor_version;//服版本号（一般不用管）\n  u2         \t\t\t\tmajor_version;//主版本号  jdk1.0为45，高本版递增\n  u2\t\t\t\t\t\t\t\tconstant_pool_count;//常量池计数器\n  cp_info\t\t\t\t\t\tconstant_pool[constant_pool_count-1];//常量池数据区\n  u2\t\t\t\t\t\t\t\taccess_flags;//访问标志\n  u2\t\t\t\t\t\t\t\tthis_class;//类索引。是constant_pool中的一个有效索引\n  u2\t\t\t\t\t\t\t\tsuper_class;//父类索引。只有object此项为0\n  u2\t\t\t\t\t\t\t\tinterfaces_count;//直接接口数量\n  u2\t\t\t\t\t\t\t\tinterfaces[interfaces_count];//接口数据区\n  u2\t\t\t\t\t\t\t\tfields_count;//类的成员变量数量\n  field_info\t\t\t\tfields[fields_count];//类的成员变量数据区\n  u2\t\t\t\t\t\t\t\tmethods_count;//定义方法个数\n  method_info\t\t\t\tmethods[methods_count];//方法数据区\n  u2 \t\t\t\t\t\t\t  attributes_count;//属性数量\n  attribute_info\t  attributes[attributes_count]//属性数据区\n}\n```\n\n\n\n<hr>\n\n### class常量池\n\n> class常量池是很重要的一个数据区。\n\n#### class常量池在什么位置\n\n> class常量池在`class`文件中的什么位置？\n>\n> 如下图，在主版本号之后的区域就是常量池相关的数据区了。首先是两个字节的常量池计数器，紧接着就是常量池数据区。\n\n\n\n<img src=\"class文件二进制组成形式.assets/image-20220807010456561.png\" alt=\"image-20220807010456561\" style=\"zoom:67%;\" />\n\n> 常量池计数器的数值为何比常量池项数量大一？\n\n常量池计数器是从1开始计数的而不是0，如果常量池计数器的数值为15那么常量池中常量项(cp_info)的数量就为14。常量池项个数 = constant_count-1。\n\n将第一位空出来是有特殊考虑的，当某些索引表示不指向常量池中任何一个常量池项的时候，可以将索引设置为0。\n\n\n\n#### 有哪些cp_info\n\n> 常量池项(cp_info)记录着class文件中的字面量信息。那么存在多少中cp_info，以及如何区分。\n\ncp_info中存在着一个tag属性，jvm会根据tag值来区分不同的常量池项\n\n| Tag  | 结构                             | 说明                     |\n| ---- | -------------------------------- | ------------------------ |\n| 1    | CONSTANT_Utf8_info               | 字符串常量值             |\n| 3    | CONSTANT_Integer_info            | INT类型常量              |\n| 4    | CONSTANT_Float_into              | FLOAT类型常量            |\n| 5    | CONSTANT_Double_info             | DOUBLE类型常量           |\n| 7    | CONSTANT_Class_info              | 类或接口全限定名常量     |\n| 8    | CONSTANT_String_info             | String类型常量对象       |\n| 9    | CONSTANT_Fieldref_info           | 类中的字段               |\n| 10   | CONSTANT_Methodref_info          | 类中的方法               |\n| 11   | CONSTANT_InterfaceMethodref_info | 所实现接口的方法         |\n| 12   | CONSTANT_NameAndType_info        | 字段或方法的名称和类型   |\n| 15   | CONSTANT_MethodHandler_info      | 方法句柄                 |\n| 16   | CONSTANT_MethodType_info         | 方法类型                 |\n| 18   | CONSTANT_InvokeDynamic_info      | 表示动态的对方法进行调用 |\n|      |                                  |                          |\n\n\n\n##### int和float的cp_info\n\n> int的常量池项结构为`CONSTANT_Integer_info`。float的常量池项结构为`CONSTANT_Float_info`。且这两种数据类型所占空间都为四个字节。所对应的结构如下：\n\n![image-20220807134442528](class文件二进制组成形式.assets/image-20220807134442528.png)\n\n\n\n###### 例子1\n\n> 编译过后使用`javap -v分析`\n\n```java\npublic class CpInfoIntAndFloat {\n    private final int i1 = 1;\n    private final int i2 = 1;\n\n    float f1 = 20f;\n    Float f2 = 20f;\n    Float f3 = 20f;\n    float f4 = 30f;\n}\n```\n\n> 确实在constant_pool中存在着我们预期的cp_info结构。且不存在重复结构。\n\n<img src=\"class文件二进制组成形式.assets/image-20220807144906700.png\" alt=\"image-20220807144906700\" style=\"zoom:67%;\" />\n\n> 但是这里我们特意将int的修饰符设置为final类型的。如果不是final类型的对于int i1 = 1来说并不会在constant_pool中存入`CONSTANT_Integer_info`结构体。我们可以试一下\n\n###### 例子2\n\n```java\npublic class CpInfoIntAndFloat2 {\n    private  int i1 = 0;\n    private  int i2 = 5;\n    private  int i3 = -127;\n    private  int i4 = 128;\n\n    private  int i5 = 32767;\n    private  int i6 = -32768;\n\n    static int i11 = 1;\n}\n```\n\n使用`javap -v  CpInfoIntAndFloat2> 1.txt`命令将分解信息输出到1.txt文件方便查看：\n\n> 发现并没有Integer相关的cp_info。且我们声明了一个 `static int i11 = 1;`静态的成员变量(类变量),编译器会为我们生成一个`cinit`方法。我们去查看一下`init`和`cinit`方法。\n\n<img src=\"class文件二进制组成形式.assets/image-20220807151725367.png\" alt=\"image-20220807151725367\" style=\"zoom:50%;\" />\n\n> 查看一下`init`方法。发现在实例初始化的时候会调用`init`方法，会使用`iconst_X`命令、`bipush`命令以及`sipush`为我们的int类型变量赋值。对于较小的int类型变量（小于5）会使用`iconst_X`命令，不需要参数，直接赋值。对于较大的（-128,127）使用bipush,带上数值大小参数，直接赋值，对于再大一点的数值使用`sipush`命令赋值。\n\n![image-20220807151815676](class文件二进制组成形式.assets/image-20220807151815676.png)\n\n###### 例子3\n\n> 那么对于比32767大也就是比short范围大的int类型呢？\n\n结论是会存入constant_pool常量池的。\n\n```java\npublic class CpInfoIntAndFloat3 {\n    private  int i1 = 32768;\n    private  int i2 = 32769;\n    private  int i3 = 42768;\n}\n```\n\n![image-20220807152348377](class文件二进制组成形式.assets/image-20220807152348377.png)\n\n> 查看一下init方法看对于存入constant_pool常量池的项，是如何赋值的\n\n会使用ldc命令从常量池中取，然后再赋值。\n\n![image-20220807152445635](class文件二进制组成形式.assets/image-20220807152445635.png)\n\n###### 结论\n\n> 那我么就可以得出结论了：\n\n- iconst_x命令，会对 0 - 5范围内的值进行直接赋值，且无需参数\n- bipush(byteintpush)命令，会对 -128 127 范围内的值进行直接赋值，需要携带字面量参数\n- sipush(shortintpush)命令，会对 -32768 32767范围内的值进行直接赋值，需要携带字面量参数\n- 超过如上范围的值，会存入constan_pool常量池，使用LDC命令取值，再赋给对应字段\n\n\n\n##### long&double\n\n> Long的常量池项结构为`CONSTANT_Long_info`。double的常量池项结构为`CONSTANT_Double_info`。且这两种数据类型所占空间都为8个字节。所对应的结构如下：\n\n![image-20220807153756946](class文件二进制组成形式.assets/image-20220807153756946.png)\n\n会将对应结构存入constant_pool中，且所有使用到对应结构的字段都会指向它\n\n![image-20220807154027858](class文件二进制组成形式.assets/image-20220807154027858.png)\n\n<img src=\"class文件二进制组成形式.assets/image-20220807154119650.png\" alt=\"image-20220807154119650\" style=\"zoom:50%;\" />\n\n##### String的cp_info\n\n> String的常量池项结构为`CONSTANT_String_info`。所对应的结构如下：\n\n![image-20220807164705511](class文件二进制组成形式.assets/image-20220807164705511.png)\n\n> String常量在常量池中的表示，为一个`CONSTANT_String_info`结构体，这个结构体除了一个tag外，还有一个指向`CONSTANT_Utf8_info`结构体的索引string_index。\n>\n> 所以说每一个字符串在编译的时候，编译器都会为其生成一个不重复的`CONSTANT_String_info`结构体，并放置于`CONSTANT_poll`class常量池中，而这个结构体内的索引string_index会指向某个`CONSTANT_Utf8_info`结构体，在`CONSTANT_Utf8_info`结构体内才正真存储着字符串的字面量信息。\n\n`CONSTANT_Utf8_info`结构体的结构为：\n\n其中legth为字节数组长度\n\nbytes[length]存储着字符串字面量信息的字符数组\n\n![image-20220807165558000](class文件二进制组成形式.assets/image-20220807165558000.png)\n\n> 写一个类只有String类型的变量，并使用javap分析\n\n```java\npublic class CpInfoStringAndUtf8 {\n    String str1 = \"abc\";\n    String str2 = \"abc1\";\n    \n    public void test() {\n        String str = \"abc\";\n        System.out.println(str == str1);\n    }\n}\n```\n\n<img src=\"class文件二进制组成形式.assets/image-20220807164504843.png\" alt=\"image-20220807164504843\" style=\"zoom: 50%;\" />\n\n> 整合起来的结构就是这个样子的：\n\n![image-20220807165610084](class文件二进制组成形式.assets/image-20220807165610084.png)\n\n\n\n##### 类(class)的cp_info\n\n> 定义的类和在类中引用到的类在常量池中如何组织和存储的？\n\n> 和String类型一样涉及到两个结构体，分别是：`CONSTANT_Class_info`和`CONSTANTT_Utf8_info`。编译器会将，定义和引用到类的完全限定名称以二进制的形式封装到`CONSTANT_Class_info`中，然后放入到class常量池中。结构如下：\n\n![image-20220807172355220](class文件二进制组成形式.assets/image-20220807172355220.png)\n\n###### 类的完全限定名称和二进制形式的完全限定名称\n\n> 类的完全限定名称：`com.roily.jvm.day03.CpInfoIntAndFloat3`,以点·分隔\n>\n> 二进制形式的类的完全限定名称：编译器在编译时，会将点替换为/，然后存入class文件，所以称呼`com\\roily\\jvm\\day03\\CpInfoIntAndFloat3`为二进制形式的类的完全限定名称。\n\n###### 具体如何存储\n\n写一个类：\n\n```java\npublic class CpInfoClass {\n    /**\n     * new关键字,真正使用到了该类。编译器会将对应的Class_info存入class常量池\n     */\n    StringBuilder sb = new StringBuilder();\n    /**\n     * 只是单纯声明,并没有真正使用到了该类。编译器不会会将对应的Class_info存入class常量池\n     */\n    StringBuffer sb2;\n}\n```\n\njavap -v分析：\n\n> 存在三个`CONSTANT_Class_info`结构体\n>\n> `CpInfoClass`表示当前类\n>\n> `StringBuilder`是我们通过`new`关键字直接使用的\n>\n> `Object`是所有类的父类，所以即便不显示继承，也会生成一个class_info\n\n对于StringBuffer来说，当前类并没有真正使用到它，所以编译器不会为其生成对应的class_info结构体\n\n<img src=\"class文件二进制组成形式.assets/image-20220807173233303.png\" alt=\"image-20220807173233303\" style=\"zoom:50%;\" />\n\n以CpInfoClass进一步分析：\n\nCpInfoClass对应的`CONSTANT_Class_info`在常量池中的索引为#5，其内部的class名称索引指向#23，#23对应的是一个`CONSTANT_Utf8_info`的这么一个结构体，存储的是CpInfoClass的二进制形式的完全限定名称。\n\n画个图表示：\n\n![image-20220807174150819](class文件二进制组成形式.assets/image-20220807174150819.png)\n\n\n\n> 小结：\n\n- 对于一个类或者接口，jvm编译器会将其自身、父类和接口的信息都各自封装到`CONSTANT_Class_info`中，并存入`CONSTANT_POO`常量池中\n- 只有真正使用到的类jvm编译器才会为其生成对应的`CONSTANT_Class_info`结构体，而对于未真正使用到的类则不会生成，比如只声明一个变量`StringBuffer sb2;`\n\n\n\n##### 字段的cp_info\n\n> 在定义一个类的时候以及在方法体内都会定义一些字段，这些字段在常量池中是如何存储的呢？\n>\n> 涉及到三个结构体，分别是：`CONSTANT_Fieldref_info`、`CONSTANT_Class_info`和`        CONSTANT_NameAndType_info`\n\n写一个类定义两个字段，并为其生成getter  and  setter方法：\n\n```java\npublic class CpInfoField {\n    StringBuilder sb = new StringBuilder();\n    StringBuffer sb2;\n\t\t//getter  and setter\n}\n```\n\n使用javap -v 分析：\n\n> jvm在编译的时候会为每一个字段生成对应的`CONSTANT_Field_info`结构体，并且在使用到该字段的地方都会指向这个结构体。\n>\n> `CONSTANT_Field_info`结构体内保存着，class_index和nameAndType_index的索引，用于指向这两个结构体。\n\n<img src=\"class文件二进制组成形式.assets/image-20220807203311563.png\" alt=\"image-20220807203311563\" style=\"zoom: 50%;\" />\n\n> 通过上面的分析我们可以了解到，一个`CONSTANT_Field_info`结构的大概样子。\n>\n> `CONSTANT_Field_info`内部包含一个类的索引和一个NameAndType的索引，而类的索引内部包含一个类名(name_index)索引，那么这个NameAndType其内部是什么样子的？\n>\n> `CONSTANT_NameAndIndex_info`内部包含一个 name_index索引指向程序员自定义的字段名称（比如说上面定义的sb sb2），和一个字段描述的索引`descriptor_index`指向该字段描述的索引(比如上面定义的`Ljava/lang/StringBuilder;`)\n\n![image-20220807203919295](class文件二进制组成形式.assets/image-20220807203919295.png)\n\n![image-20220807204503481](class文件二进制组成形式.assets/image-20220807204503481.png)\n\n###### 那么一个字段的结构信息就可以表示为：\n\n>  field字段描述信息 = field字段所属的类 .  field字段名称 : field字段描述\n\n\n\n###### 一个`CONSTANT_Field_info`与其他结构体的关系可以表示为：\n\n<img src=\"class文件二进制组成形式.assets/image-20220807205719621.png\" alt=\"image-20220807205719621\" style=\"zoom:50%;\" />\n\n\n\n###### NameAndType\n\n> `CONSTANT_NameAndType_info`结构体中关于字段的描述：\n\n- 对于基本数据类型\n\n| 类型    | 描述 | 说明             |\n| ------- | ---- | ---------------- |\n| byte    | B    | 表示一个字节整型 |\n| short   | S    | 短整型           |\n| int     | I    | 整型             |\n| long    | J    | 长整型           |\n| float   | F    | 单精度浮点数     |\n| double  | D    | 双精度浮点数     |\n| char    | C    | 字符             |\n| boolean | Z    | 布尔类型         |\n|         |      |                  |\n\n- 对于引用类型来说\n\nL<ClassName>。\n\n比如StringBuilder类型的描述信息为：`Ljava/lang/StringBuilder`\n\n\n\n- 对于数组类型来说\n\n[<descriptor>   一个左中括号加上数组元素类型。\n\n比如long[] ls = {1L,2L};对应描述信息为：`[J`\n\n\n\n###### 小结\n\n- jvm编译器会为每一个有效使用的字段生成一个对应的`CONSTANT_Field_info`结构体，该结构体内包含了一个`class_index`指向该字段所在类的结构体索引值，和一个`name_and_type_index`指向该字段名称和描述信息的结构体索引值\n- 如果一个字段没有被使用到，jvm不会将其放入常量池中\n\n\n\n\n\n##### 方法的cp_info\n\n> 和字段的cp_info相似，jvm编译时会将每一个方法(前提是使用到)包装成一个`CONSTANT_Methodref_ingo`结构体，放入常量池，该结构体内存在两个索引值分别是`Class_index`和`name_and_type_index`。\n\n![image-20220807215324127](class文件二进制组成形式.assets/image-20220807215324127.png)\n\n写一个类：添加一个test方法对getter setter 方法进行引用：\n\n```java\npublic class CpInfoMethod {\n    StringBuilder sb = new StringBuilder();\n    StringBuffer sb2;\n\t\t//getter  and  setter\n    public void test(){\n        getSb();\n        setSb(new StringBuilder(\"xxx\"));\n    }\n}\n```\n\njavap -v分析：\n\n![image-20220807214416830](class文件二进制组成形式.assets/image-20220807214416830.png)\n\n###### 一个方法的结构体信息表示：\n\n方法结构体信息 = 方法所属的类 .   方法名称:(参数说明)返回值\n\n【(参数说明)返回值】就是方法的描述信息。\n\n比如我有一个方法：String getMsg();  那么描述信息就可以表示为：()Ljava/lang/String\n\n==如果返回值是Void的话，则表示为V==\n\n\n\n\n\n##### 接口方法的cp_info\n\n>  类中引用到某个接口定义的方法\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/foot/jvm/class文件二进制组成形式.md b/foot/jvm/class文件二进制组成形式.md
--- a/foot/jvm/class文件二进制组成形式.md	(revision 90f7a170a0193be6feac9f3859d7ac72da50f9d4)
+++ b/foot/jvm/class文件二进制组成形式.md	(date 1659971755791)
@@ -71,7 +71,7 @@
 
 使用：
 
-view ->首位 bytecode with JclassLib
+view ->show  bytecode with JclassLib
 
 <img src="class文件二进制组成形式.assets/image-20220807175157830.png" alt="image-20220807175157830" style="zoom:50%;" />
 
Index: foot/读书笔记/java成神之路(基础)/java成神之路(基础).md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>## java成神之路读书笔记\n\n> 借鉴地址Gitee Pages 完整阅读:http://hollischuang.gitee.io/tobetopjavaer\n>\n> 作者：Hollis ，阿里巴巴技术专家，51CTO 专栏作家，CSDN 博客专家，掘金优秀作者， 《程序员的三门课》联合作者，《Java 工程师成神之路》系列文章作者;热衷于分享计算 机编程相关技术，博文全网阅读量数千万。\n\n\n\n### 面向对象\n\n> java是一种面向对象的编程语言\n\n#### 面向过程\n\n> 什么是面向过程？\n\n面向过程(Procedure Oriented)是一种以过程为中心的编程思想，是一种自顶而下的编程模式。简单来说，面向过程的开发范式中，程序员需要把问题分解成一个一个步骤，每个步骤用函数实现，依次调用即可。\n\n面向过程的编程语言以诸多流程控制语句来实现一个功能，整体表现为流程化。\n\n**优缺点**\n\n> 优点\n\n流程化，执行效率高\n\n> 缺点\n\n维护困难，复用性差\n\n\n\n#### 面向对象\n\n面向对象（Object Oriented），java是一种面向对象的编程语言。在面向对象的开发过程中，回将某件事情进行抽象，将一件事物的方法属性封装到一个类中，通过多个类之间的组合调用来实现某种功能。\n\n\n\n#### 面向对象三大基本特征\n\n> 封装、继承、多态\n\n##### 封装\n\n> 如果一个类希望其他类访问其内部属性存在不同限制，那么我们可以将其方法和属性设置不同的访问权限，这就是封装。\n\n访问级别有以下几种\n\n- public    所有类都可以访问\n- protected   受保护的，默认访问级别，同级别包下的类可以访问\n- private  私有的，任何其他类都不可以访问，只供其内部访问\n\n> 一般来说如果不是清楚的知道一个类的属性或方法需要被其他类访问，我们会将其设置为私有属性，不对外暴露。\n\n\n\n##### 继承\n\n> 继承是java为我们提供的可以实现代码复用的一种能力。可以拥有现有类的所有属性和功能（包括私有属性和私有方法），并且可以在此基础上进行扩展。\n\n\n\n##### 多态\n\n> \u200B\tjava中的多态指的是同一种操作，作用于不同的实例可以有不同的结果。是一种运行时状态，只有在运行期间才会直到调用的具体方法是什么。\n>\n> \u200B\t具体表现形式为父类或接口的引用指向子类或实现类的实例。调用父类或接口中定义或声明的方法，会根据传入的不同的子类或实现类来表现不同的逻辑。\n\n多态机制使具有不同内部结构的对象可以共享相同的外部接口。\n\n\n\n> 编译期&运行期\n\n编译期指的是，将源代码编译成另一个中间语言，在此期间会做一些代码规范检查，以及编译期间代码优化。\n\n运行期，指的是程序运行在内存中，进行交互。\n\n###### 编译期间多态\n\n> 在编译期间已经明确知道，具体类型，知道调用什么方法。\n\n比如说方法重载、可以通过参数列表的不同确定调用的具体方法。\n\n###### 运行期多态\n\n> 指的是在运行期间才会确认具体类型，才会知道调用的方法，需要`extends``implament`关键字一层一层去找。\n\n比如说使用父类或接口的引用，指向子类或实现类的实例。\n\n```java\npublic class Demo {\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException {\n        Class<?> sonClass = Class.forName(\"com.roily.booknode.javatogod._01faceobj.extendsiscompile.Son\");\n        Person son = (Person) sonClass.newInstance();\n        son.method1();\n        Class<?> daughterClass = Class.forName(\"com.roily.booknode.javatogod._01faceobj.extendsiscompile.Daughter\");\n        Person daughter = (Person) daughterClass.newInstance();\n        daughter.method1();\n    }\n}\n\nclass Person {\n    void method1() {\n        System.out.println(\"method1\");\n    }\n}\n\nclass Son extends Person {\n    @Override\n    void method1() {\n        System.out.println(\"son method01\");\n    }\n}\nclass Daughter extends Person {\n    @Override\n    void method1() {\n        System.out.println(\"Daughter method01\");\n    }\n}\n```\n\n![image-20220729135114407](java成神之路(基础).assets/image-20220729135114407.png)\n\n\n\n#### 重写和重载\n\n> 重写（Overriding）和重载（Overloading）是两个比较重要的概念。\n\n##### 重载\n\n> 指的是在同一个类中，多个方法的方法名称相同而方法签名不同的现象称为重载，这些方法互称为重载方法。\n\n方法签名：方法名+参数列表。（也就是方法名相同，参数列表不同才会构成重载）\n\n返回类型不同不会构成重载。\n\n- 方法名相同，参数列表不同\n- 可以改变返回类型\n- 可以修改访问修饰符\n- 可以声明新的检查异常\n- 重载可以发生在一个类中，或在子类和父类中\n\n\n\n##### 重写\n\n> 严格意义上指的是子类中定义了和父类相同方法签名，且符合重写要求的方法，那么称子类重写了父类的方法。\n>\n> 接口声明抽象方法，其实现类实现抽象方法，对应方法上可以加上@OverWriting注解，也可以称为重写，更多的称为实现。\n\n```java\npublic class OverWriting {\n    public static void main(String[] args) {\n        final Animal dog = new Dog();\n        dog.bark();\n    }\n}\nclass Animal {\n    void bark() {\n        System.out.println(\"动物叫\");\n    }\n}\nclass Dog extends Animal {\n    @Override\n    void bark() {\n        System.out.println(\"狗叫\");\n    }\n}\n```\n\n`输出：狗叫`\n\n> 这里子类实例指向父类引用，是多态的表现行式，编译期间会去检查父类中是否存在对应调用方法。而运行期间具体需要调用哪个方法，需要根据具体指向的实例来决定\n\n\n\n方法重写的条件需要具备以下条件和要求：\n\n> 两同两小一大\n\n- 两同（方法签名相同）\n  - 方法名相同\n  - 参数列表相同\n\n- 两小\n  - 返回类型的范围需要相等或更小（比如父类返回ArrayList子类就不能返回list）\n  - 抛出的检查异常范围要比父类被重写方法要小\n- 一大\n  - 访问级别限制，比被重写方法访问范围要大(即父类是protected的那么子类重写的方法不能申明为private)\n\n> 其他\n\n- 不能重写被final标识的方法\n- 重写的前提是继承\n\n```java\nclass Person {\n    void method1(int a, int b) {\n        System.out.println(\"XX\");\n    }\n    ArrayList<Integer> method2() {\n        return null;\n    }\n}\nclass Student extends Person {\n    /**\n     * 两同\n     * - 方法名和参数列表相同\n     */\n    @Override\n    void method1(int a, int b) {\n        System.out.println(\"XX\");\n    }\n    /**\n     * 两小\n     * - 返回参数要比被重写方法要小（范围）\n     */\n    //@Override\n    //List<Integer> method2() {\n    //    //通过不了编译\n    //    return null;\n    //}\n}\n```\n\n> 子类的返回范围比父类的大，通过不了编译，反过来就行\n\n\n\n#### 继承&实现\n\n> 继承的关键字`extends`，实现关键字`implements`。\n\n\n\n##### 继承\n\n> 通过继承可以拥有父类的所有属性和方法，实现代码的重用。继承可以发生在类与类之间，这个类可以是具体的也可以是抽象的，同时继承也可以发生在接口与接口之间。\n\n> 如果说可以从某个类中抽出来可以供于公共使用的功能，那么就可以抽出一个父类出来，其他类去继承这个父类，以继承的方式来实现对代码的重用。但前提是这个抽出来的这个父类得保持稳定，也就是少量修改，且这个父类得对其他类都得适用。\n\n一般来说不会使用继承来实现重用，特别是继承至具体的类，如果说非得继承可以继承至抽象类。\n\n\n\n##### 实现\n\n> 实现发生在类与接口或抽象类之间，如果说一组业务的处理方式是一样的那么就可以制定抽象（制定标准），具体业务去实现定义的抽象\n\n```java\n/**\n * 可以实现一个接口\n */\ninterface IPerson{\n    /**\n     * 抽象方法\n     */\n    void method();\n}\nclass Teacher implements IPerson{\n\n    @Override\n    public void method() {\n        \n    }\n}\n\n/**\n * 可以是类实现抽象类的抽象方法\n */\nabstract class AbstractPerson{\n    \n    abstract void method();\n    \n}\nclass StudentImpl extends AbstractPerson{\n    \n    @Override\n    void method() {\n        \n    }\n}\n\n/**\n * 可以是抽象类实现接口\n */\nabstract class AbstractPersonX implements IPerson{\n    @Override\n    public void method() {\n\n    }\n}\n```\n\n\n\n\n\n#### java单继承\n\n> `java`通过`extends`关键字实现继承，且不支持多继承。\n\n##### 为什么\n\n> 菱形问题：假设B和C都继承自A，B和C都继承了父类A的所有属性和方法，如果java支持多继承的话，此刻有一个D继承自B和C，那么类D就同时拥有类B和类C的所有属性和方法，并且类D继承了两份来自于A的属性和方法，拥有同名属性和相同方法签名的方法是通过不了编译的，且如果通过编译，在调用的时候也会产生歧义。\n\n<img src=\"java成神之路(基础).assets/image-20220728231808420.png\" alt=\"image-20220728231808420\" style=\"zoom:50%;\" />\n\n##### java可以多实现\n\n> java不支持多继承但是支持多实现\n\n如下例子，我们在InterfaceA和InterfaceB中定义了两个同名的方法，然后使用ClassC实现它们，发现实现类对于相同方法只实现了一次。\n\n```java\n/**\n * 但是java可以多实现，且java8之后接口中可以定义default方法\n */\ninterface InterfaceA {\n    void method1();\n}\ninterface InterfaceB {\n    void method1();\n    \n    void method2();\n}\nclass ClassC implements InterfaceA, InterfaceB {\n    @Override\n    public void method1() {\n        System.out.println(\"method1\");\n    }\n    @Override\n    public void method2() {\n        System.out.println(\"method2\");\n    }\n}\n```\n\n> 对于接口而言它只是一个标准、抽象，实现类按照约定实现标准。方然也可以指定标准，使用某个接口的引用指向实现类的实例。\n\n```java\n@Test\npublic void test1() {\n    InterfaceB classC1 = new ClassC();\n    InterfaceA classC2 = new ClassC();\n}\n```\n\n> 接口中可以定义default方法，且我们可以使用Implement从多个接口中继承得到多个默认方法，特别的如果说两个接口存在相同方法签名的方法，实现类会被要求强制重写同名方法签名的方法来解决菱形问题。\n\n```java\ninterface InterfaceC {\n    default void method1() {\n        System.out.println(\"InterfaceC default1方法\");\n    }\n}\ninterface InterfaceD  {\n    default void method1() {\n        System.out.println(\"InterfaceD default1方法\");\n    }\n}\n/**\n * 可以使用implement从多个接口中得到多个default方法，\n * 如果存在菱形问题，会强制要求实现类重写同名方法\n */\nclass ClassD implements InterfaceC, InterfaceD {\n    @Override\n    public void method1() {\n        InterfaceC.super.method1();\n    }\n}\n```\n\n\n\n\n\n#### 五大基本原则\n\n> \u200B\t面向对象五大基本原则，指导程序员编码，符合五大基本原则的程序，健壮性、可维护性和可扩展性都大大提高。\n\n##### 五大基本原则，都旨在：\n\n- 高内聚、低耦合\n- 面向抽象、接口，而不是面向具体、实现\n\n##### 单一职责\n\n> 适用于方法、接口和类。一个类的职责尽量单一，只有一个引起它的变化。\n\n对于方法而言，我们一般都遵守其单一职责原则\n\n对于接口而言，抽象方法尽量要求要少，如果方法太多可以进行接口拆分\n\n对于类而言，一般来说都不会严格遵守单一职责，比如说有一个类UserService，进行堆用户的增删改查，那么这个类想要严格遵守大一职责，完全可以拆分为四个类。\n\n所以说，单一职责尽量遵守，类、接口、方法不要过于臃肿。在业务要求基础之上，合理遵守。\n\n\n\n##### 开闭原则\n\n> 对扩展开放、对修改关闭。\n\n1、对扩展开放，意味着有新的需求时，可以在现有代码上进行扩展，以适应新的变化。\n\n2、对修改关闭，当软件或系统一旦设计完成，可以独立完成工作，而不要其进行任何修改的尝试\n\n> 开闭原则的重点在于，面向接口、抽象编程而不是面向实现、具体编程。\n>\n> 因为抽象也就是接口相对稳定，接口定义了一套标准，如果说接口添加新的抽象方法，那么就必须修改其实现类，所以说对于修改是关闭的。\n>\n> 而如果说现在有了一个新的需求，可以通过实现现有接口定义一个新的类，配合多态可以对当前系统功能进行扩展，所以说对扩展开放。\n\n> 而不能面向具体，一般来说会以继承或组合的方式实现具体类的复用。具体并没有一套标准，也就是说父类修改对应逻辑，并不会要求子类修改，也就是对修改开放，违背开闭原则。\n\n##### 里氏替换原则\n\n> 里氏替换原则知道我们如何使用继承，是一种编程思想。\n>\n> 要求软件实体：子类必须能够替换其基类，并且不改变业务逻辑。\n\n\n\n###### 里氏替换原则和继承的关系\n\n- 继承\n\n  > 继承是java提供的一种可以实现代码复用的语法，但是继承是侵入式的，如果在继承的过程中子类重写了父类的方法，那么说明父类的方法并不通用。\n\n- 里氏替换原则\n\n  > 里氏替换原则是一种编程思想，用于在指导我们合理使用继承。只有遵守了里氏替换原则，才可以实现继承复用。\n\n\n\n##### 依赖倒置原则\n\n> 面向接口编程，依赖于抽象。\n>\n> 具体定义：高层模块不依赖于底层模块，二者都依赖于抽象；抽象不依赖于具体，具体依赖于抽象。\n\n\n\n##### 接口隔离原则\n\n> 将臃肿的大接口拆分为一个个小接口，可以使用接口继承或实现多个接口的方式来实现多个接口定义的抽象方法。\n>\n> 如果一个接口过于庞大，或存在一些不必要实现的方法时，这是一种接口污染。\n\n\n\n#### 继承和组合\n\n> 继承和组合都是java用于实现代码复用的技术之二。优先考虑组合，尽量避免使用继承。\n\n继承\n\n> 继承(Inheritance)是一种联结类与类的层次模型。指的是一个类(子类、子接口)继承另外一个类(父类、父接口)的功能。并且可以增加自己新的功能的能力。继承是一种`AS-a`的关系。\n\n![image-20220729130759731](java成神之路(基础).assets/image-20220729130759731.png)\n\n组合\n\n> 组合(Composition)体现的是整体与部分、拥有的关系，即`has-a`关系。\n\n![image-20220729131252923](java成神之路(基础).assets/image-20220729131252923.png)\n\n\n\n##### 组合&继承关系\n\n继承是一种侵入式的代码结构，在继承关系中，父类的内部细节对于子类是可见的（继承是一种白盒式代码复用），如果父类的代码逻辑发生改变，那么如果子类调用了父类的类方法，子类的逻辑也会随之修改，甚至出错。（继承是一种编译期概念，在编译器就确认了类与类的关系）\n\n组合是将现有对象进行拼装组合来实现较复杂的业务逻辑，将对象作为内部的一个属性，组合进来的对象其内部实现细节是不可见的（黑盒式代码复用）。（如果说组合进来的是一个接口或抽象类型，那么在编译期无法确认其具体类型，只有在运行期间才会确认，所以一定程度上复用性更高）\n\n\n\n###### 对比\n\n|                             组合                             |                         继承                         |\n| :----------------------------------------------------------: | :--------------------------------------------------: |\n|            不会破坏封装，整体类与局部类之间松耦合            | 破坏封装，子类依赖于父类，表现为父类与父类之间前耦合 |\n|         组合进来的可以是一个抽象，因此具有一定扩展性         |                   可通过定义新方法                   |\n| 整体类对组合进来的类进行包装，并可以做一些拓展，就是装饰器模式和代理模式 |                                                      |\n|             创建整体对象的时候，必须创建局部对象             |           创建子类对象，会自动创建父类对象           |\n|                                                              |                                                      |\n\n\n\n##### 如何选择\n\n> 多用组合、少用继承。\n\n- 在同等情况下优先选择组合，利于扩展\n- 继承也有用处，如果当前类必须要向基类进行向上转型，则可以考虑使用继承\n\n\n\n#### 构造函数和默认构造函数\n\n> 构造函数配合`new`关键字，用于创建实例对象和给成员变量赋值。\n\n> 构造函数长什么样子？\n\n构造函数和普通方法很相似，①构造函数名为类名②构造函数不声明返回类型，返回当前类对象\n\n> 构造函数的重载\n\n构造函数根据参数列表的不同可以实现重载。并且可以为特殊属性给与默认值。\n\n```java\nclass Person{\n    int age;\n    String name;\n    String address;\n    Boolean sex;\n    \n    private Person(int age, String name, String address, Boolean sex){\n        this.age = age;\n        this.name = name;\n        this.address = address;\n        this.sex = sex;\n    }\n    public Person(int age, String name, String address){\n        return Person(age,name,address,false);\n    }\n}\n```\n\n\n\n> 如果当前类没有构造函数，编译器会自动生成一个无参构造函数。其成员变量会被赋予默认值。\n\n##### 如果没有构造函数\n\n> 会生成默认构造函数\n\n```java\npublic class ConstructorTest {\n    int i;\n    String str;\n}\n```\n\n反编译后：\n\n```java\npublic class ConstructorTest{\n    public ConstructorTest(){\n    }\n    int i;\n    String str;\n}\n```\n\n##### 如果存在构造函数\n\n> 会使用定义的构造函数，此刻空参构造函数不可用。\n\n```java\nclass ConstructorTest2 {\n    int i;\n    String str;\n    public ConstructorTest2(int i) {\n        this.i = i;\n    }\n}\n```\n\n反编译后：\n\n```java\nclass ConstructorTest2{\n    public ConstructorTest2(int i){\n        this.i = i;\n    }\n    int i;\n    String str;\n}\n```\n\n\n\n#### 类变量、成员变量和局部变量\n\n> `java`中如果从，生命周期，作用域和内存角度去看，`java`的变量分为，类变量、成员变量和局部变量。\n\n##### 类变量\n\n> 类变量被`static`修饰，属于类，生命周期等同于类的生命周期，当一个类被类加载器成功加载到方法区，其就已经存在与方法区。当类被卸载的时候也跟着消失。\n\n##### 成员变量\n\n> 成员变量属于实例，生命周期等同于实例，当一个实例被new出来(或反射等其他方式)，会为其赋值，跟随实例存在于堆内存中。当实例对象被回收时，他也跟着消失。\n\n##### 局部变量\n\n> 局部变量存在于栈内存，一般存在于方法参数，循环体或方法中。\n\n```java\npublic class Demo2 {\n    //类变量\n    final static String str1 = \"abc\";\n    static String str2 = \"abc\";\n \n    //成员变量\n    String str3 = \"abc\";\n\n    //局部变量\n    void method01(String str1) {\n        String str2 = \"abc\";\n        for (StringBuilder str = new StringBuilder(\"abc\"); str.toString().equals(\"abc\"); ) {\n        }\n    }\n}\n```\n\n\n\n#### 访问修饰符\n\n- public  \n\n> 公开的，被public修饰的成员变量和方法对所有类都是可见的，所有类和对象都可以直接访问\n\n- private\n\n> 私有的，被private修饰的成员变量和方法是私有的，只有当前类有访问权限。即便是子类也不可以访问\n\n- protected\n\n> 受保护的，被protected修饰的成员变量和方法是受保护的的，只有当前类和与其处于同一包下的类有访问权限。除非是子类\n\n- default\n\n> 默认的，被default修饰的成员变量和方法是受保护的的，只有当前类和与其处于同一包下的类有访问权限。即便是子类\n\n```java\npackage com.roily.booknode.javatogod._01faceobj.extendsiscompile;\n\npublic class Demo3 {\n    public String str1;\n    String str2;\n    private String str3;\n    protected String str4;\n}\n```\n\n子类不在同一个包下：\n\n```java\npackage com.roily.booknode.javatogod._01faceobj;\n\nimport com.roily.booknode.javatogod._01faceobj.extendsiscompile.Demo3;\npublic class TestDemo extends Demo3{\n    void method1(){\n        System.out.println(str1);\n        System.out.println(str4);\n    }\n}\n```\n\n> 可见如果不指定属性和方法的访问级别的话，默认为default。\n\n\n\n#### java的值传递\n\n> `java`关于关于参数的传递只有值传递，在传递参数的时候会将参数进行拷贝，在方法体中操作的都是拷贝的参数。\n\n##### 形参、实参\n\n> 形参：在定义方法的时候使用的参数，[参数类型+形参名称]，目的是为了接收参数\n>\n> 实参：在抵用方法的时候，被调方法会被传入一个参数 [参数名]，这个参数就叫实参\n\n```java\n/**\n * @param str 形参\n */\nvoid method(String str) {\n}\nvoid method2() {\n    /**\n     * 123  实参\n     * str  实参\n     */\n    method(\"123\");\n    String str = \"123\";\n    method(str);\n}\n```\n\n\n\n##### 为什么说java只有值传递\n\n> 对于基本数据类型来说，它只有值的概念，所以对于基本数据类型的值传递没有任何异议。\n>\n> 对于引用数据类型来说，在对引用类型的参数进行传递的时候，会将参数进行拷贝，在方法体内实际操作的是拷贝的副本，如果我们没有改变引用关系而直接操作属性，是会对原对象有影响的，应为两个引用指向的是同一个对象。\n\n例：\n\n```java\n/**\n * 基本数据类型，只有值的概念\n *\n * @param i\n */\nvoid simpType(int i) {\n    i = 999;\n}\n\nvoid referenceType1(StringBuilder sb) {\n    sb.append(\"追加\");\n}\n\nvoid referenceType2(StringBuilder sb) {\n    sb = new StringBuilder();\n    sb.append(\"追加\");\n}\n\n@Test\npublic void test1() {\n    System.out.println(\"基本数据类型\");\n    int i = 1;\n    System.out.println(\"原值：\" + i);\n    simpType(i);\n    System.out.println(\"修改后：\" + i);\n\n    System.out.println(\"引用数据类型，未修改引用\");\n    final StringBuilder sb1 = new StringBuilder(\"123\");\n    System.out.println(\"原值：\" + sb1.toString());\n    referenceType1(sb1);\n    System.out.println(\"修改后：\" + sb1.toString());\n\n    System.out.println(\"引用数据类型，修改引用\");\n    final StringBuilder sb2= new StringBuilder(\"123\");\n    System.out.println(\"原值：\" + sb2.toString());\n    referenceType2(sb2);\n    System.out.println(\"修改后：\" + sb2.toString());\n}\n```\n\n![image-20220730124812628](java成神之路(基础).assets/image-20220730124812628.png)\n\n- 对于基本数据类型来说，值传递没有异议\n\n原始参数通过值传递给方法。这意味着对参数值的任何更改都只存在于方法的范围内。当方法返回时，参数将消失，对它们的任何更改都将丢失\n\n- 对于引用数据类型来说\n\n也就是说，引用数据类型参数(如对象)也按值传递给方法。这意味着，当方法返回时，传入的引用仍然引用与以前相同的对象。但是，如果对象字段具有适当的访问级别，则可以在方法中更改这些字段的值\n\n> 引用类型传递的时候发生了什么？\n\nvoid referenceType1(StringBuilder sb)方法\n\n<img src=\"java成神之路(基础).assets/image-20220730125529126.png\" alt=\"image-20220730125529126\" style=\"zoom:67%;\" />\n\nvoid referenceType2(StringBuilder sb)方法\n\n<img src=\"java成神之路(基础).assets/image-20220730125718516.png\" alt=\"image-20220730125718516\" style=\"zoom: 67%;\" />\n\n\n\n<hr>\n\n\n### java基础\n\n#### 8大基本数据类型\n\n> Java中有8种基本数据类型分为三大类。\n\n- 字符型\n\nchar\n\n- 布尔型\n\nboolean\n\n- 数值型\n\n1.整型：byte、short、int、long\n\n2.浮点型：float、double\n\n\n\n##### 取值范围\n\n> 在`java`中整数类型属于有符号类型，第一位用来表示符号0代表整数1代表负数。\n\n比如说byte类型，占1字节8位，那么他的表示范围为：\n\n最大值：0111 1111  (2^7^-1)\n\n最小值：1000 0000  (-2^7^)\n\n> 这里会有一个疑问？ 1000 0000 为什么 表示-2^7^呢？不是 -0么？\n\n第一点：在计算机中，数据的运算是以补码进行的[源码反码补码](https://juejin.cn/post/7092566574816559111)\n\n第二点：为了防止 +0 和-0的出现，约定了 补码 1000 0000代表 -128 且移除 -0概念\n\n以一个找规律的方式解释：\n\n| 原码      | 反码      | 补码         | 值（10进制） |\n| --------- | --------- | ------------ | ------------ |\n| 0111 1111 | 0111 1111 | 0111 1111    | 127          |\n| 0000 0000 | 0000 0000 | 0000 0000    | 0            |\n| ......    | ......    | ......       | ......       |\n| 1000 0001 | 1111 1110 | 1111 1111    | -1           |\n| 1000 0010 | 1111 1101 | 1111 1110    | -2           |\n| 1000 0011 | 1111 1100 | 1111 1101    | -3           |\n|           |           | 补码不断减一 |              |\n| 1111 1111 | 1000 0000 | 1000 0001    | -127         |\n| 无法表示  | 无法表示  | 1000 0000    | -128         |\n\n###### 整型\n\n> 取值范围\n\n| 数据类型 | 字节数、位数 | 范围                  |\n| -------- | ------------ | --------------------- |\n| byte     | 1字节、8位   | 【-128，127】         |\n| short    | 2字节、16位  | 【-2^15^, 2^15^-1】   |\n| Int      | 4字节、32位  | 【-2^31^  , 2^31^-1】 |\n| long     | 8字节、64位  | 【-2^63^,  2^63^-1】  |\n|          |              |                       |\n\n> 溢出问题\n\n由于整型的存储空间是有限的，那么就会存在溢出问题\n\n这是因为int只占32位\n\n0111 1111\n\n0111 1111   +\n\n-------------------------\n\n1111 1110（补）=》 1111 1101(反) =》1000 0010(原)   =  -2\n\n```java\n/**\n * 溢出问题\n */\n@Test\npublic void test2() {\n    final int value = Integer.MAX_VALUE + Integer.MAX_VALUE;\n    System.out.println(value);\n}\n```\n\n![image-20220730161454604](java成神之路(基础).assets/image-20220730161454604.png)\n\n###### 浮点数\n\n[定点数&浮点数](https://juejin.cn/post/7126230681465651230/)\n\njava为我们提供了float和double两个浮点数数据类型，分别占4字节32位和8字节64位。\n\n相较于float(单精度),double(双精度)其表示的范围更大，且精度更高。\n\n> 存储结构\n\nfloat:        1位符号位，8位指数位，23位尾数位\n\ndouble： 1位符号位，11位指数位，52位尾数位\n\n> 浮点数存在精度问题，对于金额有严格精度要求的业务，不可使用浮点数来表示金额。\n\n\n\n##### 自动装箱与拆箱\n\n> 八大基本数据类型自动装箱与自动拆箱。八大基本数据类型都有对应的对象类型，自动装箱拆箱的意思就是在需要基本数据类型需要转化为对应的包装类型的时候不需要程序员主动的去操作，而是编译器会自动帮我们去做。\n\n除了`int`对应的包装类型为`Integer`，``char`对应包装类型为`Character`外其他基本数据类型对应的包装类型都为对应基本数据类型首字母大写。\n\n> `Java`是一种面向对象的编程语言，一切皆对象，为何需要基本数据类型？\n\n基本数据类型，相较于对象类型运算简单。\n\n> 包装类型存在的意义？\n\n基本数据类型的包装类型，不仅仅只有值的概念，其扩展了额外的方法(比如equals)。且对于集合框架来说，需要的是对象类型，我们无法将基本数据类型放进去。\n\n\n\n###### 装箱&拆箱\n\n> 装箱\n\n```java\nint i = 10;\nInteger i2 = new Integer(i);\n或\nInteger i2 = Integer.valueOf(i);\n```\n\n> 拆箱\n\n```java\nInteger i = new Integer(10);\nint i2 = i.intValue();\n```\n\n\n\n###### 自动装箱拆箱\n\n> 基本数据类型在需要转化为对应包装类型的时候，无需程序员手动操作\n\n```java\nInteger i = 10;\nint i2 = i;\n```\n\n对其进行反编译可以发现确实自动帮我们转化了：\n\n![image-20220731161053533](java成神之路(基础).assets/image-20220731161053533.png)\n\n> 还有就是集合的泛型是一个对象类型，但是我们在编码的时候可以直接将基本数据类型放入，因为编译器会帮我们自动装箱。\n\n```java\nList<Integer> ints = new ArrayList<>();\nints.add(10);\n```\n\n反编译看：\n\n![image-20220731161803912](java成神之路(基础).assets/image-20220731161803912.png)\n\n###### 问题\n\n> 自动装箱与拆箱虽然给我们编码带来了方便，但也会有一些问题。\n\n- 对于基本数据类型来说，我们只关心其数值，在自动装箱过后，超过缓存范围的包装类型，必须使用equals判等。不可使用 `==`\n- 将包装类型拆箱的过程中，可能胡出现空指针异常(NPE)\n\n```java\nInteger methodRe(){\n    return null;\n}\n@Test\npublic void testRe(){\n    int i = methodRe();\n}\n```\n\n\n\n##### 基本数据类型的池化技术\n\n> 基本数据类型（除了double、float）都有缓存技术，会缓存一定范围内的对象，原因就是`jvm`认为在此范围内的对象很常用，在需要使用的时候直接去池中拿取，而无需重新创建。\n\n\n\n###### 缓存范围\n\n除了`Character`没有负数概念，其缓存范围为：【0,127】,Boolean缓存范围 {true,false}\n\n其他都是：【-128,127】\n\n> 需要注意的是Integer的缓存范围是可配置的，其他的是固定的。\n\n```java\n@Test\npublic void testCache() {\n\n    System.out.println(\"========char==========\");\n    Character c1 = 127;\n    Character c2 = 127;\n    Character c3 = 128;\n    Character c4 = 128;\n    System.out.println(c1 == c2);\n    System.out.println(c3 == c4);\n\n    System.out.println(\"========byte==========\");\n    Byte b1 = 127;\n    Byte b2 = 127;\n    Byte b3 = -128;\n    Byte b4 = -128;\n    System.out.println(b1 == b2);\n    System.out.println(b3 == b4);\n\n    System.out.println(\"========short==========\");\n    Short s1 = 127;\n    Short s2 = 127;\n    Short s3 = -129;\n    Short s4 = -129;\n    System.out.println(s1 == s2);\n    System.out.println(s3 == s4);\n\n    System.out.println(\"========int==========\");\n    Integer i1 = 127;\n    Integer i2 = 127;\n    Integer i3 = -129;\n    Integer i4 = -129;\n    System.out.println(i1 == i2);\n    System.out.println(i3 == i4);\n\n    System.out.println(\"========long==========\");\n    Long l1 = 127L;\n    Long l2 = 127L;\n    Long l3 = -129L;\n    Long l4 = -129L;\n    System.out.println(l1 == l2);\n    System.out.println(l3 == l4);\n  \n    System.out.println(\"========Boolean==========\");\n    Boolean bb1 = false;\n    Boolean bb2 = false;\n    System.out.println(bb1 == bb2);\n}\n```\n\n![image-20220731163829088](java成神之路(基础).assets/image-20220731163829088.png)\n\n\n\n###### new关键字\n\n> 特别的，如果使用`new`关键字创建包装类型，其不会存放于缓存池中，而是存放于堆内存中\n\n```java\n@Test\npublic void testCache2() {\n    Integer i1 = new Integer(128);\n    Integer i2 = 128;\n    System.out.println(i1 == i2);\n    System.out.println(\"equals方法：\" + i1.equals(i2));\n}\n```\n\n![image-20220731163644314](java成神之路(基础).assets/image-20220731163644314.png)\n\n\n\n###### 问题\n\n> 池化技术可有效的节省内存空间，但是也会给我们带来一些问题。对于基本数据类型我们一般来说只关心其数值的大小，并不会去关心其对象具体。所以说对于基本数据类型的判等一般采用equals方法，这样即便数据超过缓存范围也可以准确判断。\n\n\n\n###### 谁负责缓存\n\n> java中会有专门的类负责缓存\n\n有ByteCache用于缓存Byte对象\n\n有ShortCache用于缓存Short对象\n\n有LongCache用于缓存Long对象\n\n有CharacterCache用于缓存Character对象\n\n有IntegerCache用于缓存Integer对象\n\n\n\n##### 对于boolean属性如何命名及返回值如何定义\n\n> `Boolean`作为实体类的属性的时候如何命名？`success`or `isSuccess`?，`Boolean`作为方法返回参数的时候使用基本类型还是包装类型？\n\n\n\n###### boolean作为属性\n\n> 我们测试`Boolean`作为属性？其生成的`getter`和`setter`方法是什么样子的，对RPC框架有什么影响。\n\n存在四种情况：\n\n```java\nBoolean success;\nBoolean isSuccess;\nboolean success;\nboolean isSuccess;\n```\n\n分别举例：\n\n> 使用Lombok自动生成getter和setter方法，编译查看对应代码\n\n```java\n@Data\nclass BooleanType1{\n    boolean success;\n}\n@Data\nclass BooleanType2{\n    boolean isSuccess;\n}\n@Data\nclass BooleanType3{\n    Boolean success;\n}\n@Data\nclass BooleanType4{\n    Boolean isSuccess;\n}\n```\n\n> 编译后查看：\n\n```java\nclass BooleanType1 {\n    boolean success;\n    public boolean isSuccess() {\n        return this.success;\n    }\n    public void setSuccess(boolean success) {\n        this.success = success;\n    }\n}\nclass BooleanType2 {\n    boolean isSuccess;\n    public boolean isSuccess() {\n        return this.isSuccess;\n    }\n    public void setSuccess(boolean isSuccess) {\n        this.isSuccess = isSuccess;\n    }\n}\nclass BooleanType3 {\n    Boolean success;\n    public Boolean getSuccess() {\n        return this.success;\n    }\n    public void setSuccess(Boolean success) {\n        this.success = success;\n    }\n}\nclass BooleanType4 {\n    Boolean isSuccess;\n    public Boolean getIsSuccess() {\n        return this.isSuccess;\n    }\n    public void setIsSuccess(Boolean isSuccess) {\n        this.isSuccess = isSuccess;\n    }\n}\n```\n\n这里可以发现如果属性是基本数据类型的`boolean`生成的getter和setter方法是:isXXXX()和setXXX();\n\n如果是包装类型生成的getter和setter方法是getXXX()和setXXX()\n\n这里可以发现，如果是基本数据类型`boolean`作为属性的话，属性名success和isSuccess其对应的getter和setter方法是相同的。那么如果我们的属性名是isSuccess的话，在部分RPC框架中，得到的getter方法是isSuccess()，会误认为对应的属性名称是success，会导致获取不到属性，从而报出异常。\n\n> 所以说对于实体类如果存在Boolean数据类型的属性，使用包装类型。\n\n###### boolean对序列化的影响\n\n> 使用FastJson  JACKSON、GSON这几个常见JSON序列话对比区别。\n\n> 同样的对于基本数据类型的boolean，对不同的序列话工具会有不同的结果。而对于包装类型则没有影响。\n\nfastjson和jackson是通过反射得到所有的getter方法（getXXX或isXXXX），然后认为 XXXX就是字段名称，并得到对应的值，直接序列化成对应JSON字符串。\n\nGson则是通过反射，遍历对象对应类的属性，再序列话成json字符串。\n\n```java\n@Test\npublic void test() throws JsonProcessingException {\n\n    Gson gson = new Gson();\n    ObjectMapper om = new ObjectMapper();\n\n    BooleanType1 booleanType1 = new BooleanType1(true);\n    System.out.println(\"booleanType1\");\n    System.out.println(\"FastJson:boolean success: => \" + JSON.toJSON(booleanType1));\n    System.out.println(\"Gson:boolean success: => \" + gson.toJson(booleanType1));\n    System.out.println(\"JackSon:boolean success: => \" + om.writeValueAsString(booleanType1));\n\n    BooleanType2 booleanType2 = new BooleanType2(true);\n    System.out.println(\"booleanType2\");\n    System.out.println(\"FastJson:boolean isSuccess: => \" + JSON.toJSON(booleanType2));\n    System.out.println(\"Gson:boolean isSuccess: => \" + gson.toJson(booleanType2));\n    System.out.println(\"JackSon:boolean isSuccess: => \" + om.writeValueAsString(booleanType2));\n\n    BooleanType3 booleanType3 = new BooleanType3(true);\n    System.out.println(\"booleanType3\");\n    System.out.println(\"FastJson:Boolean success: => \" + JSON.toJSON(booleanType3));\n    System.out.println(\"Gson:Boolean success: => \" + gson.toJson(booleanType3));\n    System.out.println(\"JackSon:Boolean success: => \" + om.writeValueAsString(booleanType3));\n\n    BooleanType4 booleanType4 = new BooleanType4(true);\n    System.out.println(\"booleanType4\");\n    System.out.println(\"FastJson:Boolean isSuccess: => \" + JSON.toJSON(booleanType4));\n    System.out.println(\"Gson:Boolean isSuccess: => \" + gson.toJson(booleanType4));\n    System.out.println(\"JackSon:Boolean isSuccess: => \" + om.writeValueAsString(booleanType4));\n}\n```\n\n![image-20220801145946307](java成神之路(基础).assets/image-20220801145946307.png)\n\n> 对于boolean isSuccess 不同的JSON序列化工具，生成的JSON字符串并不是一样的。那么如果对于同一对象使用不同序列化工具序列化和反序列化会产生什么结果？\n\n```java\n@Test\npublic void testSer() throws IOException {\n\n    BooleanType2 booleanType2 = new BooleanType2(true);\n    //使用fastjson序列话\n    String jsonStr = JSON.toJSONString(booleanType2);\n    System.out.println(\"json字符串：=》\" + jsonStr);\n    //分别使用 fastJson 、 GSON  、 JackSon反序列化\n    BooleanType2 t1 = JSON.toJavaObject(JSON.parseObject(jsonStr), BooleanType2.class);\n    System.out.println(\"FastJson反序列化后=》\" + t1);\n\n    ObjectMapper om = new ObjectMapper();\n    BooleanType2 t2 = om.readValue(jsonStr, BooleanType2.class);\n    System.out.println(\"Jackson反序列化后=》\" + t2);\n\n    Gson gson = new Gson();\n    BooleanType2 t3 = gson.fromJson(jsonStr, BooleanType2.class);\n    System.out.println(\"Gson反序列化后=》\" + t3);\n}\n```\n\n![image-20220801152221308](java成神之路(基础).assets/image-20220801152221308.png)\n\n> 还是Gson出现的问题，对于同一个类，使用不同的序列化工具进行，序列话和反序列化，对象会产生前后不一致问题。\n\n同样的对于fastjson和jackson来说，会根据success通过反射来找对应得setter方法，将属性set进去。而Gson会通过反射去找success属性，发现没找打，那么就只能赋予默认值false。\n\n> 又一次证明了只能使用success而不可以使用isSuccess\n\n###### Boolean  or   boolean\n\n> 编码得时候使用Boolean  还是 boolean\n\n- 对于实体类的属性，一律使用包装类型\n- 对于远程调用的接口来说，必须使用包装类型。避免默认值的出现\n- 对于局部变量来说使用基本数据类型\n\n###### 小结\n\n> 对于布尔值如何命名和使用success还是isSuccess。\n\n第一：布尔值命名必须去掉 is\n\n第二：除了局部变量，其他地方一律使用包装类型\n\n#### String\n\n> `String`在`java`中很常用，看似简单，也有很多知识点。\n\n##### 不可变性\n\n对象的不可变性指的是什么？\n\n对象的不可变性指的是在对象创建完成，我们不可以调用方法来修改其属性。\n\n\n\n######  现象\n\n> 在编程中我们常常通过等号和加号来\"修改\"字符串的值，为什么还是不可变得呢？\n\n比如：\n\n```java\nString str1 = \"abc\";\nstr1 = \"123\";\n//\nString str1 = \"abc\";\nstr1 += \"123\"; \n```\n\n这不是修改了么？\n\n> 这里两种方式好像都修改了str1的值，其实是修改了str1的引用，将str1指向了一个新的字符串对象。\n>\n> 对于字符串相加，回收先得到相加后的结果，创建对应字符串，然后赋予引用。\n\n图示：\n\n<img src=\"java成神之路(基础).assets/image-20220731210311597.png\" alt=\"image-20220731210311597\" style=\"zoom:67%;\" />\n\n<img src=\"java成神之路(基础).assets/image-20220731210337273.png\" alt=\"image-20220731210337273\" style=\"zoom:67%;\" />\n\n\n\n###### String为什么是不可变的\n\n> 简单理解一下为什么String不可变\n\n打开`String`类的源码，可以发现`String`底层是一个字符数组，且该属性被`final`修饰：\n\n```java\nprivate final char value[];\n```\n\n那么此刻自然就想到被`final`修饰的对象不可变。\n\n> 其实被`final`修饰的对象不可变指的是，不可以修改其引用，如果说我可以通过调用对象提供的修改方法那么完全是可以修改的。\n\n\n\n那么String类不可变的真正原因是什么呢？\n\n- 首相String类被final修饰，也就是不可以被继承，我们知道继承及侵入式的，不可以继承那么就没有子类可以破坏其不可变性。（不仅仅是String八大基本数据类型的包装类型都是fianl的）\n- String类底层是一个字符数组，其作为String的属性，被private修饰，也就是不提供外部访问\n- String类底层是一个字符数组，其作为String的属性，被final修饰，不可修改字符数组引用\n- 最后一点也是最重要的，String类中未提供任何修改其字符数组的方法（无论是私有的还是公开的），其内部方法返回的都是一个String\n\n\n\n###### String真的不可变吗\n\n> 我们直到`Java`提供了一个很强大的机制，就是反射，那么我们是否可以通过反射来破坏String底层数组的private和final呢？\n\n写一个测试案例：可以通过反射来修改被fianl修饰的属性\n\n```java\n@Test\npublic void testFinal() throws NoSuchFieldException, IllegalAccessException {\n  TestFinal testFinal = new TestFinal();\n  System.out.println(testFinal.sb + \":\" + VM.current().addressOf(testFinal.sb));\n  final Field sb = testFinal.getClass().getDeclaredField(\"sb\");\n  final StringBuilder abc = new StringBuilder(\"abc\");\n  //反射破坏不可修改\n  sb.setAccessible(true);\n  sb.set(testFinal, abc);\n  System.out.println(testFinal.sb + \":\" + VM.current().addressOf(testFinal.sb));\n}\nclass TestFinal {\n    final StringBuilder sb = new StringBuilder(\"123\");\n}\n```\n\n结果很意外，被final修饰的属性其值可以被改变，且其内存地址也发生了改变，也就是sb的引用也别修改了\n\n![image-20220731214248215](java成神之路(基础).assets/image-20220731214248215.png)\n\n同理我们尝试修改String的字符数组：\n\n```java\n/**\n * 我们都知道String其内部是字符数组，且是私有的，那么我们是否可以通过反射修改其私有属性\n */\n@Test\npublic void test3() throws NoSuchFieldException, IllegalAccessException {\n    String str = \"123\";\n    System.out.println(str + \":\" + VM.current().addressOf(str));\n\n    final Field value = str.getClass().getDeclaredField(\"value\");\n    value.setAccessible(true);\n    value.set(str, \"abc\".toCharArray());\n    System.out.println(str + \":\" + VM.current().addressOf(str));\n\n    String str2 = \"123\";\n    System.out.println(str2 + \":\" + VM.current().addressOf(str2));\n\n    String str3 = \"abc\";\n    System.out.println(str3 + \":\" + VM.current().addressOf(str3));\n}\n```\n\n> 结果有令人很惊讶\n\n- 可以修改String的属性字符数组的值，且不会修改其引用\n- String str2 = \"123\";为何值为”abc“，这里我只能猜测，String的缓存池中记录着这么一个 ”123“字符串，但是其内部的字符数组指向的是['a','b','c']\n\n![image-20220731215113520](java成神之路(基础).assets/image-20220731215113520.png)\n\n\n\n###### String为什么设计成不可变的\n\n> \n\n\n\n- 缓存池\n\n  > String是很常用的，为了避免频繁创建相同的字符串，JVM特地在堆内存中开辟了一块空间叫字符串缓存池，专门用于缓存已创建的字符串。\n\n  如果说需要的字符串在缓存池中存在，那么直接去缓存池中取即可，不用再去创建。\n\n- 安全\n\n  > 字符串用于存储的内容还是很广泛的，密码、url、账号信息等等，如果说String可以很容易的被改变，那么整个系统奖没有可信度可言了。\n\n- 线程安全\n\n  > 线程安全性问题，只出现在可修改的数据上，String不可变那么自动保证线程安全。\n\n- 拷贝安全\n\n  > 我们知道在深拷贝的时候，需要考虑对象属性的拷贝，以不影响原型对象，而String不可变在拷贝的时候无需考虑他的拷贝。\n\n- hash缓存\n\n  > 当字符串作为哈希实现的key值的时候。在对这些散列实现进行操作时，经常调用hashCode()方法。\n  >\n  > 不可变性保证了字符串的值不会改变，其哈希值也不会变，只有在首次哈希的时候会计算哈希值，之后会直接去取已计算的哈希值。\n\n  ```java\n  /** Cache the hash code for the string */\n  private int hash; // Default to 0\n  public int hashCode() {\n      int h = hash;\n      if (h == 0 && value.length > 0) {\n          char val[] = value;\n          for (int i = 0; i < value.length; i++) {\n              h = 31 * h + val[i];\n          }\n          hash = h;\n      }\n      return h;\n  }\n  ```\n\n###### 小结\n\n> 以上提到的String的缓存池技术，hashCode()缓存技术，都旨在与提高性能，因为String是非常常用的数据类型，对于它的性能即便是小小的提升，映射到整个java生态中，也是庞大的提升。\n\n\n\n##### substring\n\n> 介绍subString方法的原理，以及在jdk6和jdk6之后版本中的不同之处，jdk6中的substring方法的问题\n\n\n\n###### JDK6中substring的实现原理\n\n> String底层是一个字符数组，在jdk6中String有三个成员变量：`char value[]` `int offset` `int count`。分别表示字符数组、起始下标、字符个数。\n\n```java\nString(int offset, int count, char value[]) {\n    this.value = value;\n    this.offset = offset;\n    this.count = count;\n}\n\npublic String substring(int beginIndex, int endIndex) {\n    //check boundary\n    return  new String(offset + beginIndex, endIndex - beginIndex, value);\n}\n```\n\n在调用substring方法的时候会返回一个新的string对象，但其内部的字符数组引用任然指向原堆中的字符数组，只不过其实下标和字符数量不同。\n\n图示：\n\n![image-20220731235844909](java成神之路(基础).assets/image-20220731235844909.png)\n\n\n\n###### JDK6中substring存在的问题\n\n> 由于截取的字符串和原字符串引用的是同一个字符数组，如果原字符串很大，但是截取的部分很小，那么就会导致，原来很长的字符串所指向的字符数组即便不会使用也一直会被引用，就会无法回收，导致内存泄漏。 还有就是效率问题，我只需要截取一小段，却引用了整个字符数组。\n>\n> 解决方式是截取后的字符串重新创建一个字符串。\n\n```java\nx = x.substring(x, y) + \"\"\n```\n\n\n\n###### jdk7对于sbustring的优化\n\n> 优化方式是调用sbustring方法生成的字符串其内部字符数组的引用，指向一个新创建的字符数组。\n\n```java\n//JDK 7\npublic String(char value[], int offset, int count) {\n    //check boundary\n    this.value = Arrays.copyOfRange(value, offset, offset + count);\n}\n\npublic String substring(int beginIndex, int endIndex) {\n    //check boundary\n    int subLen = endIndex - beginIndex;\n    return new String(value, beginIndex, subLen);\n}\n```\n\n![image-20220801000754715](java成神之路(基础).assets/image-20220801000754715.png)\n\n\n\n##### replcae\n\n```java\n//将所有的replacement字符替换为target字符\npublic String replace(CharSequence target字符, CharSequence replacement) {\n    return Pattern.compile(target.toString(), Pattern.LITERAL).matcher(\n            this).replaceAll(Matcher.quoteReplacement(replacement.toString()));\n}\n//将所有的replacement字符串替换为target字符串\npublic String replaceAll(String regex, String replacement) {\n    return Pattern.compile(regex).matcher(this).replaceAll(replacement);\n}\n//将首个replacement字符串替换为target字符串\npublic String replaceFirst(String regex, String replacement) {\n    return Pattern.compile(regex).matcher(this).replaceFirst(replacement);\n}\n```\n\n\n\n##### 字符串拼接\n\n\n\n###### 通过+拼接\n\n> 字符串通过`+`拼接的原理\n\n```java\npublic void test1() {\n  String str1 = \"abc\" + \"123\";\n  System.out.println(str1);\n}\n\nvoid method(String str1, String str2) {\n  final String strX = str1 + \",\" + str2;\n}\n```\n\n反编译后：\n\n```java\npublic void test1() {\n  String str1 = \"abc123\";\n  System.out.println(str1);\n}\n\nvoid method(String str1, String str2) {\n  (new StringBuilder()).append(str1).append(\",\").append(str2).toString();\n}\n```\n\n- 对于编译时期就知道字面量的字符串，进行常量折叠\n- 对于编译器不确定的变量，会使用StringBuilder.append拼接\n\n\n\n###### 通过concat拼接\n\n> 会重新生成一个字符串对象，其内部的字符数组也是通过ArrayCopy新拷贝出来的。\n\n```java\npublic String concat(String str) {\n    int otherLen = str.length();\n    if (otherLen == 0) {\n        return this;\n    }\n    int len = value.length;\n    char buf[] = Arrays.copyOf(value, len + otherLen);\n    str.getChars(buf, len);\n    return new String(buf, true);\n}\n```\n\n\n\n###### StringBuffer&StringBuilder\n\n> 可以使用在这两类对字符串进行拼接，最后toString返回即可\n\n###### 第三方工具类\n\n> StringUtils，可以使用Spring提供的也可以是apache提供的，都是一个用法，将一个String数组或集合，以某个字符分割拼接\n\n```java\n@Test\npublic void testAppendByUtil(){\n    String[] value = {\"hello\", \"你好\", \"hello\"};\n    String result = StringUtils.join(value, \",\");\n    System.out.println(result);\n}\n```\n\nhello,你好,hello\n\n\n\n###### String的join方法\n\n\n\n```java\n@Test\npublic void testAppendByStr(){\n    String join = String.join(\",\", \"hello\", \"你好\", \"hello\", \"4\");\n    System.out.println(join);\n}\n```\n\nhello,你好,hello,4\n\n\n\n###### 性能对比\n\n```java\n@Test\npublic void testAppend() {\n    StopWatch stopWatch = new StopWatch();\n    stopWatch.start(\"使用+拼接字符串\");//任务说明\n    String str1 = \"\";\n    for (int i = 0; i < 50000; i++) {\n        //str1 += \"a\";  拼接代码\n    }\n    stopWatch.stop();\n    System.out.println(stopWatch.getLastTaskName() +\"消耗时长：\"+stopWatch.getTotalTimeNanos());\n}\n```\n\n```java\n使用+拼接字符串消耗时长：1942387300\n使用StringBuilder拼接字符串消耗时长：2846001\n使用StringBuffer拼接字符串消耗时长：4217800\n使用concat拼接字符串消耗时长：5055200\n使用StringUtils  join拼接字符串消耗时长：39924299\n```\n\n结果是：StringBuilder > StringBuffer  >  concat> StringUtils > `+`\n\n> StringBuffer  append方法基于StringBuilder实现，同时也是同步的，性能差一点点。\n\n> concat每次循环，都会进行数组拷贝，创建新字符串，性能差点。但也是为了保证字符串的不可变性\n\n> StringUtils底层使用的StringBuilder实现，拼接过程存在很多其他操作，回去判断对象是否为空等，性能也差点\n\n> `+`号是我们很常用的，性能却最差，这是为什么呢？\n\n查看使用`+`拼接字符串的反编译后的代码：\n\n> 发现每次循环都会new一个StringBuilder出来，再进行append，性能自然不会很高了。频繁的创建对象，也是对内存资源的浪费。\n\n```java\nvoid append1() {\n    StopWatch stopWatch = new StopWatch();\n    stopWatch.start(\"使用+拼接字符串\");\n    String str1 = \"\";\n    for (int i = 0; i < 50000; i++) {\n        str1 += \"a\";\n    }\n    stopWatch.stop();\n    System.out.println(stopWatch.getLastTaskName() + \"消耗时长：\" + stopWatch.getTotalTimeNanos());\n}\n```\n\n```java\nvoid append1()\n{\n    StopWatch stopWatch = new StopWatch();\n    stopWatch.start(\"\\u4F7F\\u7528+\\u62FC\\u63A5\\u5B57\\u7B26\\u4E32\");\n    String str1 = \"\";\n    for(int i = 0; i < 50000; i++)\n        str1 = (new StringBuilder()).append(str1).append(\"a\").toString();\n\n    stopWatch.stop();\n    System.out.println((new StringBuilder()).append(stopWatch.getLastTaskName()).append(\"\\u6D88\\u8017\\u65F6\\u957F\\uFF1A\").append(stopWatch.getTotalTimeNanos()).toString());\n}\n```\n\n###### 小结\n\n> 对于循环体内字符串的拼接禁止使用`+`，采用`StringBuilder`的`append`的方式进行字符串拼接。有并发需求时，使用`StringBuffer`代替`StringBuilder`。\n\n\n\n##### StringBuffer & StringBuilder\n\n> String是不可变的，java还为我们提供了两个可变的用于操作字符串的类，StringBuffer  & StringBuilder\n\nStringBuilder和StringBuilder都是AbstractStringBuilder的子类。底层也是字符数组，使用一个成员变量count来表示字符数组已使用的字符数。\n\n```java\nchar[] value;\n\nint count;\n```\n\n> StringBuilder是非线程安全的，StringBuffer是线程安全的（使用Synchronized保证）。\n\n\n\n\n\n##### String.valueOf  & Intege.toString\n\n> 将一个`Integer`转化为`String`有几种方式？\n\n```java\n@Test\npublic void test(){\n    int i = 10;\n    String str1 = i + \"\";\n    String str2 = Integer.valueOf(i).toString();\n    String str3 = String.valueOf(10);\n}\n```\n\n> 第一种方式使用`StringBuilder`\n\n```java\nString str1 = (new StringBuilder()).append(i).append(\"\").toString();\n```\n\n> 第二种和第三种都是使用`Integer.toString()`\n\n\n\n##### switch支持String\n\n> jdk7之后`switch`添加了对`String`的支持。\n>\n> `switch`目前支持的类型有Character, Byte, Short, Integer, String, or an enum，`switch`真正意义上只支持整型，对于`Character`会转化成ASCII码，ASCII是一个`int`类型的数据。`String`会优先通过`hashCode`判断，然后再通过`equals`进行安全检查，`hashCode`也是`int`类型的\n\n###### int&short&byte\n\n代码：\n\n```java\n@Test\npublic void testInt() {\n    int i = 10;\n    switch (i) {\n        case 1:\n            System.out.println(1);\n            break;\n        case 2:\n            System.out.println(2);\n            break;\n        case 3:\n            System.out.println(3);\n            break;\n        default:\n            System.out.println(i);\n    }\n}\n```\n\n反编译查看：\n\n> 没什么特别的，switch对int支持很好。对Short和byte也是一样的，不支持long\n\n```java\npublic void testInt()\n{\n    int i = 10;\n    switch(i)\n    {\n    case 1: // '\\001'\n        System.out.println(1);\n        break;\n\n    case 2: // '\\002'\n        System.out.println(2);\n        break;\n\n    case 3: // '\\003'\n        System.out.println(3);\n        break;\n\n    default:\n        System.out.println(i);\n        break;\n    }\n}\n```\n\n\n\n###### char\n\n代码：\n\n```java\n@Test\npublic void testChar() {\n    char c = 'a';\n    switch (c) {\n        case 'a':\n            System.out.println('a');\n            break;\n        case 'b':\n            System.out.println('b');\n            break;\n        case 'c':\n            System.out.println('c');\n            break;\n        default:\n            System.out.println(c);\n    }\n}\n```\n\n反编译查看：\n\n> 会将char转化成对应的ascii码值，再通过整型switch\n\n```java\npublic void testChar()\n{\n    char c = 'a';\n    switch(c)\n    {\n    case 97: // 'a'\n        System.out.println('a');\n        break;\n    case 98: // 'b'\n        System.out.println('b');\n        break;\n    case 99: // 'c'\n        System.out.println('c');\n        break;\n    default:\n        System.out.println(c);\n        break;\n    }\n}\n```\n\n\n\n###### string\n\n代码：\n\n```java\n@Test\npublic void testString() {\n    String str = \"abc\";\n    switch (str) {\n        case \"abc\":\n            System.out.println(\"a\");\n            break;\n        case \"bac\":\n            System.out.println(\"b\");\n            break;\n        case \"cab\":\n            System.out.println(\"c\");\n            break;\n        default:\n            System.out.println(str);\n    }\n}\n```\n\n反编译查看：\n\n> 发现首先获取哈希值，哈希值是整型，然后进行switch，最后使用equals进行安全判断。\n\n```java\npublic void testString()\n{\n    String str = \"abc\";\n    String s = str;\n    byte byte0 = -1;\n    switch(s.hashCode())\n    {\n    case 96354: \n        if(s.equals(\"abc\"))\n            byte0 = 0;\n        break;\n\n    case 97284: \n        if(s.equals(\"bac\"))\n            byte0 = 1;\n        break;\n\n    case 98244: \n        if(s.equals(\"cab\"))\n            byte0 = 2;\n        break;\n    }\n    switch(byte0)\n    {\n    case 0: // '\\0'\n        System.out.println(\"a\");\n        break;\n\n    case 1: // '\\001'\n        System.out.println(\"b\");\n        break;\n\n    case 2: // '\\002'\n        System.out.println(\"c\");\n        break;\n\n    default:\n        System.out.println(str);\n        break;\n    }\n}\n```\n\n\n\n##### 字符串缓存池\n\n> 创建字符串的方式有以下两种方式:\n\n```java\n@Test\npublic void testStrCache(){\n    String str1 = \"abc\";\n    String str2 = new String(\"abc\");\n}\n```\n\n- 第一种方式通过\"字面量\"的形式赋值，字符串如果在缓存池中不存在，则会创建并放入缓存池\n- 第二种方式会将字符串对象当作一个普通的对象类型，放在堆内存中\n\n> 当我们使用字面量创建字符串的时候，jvm会对此字符串进行检查，如果该字符串在缓存池中不存在，则会创建该字符串，并将其放入字符串缓存池；如果该字符串存在，那么直接将缓存池中的字符串对象的引用返回。\n\n```java\n@Test\npublic void testStrCache2(){\n    String str1 = \"abc\";\n    String str2 = String.valueOf(\"abc\");//String.valueOf也是字面量，调用toString方法直接返回\n    String str3 = \"abc\";\n    System.out.println(str1 == str2);//true\n    System.out.println(str2 == str3);//true\n    System.out.println(str1 == str3);//true\n}\n```\n\n\n\n> 字符串缓存池在内存中的哪个位置\n\njdk7之前，字符串缓存池在永久代中。\n\njdk7中，由于后续版本计划通过元空间代替永久代，所以先将字符串缓存池从永久代移出，暂时放入堆内存。\n\njdk8中，彻底废除了永久代，使用元空间代替永久代，字符串常量池从堆内存，移动到永久代。\n\n##### String长度限制？\n\n> `String`存不存在长度限制呢？\n\n- 在编译期间不可以超过 2^16^-1 = 65535\n\n  也就是我们在使用字面量对字符串赋值的时候如果字符串长度大于等于65535，就通过不了编译\n\n- 运行期间限制：不能超过int的范围\n\n\n\n#### java中的各种关键字\n\n\n\n##### transient\n\n> 短暂瞬时的意思，java提供的关键字，用于修饰成员变量。如果一个变量被`transient`修饰，当对象需要序列化传输、或存储时，会忽略该变量。\n>\n> 当我们不希望对象的某个变量需要被序列化的时候，比如我们定义一个变量，该变量我们只希望它在当前系统中使用，而不希望他在上下游系统传输，可以使用`transient`修饰。\n\n被transient修饰的引用类型也就是对象类型，在被反序列化的时候初始化为null，基本数据类型为默认值int就是0。\n\n> 创建一个对象，注意需要实现序列化接口支持序列化操作。如果存在特殊需求可以重写writeObjec方法和readObject方法。\n\n```java\n@Data\nclass TransientTestClass implements Serializable {\n    private static final long serialVersionUID = 9167810647635375505L;\n  \n    private String str;\n    private Integer value;\n    private transient String name;\n    private transient int age;\n}\n```\n\n> 将对象序列化持久化到本地\n\n```java\nString filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile\";\n\n@Test\npublic void test1() throws IOException {\n    final TransientTestClass transientTestClass = new TransientTestClass();\n    transientTestClass.setName(\"element\");\n    transientTestClass.setStr(\"element\");\n    transientTestClass.setValue(123);\n    //序列化到文件\n    final ObjectOutputStream objectOutputStream = new ObjectOutputStream(\n            new FileOutputStream(new File(filePath, transientTestClass.getClass().getName())));\n    objectOutputStream.writeObject(transientTestClass);\n    objectOutputStream.flush();\n    objectOutputStream.close();\n}\n```\n\n> 再通过反序列化将文件中的对象读出来，查看其属性值\n\n```java\n/**\n * 读出来，使用对象接收看看\n */\n@Test\npublic void test2() throws IOException, ClassNotFoundException {\n    final ObjectInputStream objectInputStream = new ObjectInputStream(\n            new FileInputStream(new File(filePath, TransientTestClass.class.getName())));\n    TransientTestClass transientTestClass = (TransientTestClass) objectInputStream.readObject();\n    System.out.println(transientTestClass);\n}\n```\n\n> 结果也如我们说的一样\n\n![image-20220801235653264](java成神之路(基础).assets/image-20220801235653264.png)\n\n##### instanceof\n\n> java关键字，类似于一个二元操作符，用于判断`instanceOf`左右两边对象类型是否一致。\n\n```java\n@Test\npublic void test() {\n    System.out.println(InstanceofTest.class instanceof Object);\n    System.out.println(\"InstanceofTest.class\" instanceof String);\n    System.out.println(Integer.valueOf(10) instanceof Integer);\n\n    Object o = Integer.valueOf(10);\n    System.out.println(o instanceof String);\n}\n```\n\n![image-20220802000331345](java成神之路(基础).assets/image-20220802000331345.png)\n\n\n\n##### synchronized\n\n[synchronized](https://juejin.cn/post/7077457448290189348)\n\n> 后续重点看\n\n\n\n##### volatile\n\n[volatile](https://juejin.cn/post/7077459563963908109)\n\n> 后续重点看\n\n\n\n##### final\n\n[final](https://juejin.cn/post/7077469542946979847)\n\n> `final`是`java`提供的关键字，表示该部分不可修改，可修饰类、方法、变量。\n\n######  final修饰类\n\n> final 修饰类表示该类不可以被继承。一般是类的自我保护，不希望子类对父类造成破坏。\n\n> 比如说`String`和八大基本数据类型的包装类型\n\n\n\n###### final修饰方法\n\n> 表示该方法不可以被子类重写，但是可以在本类中重载。\n\n\n\n###### final修饰变量\n\n> 被final修饰的变量如果是基本数据类型则其不可变，如果是引用数据类型则其引用地址不可变。\n\n> 作为局部变量\n\n不管是引用类型还是基本数据类型，都不可以使用等号赋值。但是如果引用数据类型存在修改方法的时候是可以修改对象的引用的。\n\n```java\n@Test\npublic void test01() {\n    final StringBuilder sb = new StringBuilder(\"abc\");\n    final int i = 10;\n    sb.append(\"123\");\n    System.out.println(sb.toString());\n}\n```\n\n\n\n> 作为成员变量\n\n```java\nclass MemberField {\n    /**\n     * 被static final修饰，属于类不可变。必须1、在声明的时候赋值 2、或static代码块中赋值\n     */\n    static final StringBuilder sb1 = new StringBuilder();\n    /**\n     * 被final修饰，属于实例，不可变。必须1、在声明的时候赋值 2、非static代码块中赋值 3、构造方法赋值\n     */\n    final StringBuilder sb2 ;\n    {\n        sb2 = new StringBuilder();\n    }\n}\n```\n\n\n\n##### static\n\n> 用于修饰成员变量、方法或代码块，被static修饰的成员变量称为静态成员变量或类变量属于类，被static修饰的代码块称为静态代码块。\n\n###### 静态成员变量\n\n> 也称为类变量，它不属于类的某个实例，它被所有该类的实例共享，因此存在线程安全问题。\n>\n> 如果类变量没有被private修饰，可以使用”类名.变量名“的方式访问。\n\n###### 静态方法\n\n> 和静态变量一样，静态方法也属于类，以`类名 。方法名`调用，在此期间不必创建类的实例，因此会方便许多。\n\n> 比如说集合工具类返回空集合Collections.emptyList();\n\n> java8支持在接口中定义静态方法\n\n```java\ninterface IStaticMethod{\n    static void method1() {\n        Collections.emptyList();\n    }\n    default void method2(){\n    }\n}\n```\n\n\n\n###### 静态代码块\n\n> 静态代码块会在类初始化的时候，将所有静态代码组合成一个`cinit<>`方法，由类加载器执行。一个类在其一个生命周期内只加载一次，所以说对于静态代码块，在类生命周期中只执行一次。\n\n```java\npublic class AboutStatic {  \n    static int a;\n    static {\n        a = 1;\n        System.out.println(\"静态代码块执行\");\n    }\n    {\n        System.out.println(\"非静态代码块执行\");\n    }\n    public static void main(String[] args) {\n        for (int i = 0; i < 100; i++) {\n            new AboutStatic();\n        }\n    }\n}\n```\n\n<img src=\"java成神之路(基础).assets/image-20220802164043054.png\" alt=\"image-20220802164043054\" style=\"zoom:67%;\" />\n\n###### 静态类\n\n> 静态内部类定义于普通类内部，可以和普通类一样使用。\n>\n> 下面列出类：内部类、静态内部类和匿名内部类写法\n\n```java\npublic class AboutStaticClass {\n    static class StaticClass {\n        int a;\n        static int b;\n    }\n    class InnerClass {\n        int a;\n        //不可以定义静态变量\n        //static int b;\n    }\n    void method() {\n        AboutStaticClass.InnerClass innerClass = new AboutStaticClass.InnerClass();\n    }\n    //匿名内部类写法\n     IInterface ia = new IInterface() {\n        @Override\n        public void method() {\n        }\n    };\n}\nclass TestClass {\n    public static void main(String[] args) {\n        AboutStaticClass.StaticClass staticClass = new AboutStaticClass.StaticClass();\n        System.out.println(AboutStaticClass.StaticClass.b);\n    }\n}\n@FunctionalInterface\ninterface IInterface{\n    void method();\n}\n```\n\n##### const\n\n> const和final相似，用于后期扩展。\n\n\n\n#### 枚举\n\n> 枚举类型是java5引入的，由一组固定常量组成的合法类型。\n\n##### 在枚举引入之前如何定义一组常量\n\n> java在枚举引入之前，我们一般会用一组int常量值，来表示一组固定的数据。比如使用1、2、3、4来表示春、夏、秋、冬。\n\n```java\n/**\n * 枚举类型一般会被系统共享，所以其访问修饰符一般为public\n */\nclass Season {\n    public static final int SPRING = 1;\n    public static final int SUMMER = 2;\n    public static final int AUTUMN = 3;\n    public static final int WINTER = 4;\n}\n```\n\n> 可以根据传入的int值来判断对应季节\n\n```java\n@Test\npublic void test1() {\n    final int spring = Season.SPRING;\n    season(spring);\n}\npublic void season(int value) {\n    switch (value) {\n        case 1:\n            System.out.println(\"春天\");\n            break;\n        case 2:\n            System.out.println(\"夏天\");\n            break;\n        case 3:\n            System.out.println(\"秋天\");\n            break;\n        case 4:\n            System.out.println(\"冬天\");\n            break;\n        default:\n            System.out.println(\"输入不合法\");\n            break;\n    }\n}\n```\n\n这种方法称作int枚举模式。存在一些安全问题，就如上面判断季节的方法，default分支是我们不愿意看到的场景，如果说我们不加校验可能会产生问题。并且Season这个类打印出来的也只是一个int值1、2、3、4，表面并不能看出任何的意思。所以说int枚举模式他的安全性和可读性是不可观的。\n\n> 当然了我们也可以使用字符串作为枚举值，但是字符串的比较算法相对来说比较浪费性能，也是不可取的。\n\n\n\n##### 定义枚举\n\n> 由于int枚举和字符串枚举存在着缺陷，java5引入了枚举类型`enum type`，接下来我们看如何定义一个枚举。\n\n使用enum声明一个枚举，在枚举类中列举枚举值，使用逗号隔开，尾部使用分号结尾。\n\n```java\nenum Season2 {\n    SPRING, SUMMER, AUTUMN, WINTER;  \n}\n```\n\n并且我们还可以为枚举定义属性：\n\n```java\n@AllArgsConstructor\nenum Season3 {\n    SPRING(1, \"春天\"),\n    SUMMER(1, \"春天\"),\n    AUTUMN(1, \"春天\"),\n    WINTER(1, \"春天\");\n    int code;\n    String msg;\n}\n```\n\n##### 特点\n\n- 简约\n- 和普通class类一样，枚举类可以单独存在，也可以存在于其他java类中\n- 枚举类可以实现接口\n- 也可以定义新的属性和方法\n\n\n\n##### switch对于枚举的支持\n\n> 使用枚举改造上面代码\n\n```java\npublic void seasonUseEnum(Season2 season) {\n    System.out.println(Season2.SPRING);\n    switch (season) {\n        case SPRING:\n            System.out.println(\"春天\");\n            break;\n        case SUMMER:\n            System.out.println(\"夏天\");\n            break;\n        case AUTUMN:\n            System.out.println(\"秋天\");\n            break;\n        case WINTER:\n            System.out.println(\"冬天\");\n            break;\n        default:\n            System.out.println(\"输入不合法\");\n            break;\n    }\n}\n\n@Test\npublic void test2() {\n    seasonUseEnum(Season2.SPRING);\n}\n```\n\n> 如此判断季节的方法对于传入参数存在类型限制，不会再有不合法参数的出现。一般来说我们会对枚举添加表示域的属性和对应的描述，方便统一管理。\n\n```java\npublic void seasonUseEnum(Season3 season) {\n    System.out.println(Season2.SPRING);\n    final StringBuilder sb = new StringBuilder();\n    switch (season) {\n        case SPRING:\n        case WINTER:\n        case AUTUMN:\n        case SUMMER:\n            sb.append(season.msg);\n            break;\n        default:\n            System.out.println(\"输入不合法\");\n            break;\n    }\n    System.out.println(sb.toString());\n}\n@Test\npublic void test3() {\n    seasonUseEnum(Season3.SPRING);\n}\n```\n\n\n\n###### jad查看原理\n\n> 可以使用jad 反编译一下，查看一下底层原理\n\n可以得出如下结论：\n\n- 枚举类经过编译器编译后会被当作普通类处理，继承自 `java.lang.Enum`\n- 每一个枚举项是一个 `final static`的成员变量。天生是一个单例\n\n\n\n```java\nfinal class Season3 extends Enum\n{\n    private Season3(String s, int i, int code, String msg)\n    {\n        super(s, i);\n        this.code = code;\n        this.msg = msg;\n    }\n    public static final Season3 SPRING;\n    public static final Season3 SUMMER;\n    public static final Season3 AUTUMN;\n    public static final Season3 WINTER;\n    int code;\n    String msg;\n    private static final Season3 $VALUES[];\n    static \n    {\n        SPRING = new Season3(\"SPRING\", 0, 1, \"\\u6625\\u5929\");\n        SUMMER = new Season3(\"SUMMER\", 1, 1, \"\\u6625\\u5929\");\n        AUTUMN = new Season3(\"AUTUMN\", 2, 1, \"\\u6625\\u5929\");\n        WINTER = new Season3(\"WINTER\", 3, 1, \"\\u6625\\u5929\");\n        $VALUES = (new Season3[] {\n            SPRING, SUMMER, AUTUMN, WINTER\n        });\n    }\n}\n```\n\n> 但是要想知道switch对枚举的支持的原理，其实就在构造函数内，会调用super(s,i)。s是String类型为枚举项的字段名称，i为自动生成的编号。\n>\n> 我们使用jad对switch相关代码反编译一下：\n\n- 首先枚举类中的每一个枚举都是一个单例对象，在使用new 关键字创建实例的时候会为各个实例添加一个编号 ordinal\n- 在引用了枚举类的类中，会在static代码块中初始化一个int类型的数组，用于描述各个枚举值对应的编号\n- switch还是对int做操作\n\n```java\n {\n     static final int $SwitchMap$com$roily$booknode$javatogod$_01faceobj$javakeywords$aboutenum$Season3[];\n     static \n     {\n         $SwitchMap$com$roily$booknode$javatogod$_01faceobj$javakeywords$aboutenum$Season3 = new int[Season3.values().length];\n         $SwitchMap$com$roily$booknode$javatogod$_01faceobj$javakeywords$aboutenum$Season3[Season3.SPRING.ordinal()] int= 1;\n         $SwitchMap$com$roily$booknode$javatogod$_01faceobj$javakeywords$aboutenum$Season3[Season3.WINTER.ordinal()] = 2;\n         $SwitchMap$com$roily$booknode$javatogod$_01faceobj$javakeywords$aboutenum$Season3[Season3.AUTUMN.ordinal()] = 3;\n         $SwitchMap$com$roily$booknode$javatogod$_01faceobj$javakeywords$aboutenum$Season3[Season3.SUMMER.ordinal()] = 4;\n     }\n }\npublic void seasonUseEnum(Season3 season)\n{\n    System.out.println(Season2.SPRING);\n    StringBuilder sb = new StringBuilder();\n    switch(_cls1..SwitchMap.com.roily.booknode.javatogod._01faceobj.javakeywords.aboutenum.Season3[season.ordinal()])\n    {\n    case 1: // '\\001'\n    case 2: // '\\002'\n    case 3: // '\\003'\n    case 4: // '\\004'\n        sb.append(season.msg);\n        break;\n    default:\n        System.out.println(\"\\u8F93\\u5165\\u4E0D\\u5408\\u6CD5\");\n        break;\n    }\n}\n```\n\n\n\n### 异常处理\n\n> `ThrowAble`类下有两个重要的子类：`Error`和`Exception`,并且这两个子类下面也存在着大量的子类。\n>\n> `Error`表示系统或硬件级别的错误，由java虚拟机抛出异常，程序员无法处理。\n>\n> `Exception`表示程序级别的错误，是由于程序设计不完善而出现的问题，程序员必须手动处理\n\n#### 异常类型\n\n 主要分两大类：\n\n- 受检异常(checked   exception)\n- 非受检异常(unchecked   exception)\n\n\n\n##### 受检异常\n\n> 受检异常声明：在对应方法上通过`throws`关键字，声明一个异常。然后此方法在被调用的时候，调用方一定要对其做处理(要么捕获、要么向上抛出)，否则是无法通过编译的。\n>\n> 所以当我们希望调用者，必须处理一些特殊情况的时候，就可以声明受检异常。\n\n受检异常在io操作中使用的非常频繁，比如说`FileNotFoundException`异常以及`IOException`及其子类。\n\n比如：\n\n```java\npublic void test1() throws IOException {\n    IOUtils.readLines(new FileInputStream(\"filename\"),  StandardCharsets.UTF_8);\n}\npublic void test2()   {\n    try {\n        IOUtils.readLines(new FileInputStream(\"filename\"),  StandardCharsets.UTF_8);\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n查看 IOUtils.readLines()方法：发现此方法声明了受检异常：\n\n![image-20220808104023792](java成神之路(基础).assets/image-20220808104023792.png)\n\n##### 非受检异常\n\n> 非受检异常，在编码的时候不用强制捕获，但是如果不捕获，在出现异常的时候就会中断程序的运行。\n>\n> 一般来说都是运行时异常，为 `RuntimeException`及其子类。\n>\n> 比如说空指针异常(NPE)、数组下标越界异常(IOE)以及一些我们自定义的运行期间异常。对于非受检异常来说，如果代码编写的合理，这些异常都是可以避免的。\n\n##### 关键字\n\n- throws     方法声明异常\n- throw       后跟异常实例显示抛出异常\n- try            用来包裹一块可能出现异常的代码块\n- catch        跟在try代码后，指定异常类型，并对异常进行处理\n- finally        一些代码无论是否出现异常都会执行，可以定义在fianlly代码块李\n\n\n\n##### 异常处理\n\n> 要么自己try    catch处理\n>\n> 要么向上抛出，交给调用者处理\n\n\n\n##### 自定义异常\n\n> 一般通过继承`RuntimeException`定义一个自定义异常，用于抛出一些错误的业务。\n\n```java\npublic class MyException  extends RuntimeException{\n    \n    private final String DEFAULT_ERROR_CODE = \"5000\";\n    private final String DEFAULT_ERROR_MSG = \"运行时异常\";\n    \n    String code;\n    String msg;\n    //someMethod\n    public MyException(Throwable cause, String code, String msg) {\n        super(cause);\n        this.code = code;\n        this.msg = msg;\n    }\n}\n```\n\n\n\n##### 异常链\n\n> 是指java在运行期捕获了一个异常，处理的时候，抛出了一个新的异常，所抛出的新的异常包含前一个异常的信息，如此形成一个异常链。\n\n如果抛出的异常不包含前一个异常信息的话，我们就不会清楚的知道这个异常具体出现的原因：\n\n```java\npublic void test1() {\n    try {\n        String str = null;\n        byte[] bytes = str.getBytes(StandardCharsets.UTF_8);\n    } catch (NullPointerException npe) {\n        throw new MyException(\"5000\", \"空指针异常\");\n    }\n}\n```\n\n![image-20220808111542845](java成神之路(基础).assets/image-20220808111542845.png)\n\n如果我们包含前一个异常信息，在异常抛出的时候可以，追溯到肯本原因：\n\n```java\npublic void test1() {\n。。。。\n    throw new MyException(npe, \"5000\", \"空指针异常\");\n。。。\n}\n```\n\n![image-20220808111646319](java成神之路(基础).assets/image-20220808111646319.png)\n\n\n\n##### try-with-resources\n\n> java对于资源的操作，比如说io流、数据库连接，这些资源在非常昂贵，必须在使用结束后显示的关闭资源。\n>\n> 即在finally代码块内调用对应资源的close()方法。\n\n```java\npublic void test2() {\n    BufferedReader bi = null;\n    try {\n        bi = new BufferedReader(new FileReader(\"filename\"));\n        String line;\n        while ((line = bi.readLine()) != null){\n            System.out.println(line);\n        }\n    } catch (IOException e) {\n        //dosomething\n    } finally {\n        try {\n            IOUtils.close(bi);\n        } catch (IOException e) {\n            //dosomething\n        }\n    }\n}\n```\n\n> java7 开始提供了一个跟好的处理资源的方式：try-with-resources 语句。这是一个类似于语法糖的语法，方便程序员编码，但是经过编译器编译后，都会转化成jvm认识的。\n\n将资源定义在try括号内，便无需我们手动去关闭异常了：\n\n```java\n@Test\npublic void test4() {\n    try( BufferedReader bi = new BufferedReader(new FileReader(\"filename\"))) {\n        String line;\n        while ((line = bi.readLine()) != null){\n            System.out.println(line);\n        }\n    } catch (IOException e) {\n        //dosomething\n    }\n}\n```\n\n可以使用jad反编译查看一下：\n\n发现编译器帮我们做了：\n\n![image-20220808114543526](java成神之路(基础).assets/image-20220808114543526.png)\n\n\n\n\n\n\n\n##### finally  & return\n\n- ffinally代码块一定会执行么？\n- return的结果是否被finally影响？\n- return和finally代码执行顺序，孰先孰后？\n\n###### finally代码块不一定执行\n\n> finally代码块不一定会执行\n\n- 当我们的代码在进入try代码块之前就已经return了，那么整个方法就结束了，finally代码块就不会执行\n- 当虚拟机强制停止的时候  exit(0),finally代码块就不会执行\n\n例：\n\n以下两种方式finally代码块都不会执行\n\n```java\npublic StringBuilder method1(Boolean flag) {\n    StringBuilder sb = new StringBuilder();\n    if (flag) {\n        sb.append(\"方法在try代码块之前return\\n\");\n        return sb;\n    }\n    try {\n\n    } catch (Exception e) {\n        System.out.println(\"进入try代码块\\n\");\n    } finally {\n        System.out.println(\"finally代码块执行\\n\");\n    }\n    return sb;\n}\npublic StringBuilder method2(Boolean flag) {\n    StringBuilder sb = new StringBuilder();\n    if (flag) {\n        System.exit(0);\n    }\n    try {\n\n    } catch (Exception e) {\n        System.out.println(\"进入try代码块\\n\");\n    } finally {\n        System.out.println(\"finally代码块执行\\n\");\n    }\n    return sb;\n}\n\n@Test\npublic void test1() {\n    method1(true);\n    method2(true);\n}\n```\n\n\n\n###### finally对return结果的影响\n\n> finally代码可能会对return的结果产生影响。\n>\n> 对于基本数据类型和一些不可变的引用类型return的结果不受finally的影响\n>\n> 对于可变的提供修改方法的引用类型，return的结果会受到finally的影响\n\n- 对于基本数据类型  和  一些不可变的比如说String\n\nfinally代码块执行但是不影响return的结果\n\n```java\npublic int method3() {\n    int i = 0;\n    try {\n        return i;\n    } finally {\n        System.out.println(\"finally代码块执行\");\n        i += 1;\n    }\n}\npublic String method4() {\n    String str = \"123\";\n    try {\n        return str;\n    } finally {\n        System.out.println(\"finally代码块执行\");\n        str += \"abc\";\n    }\n}\n@Test\npublic void test2() {\n    int i = method3();\n    System.out.println(\"method3返回结果：\" + i);\n\n    String str = method4();\n    System.out.println(\"method4返回结果：\" + str);\n}\n```\n\n![image-20220808130934740](java成神之路(基础).assets/image-20220808130934740.png)\n\n- 对于可修改的引用类型(比如说StringBuilder)\n\nfinally代码会执行且影响了返回的结果\n\n```java\npublic StringBuilder method5() {\n    StringBuilder sb = new StringBuilder(\"\");\n    try {\n        return sb.append(\"123\");\n    } finally {\n        System.out.println(\"finally代码块执行\");\n        sb.append(\"abc\");\n    }\n}\n\n@Test\npublic void test3() {\n    StringBuilder sb = method5();\n    System.out.println(\"method5返回结果：\" + sb.toString());\n}\n```\n\n![image-20220808131219548](java成神之路(基础).assets/image-20220808131219548.png)\n\n> 所以说我们可以得出一个结论：\n\nreturn会记住需要返回结果的字面量信息，对于基本数据类型来说就是值，对于引用类型来说就是引用地址的值。对于基本数据类型和不可变引用类型需要通过`=`等号赋值，那就直接修改了引用，而return所记住的引用指向的对象并没有被修改。那么对于可变引用类型来说，return所记住的引用指向的对象可以在finally中被修改。\n\n\n\n###### return和finally代码执行顺序\n\n> 其实在上一个例子中已经有结果了，我们可以发现返回的sb为 123abc。\n>\n> 所以说可以得出的结论是：\n>\n> return  的代码执行在finally代码块之前\n>\n> finally代码执行在return代码之后，在完全return之前\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/foot/读书笔记/java成神之路(基础)/java成神之路(基础).md b/foot/读书笔记/java成神之路(基础)/java成神之路(基础).md
--- a/foot/读书笔记/java成神之路(基础)/java成神之路(基础).md	(revision 90f7a170a0193be6feac9f3859d7ac72da50f9d4)
+++ b/foot/读书笔记/java成神之路(基础)/java成神之路(基础).md	(date 1660054748589)
@@ -2772,6 +2772,8 @@
 
 
 
+### 集合相关
+
 
 
 
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"bed07c71-5aa6-478f-ad22-84a18b2955be\" name=\"Changes\" comment=\"0802work\">\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\n    </list>\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\n  </component>\n  <component name=\"ProjectId\" id=\"2Ccb78KeUVafiMzq9wsiAXSh4AU\" />\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\">\n    <property name=\"RunOnceActivity.OpenProjectViewOnStart\" value=\"true\" />\n    <property name=\"RunOnceActivity.ShowReadmeOnStart\" value=\"true\" />\n    <property name=\"WebServerToolWindowFactoryState\" value=\"false\" />\n    <property name=\"last_opened_file_path\" value=\"$PROJECT_DIR$\" />\n    <property name=\"settings.editor.selected.configurable\" value=\"Errors\" />\n  </component>\n  <component name=\"RecentsManager\">\n    <key name=\"MoveFile.RECENT_KEYS\">\n      <recent name=\"D:\\File\\Desktop\\blogXX\\foot\\.idea\" />\n      <recent name=\"D:\\File\\Desktop\\blogXX\\foot\" />\n      <recent name=\"$PROJECT_DIR$/foot/读书笔记/java成神之路(基础)\" />\n    </key>\n  </component>\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"bed07c71-5aa6-478f-ad22-84a18b2955be\" name=\"Changes\" comment=\"\" />\n      <created>1659104649873</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1659104649873</updated>\n      <workItem from=\"1659104651612\" duration=\"169000\" />\n      <workItem from=\"1659435026542\" duration=\"147000\" />\n    </task>\n    <task id=\"LOCAL-00001\" summary=\"0802work\">\n      <created>1659435136175</created>\n      <option name=\"number\" value=\"00001\" />\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1659435136175</updated>\n    </task>\n    <option name=\"localTasksCounter\" value=\"2\" />\n    <servers />\n  </component>\n  <component name=\"TypeScriptGeneratedFilesManager\">\n    <option name=\"version\" value=\"3\" />\n  </component>\n  <component name=\"Vcs.Log.Tabs.Properties\">\n    <option name=\"TAB_STATES\">\n      <map>\n        <entry key=\"MAIN\">\n          <value>\n            <State />\n          </value>\n        </entry>\n      </map>\n    </option>\n    <option name=\"oldMeFiltersMigrated\" value=\"true\" />\n  </component>\n  <component name=\"VcsManagerConfiguration\">\n    <MESSAGE value=\"0802work\" />\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"0802work\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 90f7a170a0193be6feac9f3859d7ac72da50f9d4)
+++ b/.idea/workspace.xml	(date 1660055450393)
@@ -1,8 +1,10 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
   <component name="ChangeListManager">
-    <list default="true" id="bed07c71-5aa6-478f-ad22-84a18b2955be" name="Changes" comment="0802work">
+    <list default="true" id="bed07c71-5aa6-478f-ad22-84a18b2955be" name="Changes" comment="jvm">
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/foot/jvm/class文件二进制组成形式.md" beforeDir="false" afterPath="$PROJECT_DIR$/foot/jvm/class文件二进制组成形式.md" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/foot/读书笔记/java成神之路(基础)/java成神之路(基础).md" beforeDir="false" afterPath="$PROJECT_DIR$/foot/读书笔记/java成神之路(基础)/java成神之路(基础).md" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -11,6 +13,14 @@
   </component>
   <component name="Git.Settings">
     <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
+  </component>
+  <component name="GitSEFilterConfiguration">
+    <file-type-list>
+      <filtered-out-file-type name="LOCAL_BRANCH" />
+      <filtered-out-file-type name="REMOTE_BRANCH" />
+      <filtered-out-file-type name="TAG" />
+      <filtered-out-file-type name="COMMIT_BY_MESSAGE" />
+    </file-type-list>
   </component>
   <component name="ProjectId" id="2Ccb78KeUVafiMzq9wsiAXSh4AU" />
   <component name="ProjectViewState">
@@ -41,6 +51,8 @@
       <updated>1659104649873</updated>
       <workItem from="1659104651612" duration="169000" />
       <workItem from="1659435026542" duration="147000" />
+      <workItem from="1659890507701" duration="105000" />
+      <workItem from="1659969602475" duration="1216000" />
     </task>
     <task id="LOCAL-00001" summary="0802work">
       <created>1659435136175</created>
@@ -49,7 +61,14 @@
       <option name="project" value="LOCAL" />
       <updated>1659435136175</updated>
     </task>
-    <option name="localTasksCounter" value="2" />
+    <task id="LOCAL-00002" summary="jvm">
+      <created>1659890561272</created>
+      <option name="number" value="00002" />
+      <option name="presentableId" value="LOCAL-00002" />
+      <option name="project" value="LOCAL" />
+      <updated>1659890561272</updated>
+    </task>
+    <option name="localTasksCounter" value="3" />
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
@@ -69,6 +88,7 @@
   </component>
   <component name="VcsManagerConfiguration">
     <MESSAGE value="0802work" />
-    <option name="LAST_COMMIT_MESSAGE" value="0802work" />
+    <MESSAGE value="jvm" />
+    <option name="LAST_COMMIT_MESSAGE" value="jvm" />
   </component>
 </project>
\ No newline at end of file
