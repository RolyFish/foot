Index: foot/读书笔记/java成神之路(基础)/java成神之路(基础).md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>## java成神之路读书笔记\n\n> 借鉴地址Gitee Pages 完整阅读:http://hollischuang.gitee.io/tobetopjavaer\n>\n> 作者：Hollis ，阿里巴巴技术专家，51CTO 专栏作家，CSDN 博客专家，掘金优秀作者， 《程序员的三门课》联合作者，《Java 工程师成神之路》系列文章作者;热衷于分享计算 机编程相关技术，博文全网阅读量数千万。\n\n\n\n### 面向对象\n\n> java是一种面向对象的编程语言\n\n#### 面向过程\n\n> 什么是面向过程？\n\n面向过程(Procedure Oriented)是一种以过程为中心的编程思想，是一种自顶而下的编程模式。简单来说，面向过程的开发范式中，程序员需要把问题分解成一个一个步骤，每个步骤用函数实现，依次调用即可。\n\n面向过程的编程语言以诸多流程控制语句来实现一个功能，整体表现为流程化。\n\n**优缺点**\n\n> 优点\n\n流程化，执行效率高\n\n> 缺点\n\n维护困难，复用性差\n\n\n\n#### 面向对象\n\n面向对象（Object Oriented），java是一种面向对象的编程语言。在面向对象的开发过程中，回将某件事情进行抽象，将一件事物的方法属性封装到一个类中，通过多个类之间的组合调用来实现某种功能。\n\n\n\n#### 面向对象三大基本特征\n\n> 封装、继承、多态\n\n##### 封装\n\n> 如果一个类希望其他类访问其内部属性存在不同限制，那么我们可以将其方法和属性设置不同的访问权限，这就是封装。\n\n访问级别有以下几种\n\n- public    所有类都可以访问\n- protected   受保护的，默认访问级别，同级别包下的类可以访问\n- private  私有的，任何其他类都不可以访问，只供其内部访问\n\n> 一般来说如果不是清楚的知道一个类的属性或方法需要被其他类访问，我们会将其设置为私有属性，不对外暴露。\n\n\n\n##### 继承\n\n> 继承是java为我们提供的可以实现代码复用的一种能力。可以拥有现有类的所有属性和功能（包括私有属性和私有方法），并且可以在此基础上进行扩展。\n\n\n\n##### 多态\n\n> \u200B\tjava中的多态指的是同一种操作，作用于不同的实例可以有不同的结果。是一种运行时状态，只有在运行期间才会直到调用的具体方法是什么。\n>\n> \u200B\t具体表现形式为父类或接口的引用指向子类或实现类的实例。调用父类或接口中定义或声明的方法，会根据传入的不同的子类或实现类来表现不同的逻辑。\n\n多态机制使具有不同内部结构的对象可以共享相同的外部接口。\n\n\n\n> 编译期&运行期\n\n编译期指的是，将源代码编译成另一个中间语言，在此期间会做一些代码规范检查，以及编译期间代码优化。\n\n运行期，指的是程序运行在内存中，进行交互。\n\n###### 编译期间多态\n\n> 在编译期间已经明确知道，具体类型，知道调用什么方法。\n\n比如说方法重载、可以通过参数列表的不同确定调用的具体方法。\n\n###### 运行期多态\n\n> 指的是在运行期间才会确认具体类型，才会知道调用的方法，需要`extends``implament`关键字一层一层去找。\n\n比如说使用父类或接口的引用，指向子类或实现类的实例。\n\n```java\npublic class Demo {\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException {\n        Class<?> sonClass = Class.forName(\"com.roily.booknode.javatogod._01faceobj.extendsiscompile.Son\");\n        Person son = (Person) sonClass.newInstance();\n        son.method1();\n        Class<?> daughterClass = Class.forName(\"com.roily.booknode.javatogod._01faceobj.extendsiscompile.Daughter\");\n        Person daughter = (Person) daughterClass.newInstance();\n        daughter.method1();\n    }\n}\n\nclass Person {\n    void method1() {\n        System.out.println(\"method1\");\n    }\n}\n\nclass Son extends Person {\n    @Override\n    void method1() {\n        System.out.println(\"son method01\");\n    }\n}\nclass Daughter extends Person {\n    @Override\n    void method1() {\n        System.out.println(\"Daughter method01\");\n    }\n}\n```\n\n![image-20220729135114407](java成神之路(基础).assets/image-20220729135114407.png)\n\n\n\n#### 重写和重载\n\n> 重写（Overriding）和重载（Overloading）是两个比较重要的概念。\n\n##### 重载\n\n> 指的是在同一个类中，多个方法的方法名称相同而方法签名不同的现象称为重载，这些方法互称为重载方法。\n\n方法签名：方法名+参数列表。（也就是方法名相同，参数列表不同才会构成重载）\n\n返回类型不同不会构成重载。\n\n- 方法名相同，参数列表不同\n- 可以改变返回类型\n- 可以修改访问修饰符\n- 可以声明新的检查异常\n- 重载可以发生在一个类中，或在子类和父类中\n\n\n\n##### 重写\n\n> 严格意义上指的是子类中定义了和父类相同方法签名，且符合重写要求的方法，那么称子类重写了父类的方法。\n>\n> 接口声明抽象方法，其实现类实现抽象方法，对应方法上可以加上@OverWriting注解，也可以称为重写，更多的称为实现。\n\n```java\npublic class OverWriting {\n    public static void main(String[] args) {\n        final Animal dog = new Dog();\n        dog.bark();\n    }\n}\nclass Animal {\n    void bark() {\n        System.out.println(\"动物叫\");\n    }\n}\nclass Dog extends Animal {\n    @Override\n    void bark() {\n        System.out.println(\"狗叫\");\n    }\n}\n```\n\n`输出：狗叫`\n\n> 这里子类实例指向父类引用，是多态的表现行式，编译期间会去检查父类中是否存在对应调用方法。而运行期间具体需要调用哪个方法，需要根据具体指向的实例来决定\n\n\n\n方法重写的条件需要具备以下条件和要求：\n\n> 两同两小一大\n\n- 两同（方法签名相同）\n  - 方法名相同\n  - 参数列表相同\n\n- 两小\n  - 返回类型的范围需要相等或更小（比如父类返回ArrayList子类就不能返回list）\n  - 抛出的检查异常范围要比父类被重写方法要小\n- 一大\n  - 访问级别限制，比被重写方法访问范围要大(即父类是protected的那么子类重写的方法不能申明为private)\n\n> 其他\n\n- 不能重写被final标识的方法\n- 重写的前提是继承\n\n```java\nclass Person {\n    void method1(int a, int b) {\n        System.out.println(\"XX\");\n    }\n    ArrayList<Integer> method2() {\n        return null;\n    }\n}\nclass Student extends Person {\n    /**\n     * 两同\n     * - 方法名和参数列表相同\n     */\n    @Override\n    void method1(int a, int b) {\n        System.out.println(\"XX\");\n    }\n    /**\n     * 两小\n     * - 返回参数要比被重写方法要小（范围）\n     */\n    //@Override\n    //List<Integer> method2() {\n    //    //通过不了编译\n    //    return null;\n    //}\n}\n```\n\n> 子类的返回范围比父类的大，通过不了编译，反过来就行\n\n\n\n#### 继承&实现\n\n> 继承的关键字`extends`，实现关键字`implements`。\n\n\n\n##### 继承\n\n> 通过继承可以拥有父类的所有属性和方法，实现代码的重用。继承可以发生在类与类之间，这个类可以是具体的也可以是抽象的，同时继承也可以发生在接口与接口之间。\n\n> 如果说可以从某个类中抽出来可以供于公共使用的功能，那么就可以抽出一个父类出来，其他类去继承这个父类，以继承的方式来实现对代码的重用。但前提是这个抽出来的这个父类得保持稳定，也就是少量修改，且这个父类得对其他类都得适用。\n\n一般来说不会使用继承来实现重用，特别是继承至具体的类，如果说非得继承可以继承至抽象类。\n\n\n\n##### 实现\n\n> 实现发生在类与接口或抽象类之间，如果说一组业务的处理方式是一样的那么就可以制定抽象（制定标准），具体业务去实现定义的抽象\n\n```java\n/**\n * 可以实现一个接口\n */\ninterface IPerson{\n    /**\n     * 抽象方法\n     */\n    void method();\n}\nclass Teacher implements IPerson{\n\n    @Override\n    public void method() {\n        \n    }\n}\n\n/**\n * 可以是类实现抽象类的抽象方法\n */\nabstract class AbstractPerson{\n    \n    abstract void method();\n    \n}\nclass StudentImpl extends AbstractPerson{\n    \n    @Override\n    void method() {\n        \n    }\n}\n\n/**\n * 可以是抽象类实现接口\n */\nabstract class AbstractPersonX implements IPerson{\n    @Override\n    public void method() {\n\n    }\n}\n```\n\n\n\n\n\n#### java单继承\n\n> `java`通过`extends`关键字实现继承，且不支持多继承。\n\n##### 为什么\n\n> 菱形问题：假设B和C都继承自A，B和C都继承了父类A的所有属性和方法，如果java支持多继承的话，此刻有一个D继承自B和C，那么类D就同时拥有类B和类C的所有属性和方法，并且类D继承了两份来自于A的属性和方法，拥有同名属性和相同方法签名的方法是通过不了编译的，且如果通过编译，在调用的时候也会产生歧义。\n\n<img src=\"java成神之路(基础).assets/image-20220728231808420.png\" alt=\"image-20220728231808420\" style=\"zoom:50%;\" />\n\n##### java可以多实现\n\n> java不支持多继承但是支持多实现\n\n如下例子，我们在InterfaceA和InterfaceB中定义了两个同名的方法，然后使用ClassC实现它们，发现实现类对于相同方法只实现了一次。\n\n```java\n/**\n * 但是java可以多实现，且java8之后接口中可以定义default方法\n */\ninterface InterfaceA {\n    void method1();\n}\ninterface InterfaceB {\n    void method1();\n    \n    void method2();\n}\nclass ClassC implements InterfaceA, InterfaceB {\n    @Override\n    public void method1() {\n        System.out.println(\"method1\");\n    }\n    @Override\n    public void method2() {\n        System.out.println(\"method2\");\n    }\n}\n```\n\n> 对于接口而言它只是一个标准、抽象，实现类按照约定实现标准。方然也可以指定标准，使用某个接口的引用指向实现类的实例。\n\n```java\n@Test\npublic void test1() {\n    InterfaceB classC1 = new ClassC();\n    InterfaceA classC2 = new ClassC();\n}\n```\n\n> 接口中可以定义default方法，且我们可以使用Implement从多个接口中继承得到多个默认方法，特别的如果说两个接口存在相同方法签名的方法，实现类会被要求强制重写同名方法签名的方法来解决菱形问题。\n\n```java\ninterface InterfaceC {\n    default void method1() {\n        System.out.println(\"InterfaceC default1方法\");\n    }\n}\ninterface InterfaceD  {\n    default void method1() {\n        System.out.println(\"InterfaceD default1方法\");\n    }\n}\n/**\n * 可以使用implement从多个接口中得到多个default方法，\n * 如果存在菱形问题，会强制要求实现类重写同名方法\n */\nclass ClassD implements InterfaceC, InterfaceD {\n    @Override\n    public void method1() {\n        InterfaceC.super.method1();\n    }\n}\n```\n\n\n\n\n\n#### 五大基本原则\n\n> \u200B\t面向对象五大基本原则，指导程序员编码，符合五大基本原则的程序，健壮性、可维护性和可扩展性都大大提高。\n\n##### 五大基本原则，都旨在：\n\n- 高内聚、低耦合\n- 面向抽象、接口，而不是面向具体、实现\n\n##### 单一职责\n\n> 适用于方法、接口和类。一个类的职责尽量单一，只有一个引起它的变化。\n\n对于方法而言，我们一般都遵守其单一职责原则\n\n对于接口而言，抽象方法尽量要求要少，如果方法太多可以进行接口拆分\n\n对于类而言，一般来说都不会严格遵守单一职责，比如说有一个类UserService，进行堆用户的增删改查，那么这个类想要严格遵守大一职责，完全可以拆分为四个类。\n\n所以说，单一职责尽量遵守，类、接口、方法不要过于臃肿。在业务要求基础之上，合理遵守。\n\n\n\n##### 开闭原则\n\n> 对扩展开放、对修改关闭。\n\n1、对扩展开放，意味着有新的需求时，可以在现有代码上进行扩展，以适应新的变化。\n\n2、对修改关闭，当软件或系统一旦设计完成，可以独立完成工作，而不要其进行任何修改的尝试\n\n> 开闭原则的重点在于，面向接口、抽象编程而不是面向实现、具体编程。\n>\n> 因为抽象也就是接口相对稳定，接口定义了一套标准，如果说接口添加新的抽象方法，那么就必须修改其实现类，所以说对于修改是关闭的。\n>\n> 而如果说现在有了一个新的需求，可以通过实现现有接口定义一个新的类，配合多态可以对当前系统功能进行扩展，所以说对扩展开放。\n\n> 而不能面向具体，一般来说会以继承或组合的方式实现具体类的复用。具体并没有一套标准，也就是说父类修改对应逻辑，并不会要求子类修改，也就是对修改开放，违背开闭原则。\n\n##### 里氏替换原则\n\n> 里氏替换原则知道我们如何使用继承，是一种编程思想。\n>\n> 要求软件实体：子类必须能够替换其基类，并且不改变业务逻辑。\n\n\n\n###### 里氏替换原则和继承的关系\n\n- 继承\n\n  > 继承是java提供的一种可以实现代码复用的语法，但是继承是侵入式的，如果在继承的过程中子类重写了父类的方法，那么说明父类的方法并不通用。\n\n- 里氏替换原则\n\n  > 里氏替换原则是一种编程思想，用于在指导我们合理使用继承。只有遵守了里氏替换原则，才可以实现继承复用。\n\n\n\n##### 依赖倒置原则\n\n> 面向接口编程，依赖于抽象。\n>\n> 具体定义：高层模块不依赖于底层模块，二者都依赖于抽象；抽象不依赖于具体，具体依赖于抽象。\n\n\n\n##### 接口隔离原则\n\n> 将臃肿的大接口拆分为一个个小接口，可以使用接口继承或实现多个接口的方式来实现多个接口定义的抽象方法。\n>\n> 如果一个接口过于庞大，或存在一些不必要实现的方法时，这是一种接口污染。\n\n\n\n#### 继承和组合\n\n> 继承和组合都是java用于实现代码复用的技术之二。优先考虑组合，尽量避免使用继承。\n\n继承\n\n> 继承(Inheritance)是一种联结类与类的层次模型。指的是一个类(子类、子接口)继承另外一个类(父类、父接口)的功能。并且可以增加自己新的功能的能力。继承是一种`AS-a`的关系。\n\n![image-20220729130759731](java成神之路(基础).assets/image-20220729130759731.png)\n\n组合\n\n> 组合(Composition)体现的是整体与部分、拥有的关系，即`has-a`关系。\n\n![image-20220729131252923](java成神之路(基础).assets/image-20220729131252923.png)\n\n\n\n##### 组合&继承关系\n\n继承是一种侵入式的代码结构，在继承关系中，父类的内部细节对于子类是可见的（继承是一种白盒式代码复用），如果父类的代码逻辑发生改变，那么如果子类调用了父类的类方法，子类的逻辑也会随之修改，甚至出错。（继承是一种编译期概念，在编译器就确认了类与类的关系）\n\n组合是将现有对象进行拼装组合来实现较复杂的业务逻辑，将对象作为内部的一个属性，组合进来的对象其内部实现细节是不可见的（黑盒式代码复用）。（如果说组合进来的是一个接口或抽象类型，那么在编译期无法确认其具体类型，只有在运行期间才会确认，所以一定程度上复用性更高）\n\n\n\n###### 对比\n\n|                             组合                             |                         继承                         |\n| :----------------------------------------------------------: | :--------------------------------------------------: |\n|            不会破坏封装，整体类与局部类之间松耦合            | 破坏封装，子类依赖于父类，表现为父类与父类之间前耦合 |\n|         组合进来的可以是一个抽象，因此具有一定扩展性         |                   可通过定义新方法                   |\n| 整体类对组合进来的类进行包装，并可以做一些拓展，就是装饰器模式和代理模式 |                                                      |\n|             创建整体对象的时候，必须创建局部对象             |           创建子类对象，会自动创建父类对象           |\n|                                                              |                                                      |\n\n\n\n##### 如何选择\n\n> 多用组合、少用继承。\n\n- 在同等情况下优先选择组合，利于扩展\n- 继承也有用处，如果当前类必须要向基类进行向上转型，则可以考虑使用继承\n\n\n\n#### 构造函数和默认构造函数\n\n> 构造函数配合`new`关键字，用于创建实例对象和给成员变量赋值。\n\n> 构造函数长什么样子？\n\n构造函数和普通方法很相似，①构造函数名为类名②构造函数不声明返回类型，返回当前类对象\n\n> 构造函数的重载\n\n构造函数根据参数列表的不同可以实现重载。并且可以为特殊属性给与默认值。\n\n```java\nclass Person{\n    int age;\n    String name;\n    String address;\n    Boolean sex;\n    \n    private Person(int age, String name, String address, Boolean sex){\n        this.age = age;\n        this.name = name;\n        this.address = address;\n        this.sex = sex;\n    }\n    public Person(int age, String name, String address){\n        return Person(age,name,address,false);\n    }\n}\n```\n\n\n\n> 如果当前类没有构造函数，编译器会自动生成一个无参构造函数。其成员变量会被赋予默认值。\n\n##### 如果没有构造函数\n\n> 会生成默认构造函数\n\n```java\npublic class ConstructorTest {\n    int i;\n    String str;\n}\n```\n\n反编译后：\n\n```java\npublic class ConstructorTest{\n    public ConstructorTest(){\n    }\n    int i;\n    String str;\n}\n```\n\n##### 如果存在构造函数\n\n> 会使用定义的构造函数，此刻空参构造函数不可用。\n\n```java\nclass ConstructorTest2 {\n    int i;\n    String str;\n    public ConstructorTest2(int i) {\n        this.i = i;\n    }\n}\n```\n\n反编译后：\n\n```java\nclass ConstructorTest2{\n    public ConstructorTest2(int i){\n        this.i = i;\n    }\n    int i;\n    String str;\n}\n```\n\n\n\n#### 类变量、成员变量和局部变量\n\n> `java`中如果从，生命周期，作用域和内存角度去看，`java`的变量分为，类变量、成员变量和局部变量。\n\n##### 类变量\n\n> 类变量被`static`修饰，属于类，生命周期等同于类的生命周期，当一个类被类加载器成功加载到方法区，其就已经存在与方法区。当类被卸载的时候也跟着消失。\n\n##### 成员变量\n\n> 成员变量属于实例，生命周期等同于实例，当一个实例被new出来(或反射等其他方式)，会为其赋值，跟随实例存在于堆内存中。当实例对象被回收时，他也跟着消失。\n\n##### 局部变量\n\n> 局部变量存在于栈内存，一般存在于方法参数，循环体或方法中。\n\n```java\npublic class Demo2 {\n    //类变量\n    final static String str1 = \"abc\";\n    static String str2 = \"abc\";\n \n    //成员变量\n    String str3 = \"abc\";\n\n    //局部变量\n    void method01(String str1) {\n        String str2 = \"abc\";\n        for (StringBuilder str = new StringBuilder(\"abc\"); str.toString().equals(\"abc\"); ) {\n        }\n    }\n}\n```\n\n\n\n#### 访问修饰符\n\n- public  \n\n> 公开的，被public修饰的成员变量和方法对所有类都是可见的，所有类和对象都可以直接访问\n\n- private\n\n> 私有的，被private修饰的成员变量和方法是私有的，只有当前类有访问权限。即便是子类也不可以访问\n\n- protected\n\n> 受保护的，被protected修饰的成员变量和方法是受保护的的，只有当前类和与其处于同一包下的类有访问权限。除非是子类\n\n- default\n\n> 默认的，被default修饰的成员变量和方法是受保护的的，只有当前类和与其处于同一包下的类有访问权限。即便是子类\n\n```java\npackage com.roily.booknode.javatogod._01faceobj.extendsiscompile;\n\npublic class Demo3 {\n    public String str1;\n    String str2;\n    private String str3;\n    protected String str4;\n}\n```\n\n子类不在同一个包下：\n\n```java\npackage com.roily.booknode.javatogod._01faceobj;\n\nimport com.roily.booknode.javatogod._01faceobj.extendsiscompile.Demo3;\npublic class TestDemo extends Demo3{\n    void method1(){\n        System.out.println(str1);\n        System.out.println(str4);\n    }\n}\n```\n\n> 可见如果不指定属性和方法的访问级别的话，默认为default。\n\n\n\n#### java的值传递\n\n> `java`关于关于参数的传递只有值传递，在传递参数的时候会将参数进行拷贝，在方法体中操作的都是拷贝的参数。\n\n##### 形参、实参\n\n> 形参：在定义方法的时候使用的参数，[参数类型+形参名称]，目的是为了接收参数\n>\n> 实参：在抵用方法的时候，被调方法会被传入一个参数 [参数名]，这个参数就叫实参\n\n```java\n/**\n * @param str 形参\n */\nvoid method(String str) {\n}\nvoid method2() {\n    /**\n     * 123  实参\n     * str  实参\n     */\n    method(\"123\");\n    String str = \"123\";\n    method(str);\n}\n```\n\n\n\n##### 为什么说java只有值传递\n\n> 对于基本数据类型来说，它只有值的概念，所以对于基本数据类型的值传递没有任何异议。\n>\n> 对于引用数据类型来说，在对引用类型的参数进行传递的时候，会将参数进行拷贝，在方法体内实际操作的是拷贝的副本，如果我们没有改变引用关系而直接操作属性，是会对原对象有影响的，应为两个引用指向的是同一个对象。\n\n例：\n\n```java\n/**\n * 基本数据类型，只有值的概念\n *\n * @param i\n */\nvoid simpType(int i) {\n    i = 999;\n}\n\nvoid referenceType1(StringBuilder sb) {\n    sb.append(\"追加\");\n}\n\nvoid referenceType2(StringBuilder sb) {\n    sb = new StringBuilder();\n    sb.append(\"追加\");\n}\n\n@Test\npublic void test1() {\n    System.out.println(\"基本数据类型\");\n    int i = 1;\n    System.out.println(\"原值：\" + i);\n    simpType(i);\n    System.out.println(\"修改后：\" + i);\n\n    System.out.println(\"引用数据类型，未修改引用\");\n    final StringBuilder sb1 = new StringBuilder(\"123\");\n    System.out.println(\"原值：\" + sb1.toString());\n    referenceType1(sb1);\n    System.out.println(\"修改后：\" + sb1.toString());\n\n    System.out.println(\"引用数据类型，修改引用\");\n    final StringBuilder sb2= new StringBuilder(\"123\");\n    System.out.println(\"原值：\" + sb2.toString());\n    referenceType2(sb2);\n    System.out.println(\"修改后：\" + sb2.toString());\n}\n```\n\n![image-20220730124812628](java成神之路(基础).assets/image-20220730124812628.png)\n\n- 对于基本数据类型来说，值传递没有异议\n\n原始参数通过值传递给方法。这意味着对参数值的任何更改都只存在于方法的范围内。当方法返回时，参数将消失，对它们的任何更改都将丢失\n\n- 对于引用数据类型来说\n\n也就是说，引用数据类型参数(如对象)也按值传递给方法。这意味着，当方法返回时，传入的引用仍然引用与以前相同的对象。但是，如果对象字段具有适当的访问级别，则可以在方法中更改这些字段的值\n\n> 引用类型传递的时候发生了什么？\n\nvoid referenceType1(StringBuilder sb)方法\n\n<img src=\"java成神之路(基础).assets/image-20220730125529126.png\" alt=\"image-20220730125529126\" style=\"zoom:67%;\" />\n\nvoid referenceType2(StringBuilder sb)方法\n\n<img src=\"java成神之路(基础).assets/image-20220730125718516.png\" alt=\"image-20220730125718516\" style=\"zoom: 67%;\" />\n\n\n\n<hr>\n\n\n### java基础\n\n#### 8大基本数据类型\n\n> Java中有8种基本数据类型分为三大类。\n\n- 字符型\n\nchar\n\n- 布尔型\n\nboolean\n\n- 数值型\n\n1.整型：byte、short、int、long\n\n2.浮点型：float、double\n\n\n\n##### 取值范围\n\n> 在`java`中整数类型属于有符号类型，第一位用来表示符号0代表整数1代表负数。\n\n比如说byte类型，占1字节8位，那么他的表示范围为：\n\n最大值：0111 1111  (2^7^-1)\n\n最小值：1000 0000  (-2^7^)\n\n> 这里会有一个疑问？ 1000 0000 为什么 表示-2^7^呢？不是 -0么？\n\n第一点：在计算机中，数据的运算是以补码进行的[源码反码补码](https://juejin.cn/post/7092566574816559111)\n\n第二点：为了防止 +0 和-0的出现，约定了 补码 1000 0000代表 -128 且移除 -0概念\n\n以一个找规律的方式解释：\n\n| 原码      | 反码      | 补码         | 值（10进制） |\n| --------- | --------- | ------------ | ------------ |\n| 0111 1111 | 0111 1111 | 0111 1111    | 127          |\n| 0000 0000 | 0000 0000 | 0000 0000    | 0            |\n| ......    | ......    | ......       | ......       |\n| 1000 0001 | 1111 1110 | 1111 1111    | -1           |\n| 1000 0010 | 1111 1101 | 1111 1110    | -2           |\n| 1000 0011 | 1111 1100 | 1111 1101    | -3           |\n|           |           | 补码不断减一 |              |\n| 1111 1111 | 1000 0000 | 1000 0001    | -127         |\n| 无法表示  | 无法表示  | 1000 0000    | -128         |\n\n###### 整型\n\n> 取值范围\n\n| 数据类型 | 字节数、位数 | 范围                  |\n| -------- | ------------ | --------------------- |\n| byte     | 1字节、8位   | 【-128，127】         |\n| short    | 2字节、16位  | 【-2^15^, 2^15^-1】   |\n| Int      | 4字节、32位  | 【-2^31^  , 2^31^-1】 |\n| long     | 8字节、64位  | 【-2^63^,  2^63^-1】  |\n|          |              |                       |\n\n> 溢出问题\n\n由于整型的存储空间是有限的，那么就会存在溢出问题\n\n这是因为int只占32位\n\n0111 1111\n\n0111 1111   +\n\n-------------------------\n\n1111 1110（补）=》 1111 1101(反) =》1000 0010(原)   =  -2\n\n```java\n/**\n * 溢出问题\n */\n@Test\npublic void test2() {\n    final int value = Integer.MAX_VALUE + Integer.MAX_VALUE;\n    System.out.println(value);\n}\n```\n\n![image-20220730161454604](java成神之路(基础).assets/image-20220730161454604.png)\n\n###### 浮点数\n\n[定点数&浮点数](https://juejin.cn/post/7126230681465651230/)\n\njava为我们提供了float和double两个浮点数数据类型，分别占4字节32位和8字节64位。\n\n相较于float(单精度),double(双精度)其表示的范围更大，且精度更高。\n\n> 存储结构\n\nfloat:        1位符号位，8位指数位，23位尾数位\n\ndouble： 1位符号位，11位指数位，52位尾数位\n\n> 浮点数存在精度问题，对于金额有严格精度要求的业务，不可使用浮点数来表示金额。\n\n\n\n##### 自动装箱与拆箱\n\n> 八大基本数据类型自动装箱与自动拆箱。八大基本数据类型都有对应的对象类型，自动装箱拆箱的意思就是在需要基本数据类型需要转化为对应的包装类型的时候不需要程序员主动的去操作，而是编译器会自动帮我们去做。\n\n除了`int`对应的包装类型为`Integer`，``char`对应包装类型为`Character`外其他基本数据类型对应的包装类型都为对应基本数据类型首字母大写。\n\n> `Java`是一种面向对象的编程语言，一切皆对象，为何需要基本数据类型？\n\n基本数据类型，相较于对象类型运算简单。\n\n> 包装类型存在的意义？\n\n基本数据类型的包装类型，不仅仅只有值的概念，其扩展了额外的方法(比如equals)。且对于集合框架来说，需要的是对象类型，我们无法将基本数据类型放进去。\n\n\n\n###### 装箱&拆箱\n\n> 装箱\n\n```java\nint i = 10;\nInteger i2 = new Integer(i);\n或\nInteger i2 = Integer.valueOf(i);\n```\n\n> 拆箱\n\n```java\nInteger i = new Integer(10);\nint i2 = i.intValue();\n```\n\n\n\n###### 自动装箱拆箱\n\n> 基本数据类型在需要转化为对应包装类型的时候，无需程序员手动操作\n\n```java\nInteger i = 10;\nint i2 = i;\n```\n\n对其进行反编译可以发现确实自动帮我们转化了：\n\n![image-20220731161053533](java成神之路(基础).assets/image-20220731161053533.png)\n\n> 还有就是集合的泛型是一个对象类型，但是我们在编码的时候可以直接将基本数据类型放入，因为编译器会帮我们自动装箱。\n\n```java\nList<Integer> ints = new ArrayList<>();\nints.add(10);\n```\n\n反编译看：\n\n![image-20220731161803912](java成神之路(基础).assets/image-20220731161803912.png)\n\n###### 问题\n\n> 自动装箱与拆箱虽然给我们编码带来了方便，但也会有一些问题。\n\n- 对于基本数据类型来说，我们只关心其数值，在自动装箱过后，超过缓存范围的包装类型，必须使用equals判等。不可使用 `==`\n- 将包装类型拆箱的过程中，可能胡出现空指针异常(NPE)\n\n```java\nInteger methodRe(){\n    return null;\n}\n@Test\npublic void testRe(){\n    int i = methodRe();\n}\n```\n\n\n\n##### 基本数据类型的池化技术\n\n> 基本数据类型（除了double、float）都有缓存技术，会缓存一定范围内的对象，原因就是`jvm`认为在此范围内的对象很常用，在需要使用的时候直接去池中拿取，而无需重新创建。\n\n\n\n###### 缓存范围\n\n除了`Character`没有负数概念，其缓存范围为：【0,127】,Boolean缓存范围 {true,false}\n\n其他都是：【-128,127】\n\n> 需要注意的是Integer的缓存范围是可配置的，其他的是固定的。\n\n```java\n@Test\npublic void testCache() {\n\n    System.out.println(\"========char==========\");\n    Character c1 = 127;\n    Character c2 = 127;\n    Character c3 = 128;\n    Character c4 = 128;\n    System.out.println(c1 == c2);\n    System.out.println(c3 == c4);\n\n    System.out.println(\"========byte==========\");\n    Byte b1 = 127;\n    Byte b2 = 127;\n    Byte b3 = -128;\n    Byte b4 = -128;\n    System.out.println(b1 == b2);\n    System.out.println(b3 == b4);\n\n    System.out.println(\"========short==========\");\n    Short s1 = 127;\n    Short s2 = 127;\n    Short s3 = -129;\n    Short s4 = -129;\n    System.out.println(s1 == s2);\n    System.out.println(s3 == s4);\n\n    System.out.println(\"========int==========\");\n    Integer i1 = 127;\n    Integer i2 = 127;\n    Integer i3 = -129;\n    Integer i4 = -129;\n    System.out.println(i1 == i2);\n    System.out.println(i3 == i4);\n\n    System.out.println(\"========long==========\");\n    Long l1 = 127L;\n    Long l2 = 127L;\n    Long l3 = -129L;\n    Long l4 = -129L;\n    System.out.println(l1 == l2);\n    System.out.println(l3 == l4);\n  \n    System.out.println(\"========Boolean==========\");\n    Boolean bb1 = false;\n    Boolean bb2 = false;\n    System.out.println(bb1 == bb2);\n}\n```\n\n![image-20220731163829088](java成神之路(基础).assets/image-20220731163829088.png)\n\n\n\n###### new关键字\n\n> 特别的，如果使用`new`关键字创建包装类型，其不会存放于缓存池中，而是存放于堆内存中\n\n```java\n@Test\npublic void testCache2() {\n    Integer i1 = new Integer(128);\n    Integer i2 = 128;\n    System.out.println(i1 == i2);\n    System.out.println(\"equals方法：\" + i1.equals(i2));\n}\n```\n\n![image-20220731163644314](java成神之路(基础).assets/image-20220731163644314.png)\n\n\n\n###### 问题\n\n> 池化技术可有效的节省内存空间，但是也会给我们带来一些问题。对于基本数据类型我们一般来说只关心其数值的大小，并不会去关心其对象具体。所以说对于基本数据类型的判等一般采用equals方法，这样即便数据超过缓存范围也可以准确判断。\n\n\n\n###### 谁负责缓存\n\n> java中会有专门的类负责缓存\n\n有ByteCache用于缓存Byte对象\n\n有ShortCache用于缓存Short对象\n\n有LongCache用于缓存Long对象\n\n有CharacterCache用于缓存Character对象\n\n有IntegerCache用于缓存Integer对象\n\n\n\n##### 对于boolean属性如何命名及返回值如何定义\n\n> `Boolean`作为实体类的属性的时候如何命名？`success`or `isSuccess`?，`Boolean`作为方法返回参数的时候使用基本类型还是包装类型？\n\n\n\n###### boolean作为属性\n\n> 我们测试`Boolean`作为属性？其生成的`getter`和`setter`方法是什么样子的，对RPC框架有什么影响。\n\n存在四种情况：\n\n```java\nBoolean success;\nBoolean isSuccess;\nboolean success;\nboolean isSuccess;\n```\n\n分别举例：\n\n> 使用Lombok自动生成getter和setter方法，编译查看对应代码\n\n```java\n@Data\nclass BooleanType1{\n    boolean success;\n}\n@Data\nclass BooleanType2{\n    boolean isSuccess;\n}\n@Data\nclass BooleanType3{\n    Boolean success;\n}\n@Data\nclass BooleanType4{\n    Boolean isSuccess;\n}\n```\n\n> 编译后查看：\n\n```java\nclass BooleanType1 {\n    boolean success;\n    public boolean isSuccess() {\n        return this.success;\n    }\n    public void setSuccess(boolean success) {\n        this.success = success;\n    }\n}\nclass BooleanType2 {\n    boolean isSuccess;\n    public boolean isSuccess() {\n        return this.isSuccess;\n    }\n    public void setSuccess(boolean isSuccess) {\n        this.isSuccess = isSuccess;\n    }\n}\nclass BooleanType3 {\n    Boolean success;\n    public Boolean getSuccess() {\n        return this.success;\n    }\n    public void setSuccess(Boolean success) {\n        this.success = success;\n    }\n}\nclass BooleanType4 {\n    Boolean isSuccess;\n    public Boolean getIsSuccess() {\n        return this.isSuccess;\n    }\n    public void setIsSuccess(Boolean isSuccess) {\n        this.isSuccess = isSuccess;\n    }\n}\n```\n\n这里可以发现如果属性是基本数据类型的`boolean`生成的getter和setter方法是:isXXXX()和setXXX();\n\n如果是包装类型生成的getter和setter方法是getXXX()和setXXX()\n\n这里可以发现，如果是基本数据类型`boolean`作为属性的话，属性名success和isSuccess其对应的getter和setter方法是相同的。那么如果我们的属性名是isSuccess的话，在部分RPC框架中，得到的getter方法是isSuccess()，会误认为对应的属性名称是success，会导致获取不到属性，从而报出异常。\n\n> 所以说对于实体类如果存在Boolean数据类型的属性，使用包装类型。\n\n###### boolean对序列化的影响\n\n> 使用FastJson  JACKSON、GSON这几个常见JSON序列话对比区别。\n\n> 同样的对于基本数据类型的boolean，对不同的序列话工具会有不同的结果。而对于包装类型则没有影响。\n\nfastjson和jackson是通过反射得到所有的getter方法（getXXX或isXXXX），然后认为 XXXX就是字段名称，并得到对应的值，直接序列化成对应JSON字符串。\n\nGson则是通过反射，遍历对象对应类的属性，再序列话成json字符串。\n\n```java\n@Test\npublic void test() throws JsonProcessingException {\n\n    Gson gson = new Gson();\n    ObjectMapper om = new ObjectMapper();\n\n    BooleanType1 booleanType1 = new BooleanType1(true);\n    System.out.println(\"booleanType1\");\n    System.out.println(\"FastJson:boolean success: => \" + JSON.toJSON(booleanType1));\n    System.out.println(\"Gson:boolean success: => \" + gson.toJson(booleanType1));\n    System.out.println(\"JackSon:boolean success: => \" + om.writeValueAsString(booleanType1));\n\n    BooleanType2 booleanType2 = new BooleanType2(true);\n    System.out.println(\"booleanType2\");\n    System.out.println(\"FastJson:boolean isSuccess: => \" + JSON.toJSON(booleanType2));\n    System.out.println(\"Gson:boolean isSuccess: => \" + gson.toJson(booleanType2));\n    System.out.println(\"JackSon:boolean isSuccess: => \" + om.writeValueAsString(booleanType2));\n\n    BooleanType3 booleanType3 = new BooleanType3(true);\n    System.out.println(\"booleanType3\");\n    System.out.println(\"FastJson:Boolean success: => \" + JSON.toJSON(booleanType3));\n    System.out.println(\"Gson:Boolean success: => \" + gson.toJson(booleanType3));\n    System.out.println(\"JackSon:Boolean success: => \" + om.writeValueAsString(booleanType3));\n\n    BooleanType4 booleanType4 = new BooleanType4(true);\n    System.out.println(\"booleanType4\");\n    System.out.println(\"FastJson:Boolean isSuccess: => \" + JSON.toJSON(booleanType4));\n    System.out.println(\"Gson:Boolean isSuccess: => \" + gson.toJson(booleanType4));\n    System.out.println(\"JackSon:Boolean isSuccess: => \" + om.writeValueAsString(booleanType4));\n}\n```\n\n![image-20220801145946307](java成神之路(基础).assets/image-20220801145946307.png)\n\n> 对于boolean isSuccess 不同的JSON序列化工具，生成的JSON字符串并不是一样的。那么如果对于同一对象使用不同序列化工具序列化和反序列化会产生什么结果？\n\n```java\n@Test\npublic void testSer() throws IOException {\n\n    BooleanType2 booleanType2 = new BooleanType2(true);\n    //使用fastjson序列话\n    String jsonStr = JSON.toJSONString(booleanType2);\n    System.out.println(\"json字符串：=》\" + jsonStr);\n    //分别使用 fastJson 、 GSON  、 JackSon反序列化\n    BooleanType2 t1 = JSON.toJavaObject(JSON.parseObject(jsonStr), BooleanType2.class);\n    System.out.println(\"FastJson反序列化后=》\" + t1);\n\n    ObjectMapper om = new ObjectMapper();\n    BooleanType2 t2 = om.readValue(jsonStr, BooleanType2.class);\n    System.out.println(\"Jackson反序列化后=》\" + t2);\n\n    Gson gson = new Gson();\n    BooleanType2 t3 = gson.fromJson(jsonStr, BooleanType2.class);\n    System.out.println(\"Gson反序列化后=》\" + t3);\n}\n```\n\n![image-20220801152221308](java成神之路(基础).assets/image-20220801152221308.png)\n\n> 还是Gson出现的问题，对于同一个类，使用不同的序列化工具进行，序列话和反序列化，对象会产生前后不一致问题。\n\n同样的对于fastjson和jackson来说，会根据success通过反射来找对应得setter方法，将属性set进去。而Gson会通过反射去找success属性，发现没找打，那么就只能赋予默认值false。\n\n> 又一次证明了只能使用success而不可以使用isSuccess\n\n###### Boolean  or   boolean\n\n> 编码得时候使用Boolean  还是 boolean\n\n- 对于实体类的属性，一律使用包装类型\n- 对于远程调用的接口来说，必须使用包装类型。避免默认值的出现\n- 对于局部变量来说使用基本数据类型\n\n###### 小结\n\n> 对于布尔值如何命名和使用success还是isSuccess。\n\n第一：布尔值命名必须去掉 is\n\n第二：除了局部变量，其他地方一律使用包装类型\n\n#### String\n\n> `String`在`java`中很常用，看似简单，也有很多知识点。\n\n##### 不可变性\n\n对象的不可变性指的是什么？\n\n对象的不可变性指的是在对象创建完成，我们不可以调用方法来修改其属性。\n\n\n\n######  现象\n\n> 在编程中我们常常通过等号和加号来\"修改\"字符串的值，为什么还是不可变得呢？\n\n比如：\n\n```java\nString str1 = \"abc\";\nstr1 = \"123\";\n//\nString str1 = \"abc\";\nstr1 += \"123\"; \n```\n\n这不是修改了么？\n\n> 这里两种方式好像都修改了str1的值，其实是修改了str1的引用，将str1指向了一个新的字符串对象。\n>\n> 对于字符串相加，回收先得到相加后的结果，创建对应字符串，然后赋予引用。\n\n图示：\n\n<img src=\"java成神之路(基础).assets/image-20220731210311597.png\" alt=\"image-20220731210311597\" style=\"zoom:67%;\" />\n\n<img src=\"java成神之路(基础).assets/image-20220731210337273.png\" alt=\"image-20220731210337273\" style=\"zoom:67%;\" />\n\n\n\n###### String为什么是不可变的\n\n> 简单理解一下为什么String不可变\n\n打开`String`类的源码，可以发现`String`底层是一个字符数组，且该属性被`final`修饰：\n\n```java\nprivate final char value[];\n```\n\n那么此刻自然就想到被`final`修饰的对象不可变。\n\n> 其实被`final`修饰的对象不可变指的是，不可以修改其引用，如果说我可以通过调用对象提供的修改方法那么完全是可以修改的。\n\n\n\n那么String类不可变的真正原因是什么呢？\n\n- 首相String类被final修饰，也就是不可以被继承，我们知道继承及侵入式的，不可以继承那么就没有子类可以破坏其不可变性。（不仅仅是String八大基本数据类型的包装类型都是fianl的）\n- String类底层是一个字符数组，其作为String的属性，被private修饰，也就是不提供外部访问\n- String类底层是一个字符数组，其作为String的属性，被final修饰，不可修改字符数组引用\n- 最后一点也是最重要的，String类中未提供任何修改其字符数组的方法（无论是私有的还是公开的），其内部方法返回的都是一个String\n\n\n\n###### String真的不可变吗\n\n> 我们直到`Java`提供了一个很强大的机制，就是反射，那么我们是否可以通过反射来破坏String底层数组的private和final呢？\n\n写一个测试案例：可以通过反射来修改被fianl修饰的属性\n\n```java\n@Test\npublic void testFinal() throws NoSuchFieldException, IllegalAccessException {\n  TestFinal testFinal = new TestFinal();\n  System.out.println(testFinal.sb + \":\" + VM.current().addressOf(testFinal.sb));\n  final Field sb = testFinal.getClass().getDeclaredField(\"sb\");\n  final StringBuilder abc = new StringBuilder(\"abc\");\n  //反射破坏不可修改\n  sb.setAccessible(true);\n  sb.set(testFinal, abc);\n  System.out.println(testFinal.sb + \":\" + VM.current().addressOf(testFinal.sb));\n}\nclass TestFinal {\n    final StringBuilder sb = new StringBuilder(\"123\");\n}\n```\n\n结果很意外，被final修饰的属性其值可以被改变，且其内存地址也发生了改变，也就是sb的引用也别修改了\n\n![image-20220731214248215](java成神之路(基础).assets/image-20220731214248215.png)\n\n同理我们尝试修改String的字符数组：\n\n```java\n/**\n * 我们都知道String其内部是字符数组，且是私有的，那么我们是否可以通过反射修改其私有属性\n */\n@Test\npublic void test3() throws NoSuchFieldException, IllegalAccessException {\n    String str = \"123\";\n    System.out.println(str + \":\" + VM.current().addressOf(str));\n\n    final Field value = str.getClass().getDeclaredField(\"value\");\n    value.setAccessible(true);\n    value.set(str, \"abc\".toCharArray());\n    System.out.println(str + \":\" + VM.current().addressOf(str));\n\n    String str2 = \"123\";\n    System.out.println(str2 + \":\" + VM.current().addressOf(str2));\n\n    String str3 = \"abc\";\n    System.out.println(str3 + \":\" + VM.current().addressOf(str3));\n}\n```\n\n> 结果有令人很惊讶\n\n- 可以修改String的属性字符数组的值，且不会修改其引用\n- String str2 = \"123\";为何值为”abc“，这里我只能猜测，String的缓存池中记录着这么一个 ”123“字符串，但是其内部的字符数组指向的是['a','b','c']\n\n![image-20220731215113520](java成神之路(基础).assets/image-20220731215113520.png)\n\n\n\n###### String为什么设计成不可变的\n\n> \n\n\n\n- 缓存池\n\n  > String是很常用的，为了避免频繁创建相同的字符串，JVM特地在堆内存中开辟了一块空间叫字符串缓存池，专门用于缓存已创建的字符串。\n\n  如果说需要的字符串在缓存池中存在，那么直接去缓存池中取即可，不用再去创建。\n\n- 安全\n\n  > 字符串用于存储的内容还是很广泛的，密码、url、账号信息等等，如果说String可以很容易的被改变，那么整个系统奖没有可信度可言了。\n\n- 线程安全\n\n  > 线程安全性问题，只出现在可修改的数据上，String不可变那么自动保证线程安全。\n\n- 拷贝安全\n\n  > 我们知道在深拷贝的时候，需要考虑对象属性的拷贝，以不影响原型对象，而String不可变在拷贝的时候无需考虑他的拷贝。\n\n- hash缓存\n\n  > 当字符串作为哈希实现的key值的时候。在对这些散列实现进行操作时，经常调用hashCode()方法。\n  >\n  > 不可变性保证了字符串的值不会改变，其哈希值也不会变，只有在首次哈希的时候会计算哈希值，之后会直接去取已计算的哈希值。\n\n  ```java\n  /** Cache the hash code for the string */\n  private int hash; // Default to 0\n  public int hashCode() {\n      int h = hash;\n      if (h == 0 && value.length > 0) {\n          char val[] = value;\n          for (int i = 0; i < value.length; i++) {\n              h = 31 * h + val[i];\n          }\n          hash = h;\n      }\n      return h;\n  }\n  ```\n\n###### 小结\n\n> 以上提到的String的缓存池技术，hashCode()缓存技术，都旨在与提高性能，因为String是非常常用的数据类型，对于它的性能即便是小小的提升，映射到整个java生态中，也是庞大的提升。\n\n\n\n##### substring\n\n> 介绍subString方法的原理，以及在jdk6和jdk6之后版本中的不同之处，jdk6中的substring方法的问题\n\n\n\n###### JDK6中substring的实现原理\n\n> String底层是一个字符数组，在jdk6中String有三个成员变量：`char value[]` `int offset` `int count`。分别表示字符数组、起始下标、字符个数。\n\n```java\nString(int offset, int count, char value[]) {\n    this.value = value;\n    this.offset = offset;\n    this.count = count;\n}\n\npublic String substring(int beginIndex, int endIndex) {\n    //check boundary\n    return  new String(offset + beginIndex, endIndex - beginIndex, value);\n}\n```\n\n在调用substring方法的时候会返回一个新的string对象，但其内部的字符数组引用任然指向原堆中的字符数组，只不过其实下标和字符数量不同。\n\n图示：\n\n![image-20220731235844909](java成神之路(基础).assets/image-20220731235844909.png)\n\n\n\n###### JDK6中substring存在的问题\n\n> 由于截取的字符串和原字符串引用的是同一个字符数组，如果原字符串很大，但是截取的部分很小，那么就会导致，原来很长的字符串所指向的字符数组即便不会使用也一直会被引用，就会无法回收，导致内存泄漏。 还有就是效率问题，我只需要截取一小段，却引用了整个字符数组。\n>\n> 解决方式是截取后的字符串重新创建一个字符串。\n\n```java\nx = x.substring(x, y) + \"\"\n```\n\n\n\n###### jdk7对于sbustring的优化\n\n> 优化方式是调用sbustring方法生成的字符串其内部字符数组的引用，指向一个新创建的字符数组。\n\n```java\n//JDK 7\npublic String(char value[], int offset, int count) {\n    //check boundary\n    this.value = Arrays.copyOfRange(value, offset, offset + count);\n}\n\npublic String substring(int beginIndex, int endIndex) {\n    //check boundary\n    int subLen = endIndex - beginIndex;\n    return new String(value, beginIndex, subLen);\n}\n```\n\n![image-20220801000754715](java成神之路(基础).assets/image-20220801000754715.png)\n\n\n\n##### replcae\n\n```java\n//将所有的replacement字符替换为target字符\npublic String replace(CharSequence target字符, CharSequence replacement) {\n    return Pattern.compile(target.toString(), Pattern.LITERAL).matcher(\n            this).replaceAll(Matcher.quoteReplacement(replacement.toString()));\n}\n//将所有的replacement字符串替换为target字符串\npublic String replaceAll(String regex, String replacement) {\n    return Pattern.compile(regex).matcher(this).replaceAll(replacement);\n}\n//将首个replacement字符串替换为target字符串\npublic String replaceFirst(String regex, String replacement) {\n    return Pattern.compile(regex).matcher(this).replaceFirst(replacement);\n}\n```\n\n\n\n##### 字符串拼接\n\n\n\n###### 通过+拼接\n\n> 字符串通过`+`拼接的原理\n\n```java\npublic void test1() {\n  String str1 = \"abc\" + \"123\";\n  System.out.println(str1);\n}\n\nvoid method(String str1, String str2) {\n  final String strX = str1 + \",\" + str2;\n}\n```\n\n反编译后：\n\n```java\npublic void test1() {\n  String str1 = \"abc123\";\n  System.out.println(str1);\n}\n\nvoid method(String str1, String str2) {\n  (new StringBuilder()).append(str1).append(\",\").append(str2).toString();\n}\n```\n\n- 对于编译时期就知道字面量的字符串，进行常量折叠\n- 对于编译器不确定的变量，会使用StringBuilder.append拼接\n\n\n\n###### 通过concat拼接\n\n> 会重新生成一个字符串对象，其内部的字符数组也是通过ArrayCopy新拷贝出来的。\n\n```java\npublic String concat(String str) {\n    int otherLen = str.length();\n    if (otherLen == 0) {\n        return this;\n    }\n    int len = value.length;\n    char buf[] = Arrays.copyOf(value, len + otherLen);\n    str.getChars(buf, len);\n    return new String(buf, true);\n}\n```\n\n\n\n###### StringBuffer&StringBuilder\n\n> 可以使用在这两类对字符串进行拼接，最后toString返回即可\n\n###### 第三方工具类\n\n> StringUtils，可以使用Spring提供的也可以是apache提供的，都是一个用法，将一个String数组或集合，以某个字符分割拼接\n\n```java\n@Test\npublic void testAppendByUtil(){\n    String[] value = {\"hello\", \"你好\", \"hello\"};\n    String result = StringUtils.join(value, \",\");\n    System.out.println(result);\n}\n```\n\nhello,你好,hello\n\n\n\n###### String的join方法\n\n\n\n```java\n@Test\npublic void testAppendByStr(){\n    String join = String.join(\",\", \"hello\", \"你好\", \"hello\", \"4\");\n    System.out.println(join);\n}\n```\n\nhello,你好,hello,4\n\n\n\n###### 性能对比\n\n```java\n@Test\npublic void testAppend() {\n    StopWatch stopWatch = new StopWatch();\n    stopWatch.start(\"使用+拼接字符串\");//任务说明\n    String str1 = \"\";\n    for (int i = 0; i < 50000; i++) {\n        //str1 += \"a\";  拼接代码\n    }\n    stopWatch.stop();\n    System.out.println(stopWatch.getLastTaskName() +\"消耗时长：\"+stopWatch.getTotalTimeNanos());\n}\n```\n\n```java\n使用+拼接字符串消耗时长：1942387300\n使用StringBuilder拼接字符串消耗时长：2846001\n使用StringBuffer拼接字符串消耗时长：4217800\n使用concat拼接字符串消耗时长：5055200\n使用StringUtils  join拼接字符串消耗时长：39924299\n```\n\n结果是：StringBuilder > StringBuffer  >  concat> StringUtils > `+`\n\n> StringBuffer  append方法基于StringBuilder实现，同时也是同步的，性能差一点点。\n\n> concat每次循环，都会进行数组拷贝，创建新字符串，性能差点。但也是为了保证字符串的不可变性\n\n> StringUtils底层使用的StringBuilder实现，拼接过程存在很多其他操作，回去判断对象是否为空等，性能也差点\n\n> `+`号是我们很常用的，性能却最差，这是为什么呢？\n\n查看使用`+`拼接字符串的反编译后的代码：\n\n> 发现每次循环都会new一个StringBuilder出来，再进行append，性能自然不会很高了。频繁的创建对象，也是对内存资源的浪费。\n\n```java\nvoid append1() {\n    StopWatch stopWatch = new StopWatch();\n    stopWatch.start(\"使用+拼接字符串\");\n    String str1 = \"\";\n    for (int i = 0; i < 50000; i++) {\n        str1 += \"a\";\n    }\n    stopWatch.stop();\n    System.out.println(stopWatch.getLastTaskName() + \"消耗时长：\" + stopWatch.getTotalTimeNanos());\n}\n```\n\n```java\nvoid append1()\n{\n    StopWatch stopWatch = new StopWatch();\n    stopWatch.start(\"\\u4F7F\\u7528+\\u62FC\\u63A5\\u5B57\\u7B26\\u4E32\");\n    String str1 = \"\";\n    for(int i = 0; i < 50000; i++)\n        str1 = (new StringBuilder()).append(str1).append(\"a\").toString();\n\n    stopWatch.stop();\n    System.out.println((new StringBuilder()).append(stopWatch.getLastTaskName()).append(\"\\u6D88\\u8017\\u65F6\\u957F\\uFF1A\").append(stopWatch.getTotalTimeNanos()).toString());\n}\n```\n\n###### 小结\n\n> 对于循环体内字符串的拼接禁止使用`+`，采用`StringBuilder`的`append`的方式进行字符串拼接。有并发需求时，使用`StringBuffer`代替`StringBuilder`。\n\n\n\n##### StringBuffer & StringBuilder\n\n> String是不可变的，java还为我们提供了两个可变的用于操作字符串的类，StringBuffer  & StringBuilder\n\nStringBuilder和StringBuilder都是AbstractStringBuilder的子类。底层也是字符数组，使用一个成员变量count来表示字符数组已使用的字符数。\n\n```java\nchar[] value;\n\nint count;\n```\n\n> StringBuilder是非线程安全的，StringBuffer是线程安全的（使用Synchronized保证）。\n\n\n\n\n\n##### String.valueOf  & Intege.toString\n\n> 将一个`Integer`转化为`String`有几种方式？\n\n```java\n@Test\npublic void test(){\n    int i = 10;\n    String str1 = i + \"\";\n    String str2 = Integer.valueOf(i).toString();\n    String str3 = String.valueOf(10);\n}\n```\n\n> 第一种方式使用`StringBuilder`\n\n```java\nString str1 = (new StringBuilder()).append(i).append(\"\").toString();\n```\n\n> 第二种和第三种都是使用`Integer.toString()`\n\n\n\n##### switch支持String\n\n> jdk7之后`switch`添加了对`String`的支持。\n>\n> `switch`目前支持的类型有Character, Byte, Short, Integer, String, or an enum，`switch`真正意义上只支持整型，对于`Character`会转化成ASCII码，ASCII是一个`int`类型的数据。`String`会优先通过`hashCode`判断，然后再通过`equals`进行安全检查，`hashCode`也是`int`类型的\n\n###### int&short&byte\n\n代码：\n\n```java\n@Test\npublic void testInt() {\n    int i = 10;\n    switch (i) {\n        case 1:\n            System.out.println(1);\n            break;\n        case 2:\n            System.out.println(2);\n            break;\n        case 3:\n            System.out.println(3);\n            break;\n        default:\n            System.out.println(i);\n    }\n}\n```\n\n反编译查看：\n\n> 没什么特别的，switch对int支持很好。对Short和byte也是一样的，不支持long\n\n```java\npublic void testInt()\n{\n    int i = 10;\n    switch(i)\n    {\n    case 1: // '\\001'\n        System.out.println(1);\n        break;\n\n    case 2: // '\\002'\n        System.out.println(2);\n        break;\n\n    case 3: // '\\003'\n        System.out.println(3);\n        break;\n\n    default:\n        System.out.println(i);\n        break;\n    }\n}\n```\n\n\n\n###### char\n\n代码：\n\n```java\n@Test\npublic void testChar() {\n    char c = 'a';\n    switch (c) {\n        case 'a':\n            System.out.println('a');\n            break;\n        case 'b':\n            System.out.println('b');\n            break;\n        case 'c':\n            System.out.println('c');\n            break;\n        default:\n            System.out.println(c);\n    }\n}\n```\n\n反编译查看：\n\n> 会将char转化成对应的ascii码值，再通过整型switch\n\n```java\npublic void testChar()\n{\n    char c = 'a';\n    switch(c)\n    {\n    case 97: // 'a'\n        System.out.println('a');\n        break;\n    case 98: // 'b'\n        System.out.println('b');\n        break;\n    case 99: // 'c'\n        System.out.println('c');\n        break;\n    default:\n        System.out.println(c);\n        break;\n    }\n}\n```\n\n\n\n###### string\n\n代码：\n\n```java\n@Test\npublic void testString() {\n    String str = \"abc\";\n    switch (str) {\n        case \"abc\":\n            System.out.println(\"a\");\n            break;\n        case \"bac\":\n            System.out.println(\"b\");\n            break;\n        case \"cab\":\n            System.out.println(\"c\");\n            break;\n        default:\n            System.out.println(str);\n    }\n}\n```\n\n反编译查看：\n\n> 发现首先获取哈希值，哈希值是整型，然后进行switch，最后使用equals进行安全判断。\n\n```java\npublic void testString()\n{\n    String str = \"abc\";\n    String s = str;\n    byte byte0 = -1;\n    switch(s.hashCode())\n    {\n    case 96354: \n        if(s.equals(\"abc\"))\n            byte0 = 0;\n        break;\n\n    case 97284: \n        if(s.equals(\"bac\"))\n            byte0 = 1;\n        break;\n\n    case 98244: \n        if(s.equals(\"cab\"))\n            byte0 = 2;\n        break;\n    }\n    switch(byte0)\n    {\n    case 0: // '\\0'\n        System.out.println(\"a\");\n        break;\n\n    case 1: // '\\001'\n        System.out.println(\"b\");\n        break;\n\n    case 2: // '\\002'\n        System.out.println(\"c\");\n        break;\n\n    default:\n        System.out.println(str);\n        break;\n    }\n}\n```\n\n\n\n##### 字符串缓存池\n\n> 创建字符串的方式有以下两种方式:\n\n```java\n@Test\npublic void testStrCache(){\n    String str1 = \"abc\";\n    String str2 = new String(\"abc\");\n}\n```\n\n- 第一种方式通过\"字面量\"的形式赋值，字符串如果在缓存池中不存在，则会创建并放入缓存池\n- 第二种方式会将字符串对象当作一个普通的对象类型，放在堆内存中\n\n> 当我们使用字面量创建字符串的时候，jvm会对此字符串进行检查，如果该字符串在缓存池中不存在，则会创建该字符串，并将其放入字符串缓存池；如果该字符串存在，那么直接将缓存池中的字符串对象的引用返回。\n\n```java\n@Test\npublic void testStrCache2(){\n    String str1 = \"abc\";\n    String str2 = String.valueOf(\"abc\");//String.valueOf也是字面量，调用toString方法直接返回\n    String str3 = \"abc\";\n    System.out.println(str1 == str2);//true\n    System.out.println(str2 == str3);//true\n    System.out.println(str1 == str3);//true\n}\n```\n\n\n\n> 字符串缓存池在内存中的哪个位置\n\njdk7之前，字符串缓存池在永久代中。\n\njdk7中，由于后续版本计划通过元空间代替永久代，所以先将字符串缓存池从永久代移出，暂时放入堆内存。\n\njdk8中，彻底废除了永久代，使用元空间代替永久代，字符串常量池从堆内存，移动到永久代。\n\n##### String长度限制？\n\n> `String`存不存在长度限制呢？\n\n- 在编译期间不可以超过 2^16^-1 = 65535\n\n  也就是我们在使用字面量对字符串赋值的时候如果字符串长度大于等于65535，就通过不了编译\n\n- 运行期间限制：不能超过int的范围\n\n\n\n#### java中的各种关键字\n\n\n\n##### transient\n\n> 短暂瞬时的意思，java提供的关键字，用于修饰成员变量。如果一个变量被`transient`修饰，当对象需要序列化传输、或存储时，会忽略该变量。\n>\n> 当我们不希望对象的某个变量需要被序列化的时候，比如我们定义一个变量，该变量我们只希望它在当前系统中使用，而不希望他在上下游系统传输，可以使用`transient`修饰。\n\n被transient修饰的引用类型也就是对象类型，在被反序列化的时候初始化为null，基本数据类型为默认值int就是0。\n\n> 创建一个对象，注意需要实现序列化接口支持序列化操作。如果存在特殊需求可以重写writeObjec方法和readObject方法。\n\n```java\n@Data\nclass TransientTestClass implements Serializable {\n    private static final long serialVersionUID = 9167810647635375505L;\n  \n    private String str;\n    private Integer value;\n    private transient String name;\n    private transient int age;\n}\n```\n\n> 将对象序列化持久化到本地\n\n```java\nString filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile\";\n\n@Test\npublic void test1() throws IOException {\n    final TransientTestClass transientTestClass = new TransientTestClass();\n    transientTestClass.setName(\"element\");\n    transientTestClass.setStr(\"element\");\n    transientTestClass.setValue(123);\n    //序列化到文件\n    final ObjectOutputStream objectOutputStream = new ObjectOutputStream(\n            new FileOutputStream(new File(filePath, transientTestClass.getClass().getName())));\n    objectOutputStream.writeObject(transientTestClass);\n    objectOutputStream.flush();\n    objectOutputStream.close();\n}\n```\n\n> 再通过反序列化将文件中的对象读出来，查看其属性值\n\n```java\n/**\n * 读出来，使用对象接收看看\n */\n@Test\npublic void test2() throws IOException, ClassNotFoundException {\n    final ObjectInputStream objectInputStream = new ObjectInputStream(\n            new FileInputStream(new File(filePath, TransientTestClass.class.getName())));\n    TransientTestClass transientTestClass = (TransientTestClass) objectInputStream.readObject();\n    System.out.println(transientTestClass);\n}\n```\n\n> 结果也如我们说的一样\n\n![image-20220801235653264](java成神之路(基础).assets/image-20220801235653264.png)\n\n##### instanceof\n\n> java关键字，类似于一个二元操作符，用于判断`instanceOf`左右两边对象类型是否一致。\n\n```java\n@Test\npublic void test() {\n    System.out.println(InstanceofTest.class instanceof Object);\n    System.out.println(\"InstanceofTest.class\" instanceof String);\n    System.out.println(Integer.valueOf(10) instanceof Integer);\n\n    Object o = Integer.valueOf(10);\n    System.out.println(o instanceof String);\n}\n```\n\n![image-20220802000331345](java成神之路(基础).assets/image-20220802000331345.png)\n\n\n\n##### synchronized\n\n[synchronized](https://juejin.cn/post/7077457448290189348)\n\n> 后续重点看\n\n\n\n##### volatile\n\n[volatile](https://juejin.cn/post/7077459563963908109)\n\n> 后续重点看\n\n\n\n##### final\n\n[final](https://juejin.cn/post/7077469542946979847)\n\n> `final`是`java`提供的关键字，表示该部分不可修改，可修饰类、方法、变量。\n\n######  final修饰类\n\n> final 修饰类表示该类不可以被继承。一般是类的自我保护，不希望子类对父类造成破坏。\n\n> 比如说`String`和八大基本数据类型的包装类型\n\n\n\n###### final修饰方法\n\n> 表示该方法不可以被子类重写，但是可以在本类中重载。\n\n\n\n###### final修饰变量\n\n> 被final修饰的变量如果是基本数据类型则其不可变，如果是引用数据类型则其引用地址不可变。\n\n> 作为局部变量\n\n不管是引用类型还是基本数据类型，都不可以使用等号赋值。但是如果引用数据类型存在修改方法的时候是可以修改对象的引用的。\n\n```java\n@Test\npublic void test01() {\n    final StringBuilder sb = new StringBuilder(\"abc\");\n    final int i = 10;\n    sb.append(\"123\");\n    System.out.println(sb.toString());\n}\n```\n\n\n\n> 作为成员变量\n\n```java\nclass MemberField {\n    /**\n     * 被static final修饰，属于类不可变。必须1、在声明的时候赋值 2、或static代码块中赋值\n     */\n    static final StringBuilder sb1 = new StringBuilder();\n    /**\n     * 被final修饰，属于实例，不可变。必须1、在声明的时候赋值 2、非static代码块中赋值 3、构造方法赋值\n     */\n    final StringBuilder sb2 ;\n    {\n        sb2 = new StringBuilder();\n    }\n}\n```\n\n\n\n##### static\n\n> 用于修饰成员变量、方法或代码块，被static修饰的成员变量称为静态成员变量或类变量属于类，被static修饰的代码块称为静态代码块。\n\n###### 静态成员变量\n\n> 也称为类变量，它不属于类的某个实例，它被所有该类的实例共享，因此存在线程安全问题。\n>\n> 如果类变量没有被private修饰，可以使用”类名.变量名“的方式访问。\n\n###### 静态方法\n\n> 和静态变量一样，静态方法也属于类，以`类名 。方法名`调用，在此期间不必创建类的实例，因此会方便许多。\n\n> 比如说集合工具类返回空集合Collections.emptyList();\n\n> java8支持在接口中定义静态方法\n\n```java\ninterface IStaticMethod{\n    static void method1() {\n        Collections.emptyList();\n    }\n    default void method2(){\n    }\n}\n```\n\n\n\n###### 静态代码块\n\n> 静态代码块会在类初始化的时候，将所有静态代码组合成一个`cinit<>`方法，由类加载器执行。一个类在其一个生命周期内只加载一次，所以说对于静态代码块，在类生命周期中只执行一次。\n\n```java\npublic class AboutStatic {  \n    static int a;\n    static {\n        a = 1;\n        System.out.println(\"静态代码块执行\");\n    }\n    {\n        System.out.println(\"非静态代码块执行\");\n    }\n    public static void main(String[] args) {\n        for (int i = 0; i < 100; i++) {\n            new AboutStatic();\n        }\n    }\n}\n```\n\n<img src=\"java成神之路(基础).assets/image-20220802164043054.png\" alt=\"image-20220802164043054\" style=\"zoom:67%;\" />\n\n###### 静态类\n\n> 静态内部类定义于普通类内部，可以和普通类一样使用。\n>\n> 下面列出类：内部类、静态内部类和匿名内部类写法\n\n```java\npublic class AboutStaticClass {\n    static class StaticClass {\n        int a;\n        static int b;\n    }\n    class InnerClass {\n        int a;\n        //不可以定义静态变量\n        //static int b;\n    }\n    void method() {\n        AboutStaticClass.InnerClass innerClass = new AboutStaticClass.InnerClass();\n    }\n    //匿名内部类写法\n     IInterface ia = new IInterface() {\n        @Override\n        public void method() {\n        }\n    };\n}\nclass TestClass {\n    public static void main(String[] args) {\n        AboutStaticClass.StaticClass staticClass = new AboutStaticClass.StaticClass();\n        System.out.println(AboutStaticClass.StaticClass.b);\n    }\n}\n@FunctionalInterface\ninterface IInterface{\n    void method();\n}\n```\n\n##### const\n\n> const和final相似，用于后期扩展。\n\n\n\n#### 枚举\n\n> 枚举类型是java5引入的，由一组固定常量组成的合法类型。\n\n##### 在枚举引入之前如何定义一组常量\n\n> java在枚举引入之前，我们一般会用一组int常量值，来表示一组固定的数据。比如使用1、2、3、4来表示春、夏、秋、冬。\n\n```java\n/**\n * 枚举类型一般会被系统共享，所以其访问修饰符一般为public\n */\nclass Season {\n    public static final int SPRING = 1;\n    public static final int SUMMER = 2;\n    public static final int AUTUMN = 3;\n    public static final int WINTER = 4;\n}\n```\n\n> 可以根据传入的int值来判断对应季节\n\n```java\n@Test\npublic void test1() {\n    final int spring = Season.SPRING;\n    season(spring);\n}\npublic void season(int value) {\n    switch (value) {\n        case 1:\n            System.out.println(\"春天\");\n            break;\n        case 2:\n            System.out.println(\"夏天\");\n            break;\n        case 3:\n            System.out.println(\"秋天\");\n            break;\n        case 4:\n            System.out.println(\"冬天\");\n            break;\n        default:\n            System.out.println(\"输入不合法\");\n            break;\n    }\n}\n```\n\n这种方法称作int枚举模式。存在一些安全问题，就如上面判断季节的方法，default分支是我们不愿意看到的场景，如果说我们不加校验可能会产生问题。并且Season这个类打印出来的也只是一个int值1、2、3、4，表面并不能看出任何的意思。所以说int枚举模式他的安全性和可读性是不可观的。\n\n> 当然了我们也可以使用字符串作为枚举值，但是字符串的比较算法相对来说比较浪费性能，也是不可取的。\n\n\n\n##### 定义枚举\n\n> 由于int枚举和字符串枚举存在着缺陷，java5引入了枚举类型`enum type`，接下来我们看如何定义一个枚举。\n\n使用enum声明一个枚举，在枚举类中列举枚举值，使用逗号隔开，尾部使用分号结尾。\n\n```java\nenum Season2 {\n    SPRING, SUMMER, AUTUMN, WINTER;  \n}\n```\n\n并且我们还可以为枚举定义属性：\n\n```java\n@AllArgsConstructor\nenum Season3 {\n    SPRING(1, \"春天\"),\n    SUMMER(1, \"春天\"),\n    AUTUMN(1, \"春天\"),\n    WINTER(1, \"春天\");\n    int code;\n    String msg;\n}\n```\n\n##### 特点\n\n- 简约\n- 和普通class类一样，枚举类可以单独存在，也可以存在于其他java类中\n- 枚举类可以实现接口\n- 也可以定义新的属性和方法\n\n\n\n##### switch对于枚举的支持\n\n> 使用枚举改造上面代码\n\n```java\npublic void seasonUseEnum(Season2 season) {\n    System.out.println(Season2.SPRING);\n    switch (season) {\n        case SPRING:\n            System.out.println(\"春天\");\n            break;\n        case SUMMER:\n            System.out.println(\"夏天\");\n            break;\n        case AUTUMN:\n            System.out.println(\"秋天\");\n            break;\n        case WINTER:\n            System.out.println(\"冬天\");\n            break;\n        default:\n            System.out.println(\"输入不合法\");\n            break;\n    }\n}\n\n@Test\npublic void test2() {\n    seasonUseEnum(Season2.SPRING);\n}\n```\n\n> 如此判断季节的方法对于传入参数存在类型限制，不会再有不合法参数的出现。一般来说我们会对枚举添加表示域的属性和对应的描述，方便统一管理。\n\n```java\npublic void seasonUseEnum(Season3 season) {\n    System.out.println(Season2.SPRING);\n    final StringBuilder sb = new StringBuilder();\n    switch (season) {\n        case SPRING:\n        case WINTER:\n        case AUTUMN:\n        case SUMMER:\n            sb.append(season.msg);\n            break;\n        default:\n            System.out.println(\"输入不合法\");\n            break;\n    }\n    System.out.println(sb.toString());\n}\n@Test\npublic void test3() {\n    seasonUseEnum(Season3.SPRING);\n}\n```\n\n\n\n###### jad查看原理\n\n> 可以使用jad 反编译一下，查看一下底层原理\n\n可以得出如下结论：\n\n- 枚举类经过编译器编译后会被当作普通类处理，继承自 `java.lang.Enum`\n- 每一个枚举项是一个 `final static`的成员变量。天生是一个单例\n\n\n\n```java\nfinal class Season3 extends Enum\n{\n    private Season3(String s, int i, int code, String msg)\n    {\n        super(s, i);\n        this.code = code;\n        this.msg = msg;\n    }\n    public static final Season3 SPRING;\n    public static final Season3 SUMMER;\n    public static final Season3 AUTUMN;\n    public static final Season3 WINTER;\n    int code;\n    String msg;\n    private static final Season3 $VALUES[];\n    static \n    {\n        SPRING = new Season3(\"SPRING\", 0, 1, \"\\u6625\\u5929\");\n        SUMMER = new Season3(\"SUMMER\", 1, 1, \"\\u6625\\u5929\");\n        AUTUMN = new Season3(\"AUTUMN\", 2, 1, \"\\u6625\\u5929\");\n        WINTER = new Season3(\"WINTER\", 3, 1, \"\\u6625\\u5929\");\n        $VALUES = (new Season3[] {\n            SPRING, SUMMER, AUTUMN, WINTER\n        });\n    }\n}\n```\n\n> 但是要想知道switch对枚举的支持的原理，其实就在构造函数内，会调用super(s,i)。s是String类型为枚举项的字段名称，i为自动生成的编号。\n>\n> 我们使用jad对switch相关代码反编译一下：\n\n- 首先枚举类中的每一个枚举都是一个单例对象，在使用new 关键字创建实例的时候会为各个实例添加一个编号 ordinal\n- 在引用了枚举类的类中，会在static代码块中初始化一个int类型的数组，用于描述各个枚举值对应的编号\n- switch还是对int做操作\n\n```java\n {\n     static final int $SwitchMap$com$roily$booknode$javatogod$_01faceobj$javakeywords$aboutenum$Season3[];\n     static \n     {\n         $SwitchMap$com$roily$booknode$javatogod$_01faceobj$javakeywords$aboutenum$Season3 = new int[Season3.values().length];\n         $SwitchMap$com$roily$booknode$javatogod$_01faceobj$javakeywords$aboutenum$Season3[Season3.SPRING.ordinal()] int= 1;\n         $SwitchMap$com$roily$booknode$javatogod$_01faceobj$javakeywords$aboutenum$Season3[Season3.WINTER.ordinal()] = 2;\n         $SwitchMap$com$roily$booknode$javatogod$_01faceobj$javakeywords$aboutenum$Season3[Season3.AUTUMN.ordinal()] = 3;\n         $SwitchMap$com$roily$booknode$javatogod$_01faceobj$javakeywords$aboutenum$Season3[Season3.SUMMER.ordinal()] = 4;\n     }\n }\npublic void seasonUseEnum(Season3 season)\n{\n    System.out.println(Season2.SPRING);\n    StringBuilder sb = new StringBuilder();\n    switch(_cls1..SwitchMap.com.roily.booknode.javatogod._01faceobj.javakeywords.aboutenum.Season3[season.ordinal()])\n    {\n    case 1: // '\\001'\n    case 2: // '\\002'\n    case 3: // '\\003'\n    case 4: // '\\004'\n        sb.append(season.msg);\n        break;\n    default:\n        System.out.println(\"\\u8F93\\u5165\\u4E0D\\u5408\\u6CD5\");\n        break;\n    }\n}\n```\n\n##### 枚举是单例的最佳实践\n\n> 单例的实现方式存在很多，懒汉式、饿汉式、双重检验锁、静态内部类、枚举\n\n单例的设计主要考虑两个问题：\n\n- 延时加载\n\n  > 在希望使用的时候才进行单例创建，在未正真使用不创建。那么双重检验锁、静态内部类符合需求\n\n- 线程安全\n\n  > 单例实现的复杂问题在于需要考虑线程安全问题，同时兼虑性能。懒汉式非线程安全。\n\n1、懒汉式可实现，但非线程安全\n\n2、饿汉式不行，饿汉式单例的创建由类加载器实现，但线程安全\n\n3、懒汉式配合Synchronized可实现，但影响性能(会对访问单例也进行加锁操作,但访问是没有线程安全问题的)\n\n4、双重检验锁可延时加载：是对懒汉式+锁机制的优化。避免读时加锁\n\n5、静态内部类可实现且线程安全，也是类加载器保证的线程安全\t\n\n###### 为何枚举是单例的最佳实现？\n\n- 枚举天生单例，且线程安全，枚举作为内部类可实现延时加载。\n- 枚举可避免序列化、或反射 破坏单例 （枚举的序列化是定制的，序列化时会将枚举项名记录）\n\n以上编写枚举反编译查看枚举中的每一个枚举项都被final static 修饰，且在static代码块中初始化，这也就是饿汉式单例的实现。\n\n###### 尝试使用反射破坏单例\n\n我们知道单例的实现，重点在于构造函数私有化，并提供获取实例的方法，那么我们就来破坏构造方法的私有性\n\n首先写一个单例类：\n\n```java\npublic class SingleDemo implements Serializable {\n    private static final long serialVersionUID = -6489201409969990006L;+\n    private static SingleDemo singleDemo;\n    //构造方法私有化\n    private SingleDemo() {\n    }\n    public static SingleDemo getInstance() {\n        if (null == singleDemo){\n            singleDemo = new SingleDemo();\n        }\n        return singleDemo;\n    }\n}\n```\n\n```java\n@Test\npublic void testSingle() {\n    final SingleDemo instance1 = SingleDemo.getInstance();\n    final SingleDemo instance2 = SingleDemo.getInstance();\n    System.out.println(instance1 == instance2);\n}\n```\n\n![image-20220826013226826](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208260141690.png)\n\n反射破坏单例：\n\n```java\nfinal SingleDemo instance1 = SingleDemo.getInstance();\nfinal Constructor<? extends SingleDemo> declaredConstructor = instance1.getClass().getDeclaredConstructor();\ndeclaredConstructor.setAccessible(true);\nfinal SingleDemo singleDemo = declaredConstructor.newInstance(null);\nSystem.out.println(instance1 == singleDemo);\n```\n\n![image-20220826013415047](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208260141341.png)###### 序列化破坏单例\n\n先执行test1，再执行test2\n\n```java\n@Test\npublic void test1() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile\";\n    final SingleDemo instance1 = SingleDemo.getInstance();\n    try (final ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(new File(filePath, \"object.txt\")))) {\n        //将instance写入文件\n        objectOutputStream.writeObject(instance1);\n        objectOutputStream.flush();\n    } catch (IOException e) {\n    }\n}\n@Test\npublic void test2() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile\";\n    final SingleDemo instance1 = SingleDemo.getInstance();\n    SingleDemo sngleDemo = null;\n    try (final ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(new File(filePath, \"object.txt\")))) {\n        //将instance写入文件\n        sngleDemo = (SingleDemo) objectInputStream.readObject();\n    } catch (IOException | ClassNotFoundException e) {\n    }\n    System.out.println(sngleDemo == instance1);\n    System.out.println(sngleDemo);\n    System.out.println(instance1);\n}\n```\n\n![image-20220826014043371](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208260152931.png)\n\n\n\n###### 枚举可避免以上问题\n\n> 尝试使用反射破坏枚举单例：枚举的构造方法除枚举自定义的还有Enum类中的code。\n>\n> 会报出`IllegalArgumentException`异常，不可以使用反射创建枚举对象。\n\n```java\n@Test\npublic void test2() throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {\n    final Constructor<? extends SignalEnum> declaredConstructor = SignalEnum.SIGNAL_ENUM.getClass().getDeclaredConstructor(String.class,int.class);\n    declaredConstructor.setAccessible(true);\n    final SignalEnum signalEnum = declaredConstructor.newInstance(\"signalEnum\",2);\n    System.out.println(signalEnum == SignalEnum.SIGNAL_ENUM);\n    System.out.println(SignalEnum.SIGNAL_ENUM);\n    System.out.println(signalEnum);\n}\n```\n\n![image-20220826015207256](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208260152336.png)\n\n> 尝试使用序列化破坏枚举单例\n\n先执行testx  再执行testy\n\n结果是true，表示序列化不会破坏枚举单例。\n\n```java\n@Test\npublic void testx() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile\";\n    final SignalEnum signalEnum = SignalEnum.SIGNAL_ENUM;\n    try (final ObjectOutputStream objectOutputStream = new ObjectOutputStream(\n            new FileOutputStream(new File(filePath, \"object2.txt\")))) {\n        //将instance写入文件\n        objectOutputStream.writeObject(signalEnum);\n        objectOutputStream.flush();\n    } catch (IOException e) {\n    }\n}\n\n@Test\npublic void testy() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile\";\n    final SignalEnum signalEnum = SignalEnum.SIGNAL_ENUM;\n    SignalEnum signalEnum2 = null;\n    try (final ObjectInputStream objectInputStream = new ObjectInputStream(\n            new FileInputStream(new File(filePath, \"object2.txt\")))) {\n        //将instance写入文件\n        signalEnum2 = (SignalEnum) objectInputStream.readObject();\n    } catch (IOException | ClassNotFoundException e) {\n    }\n    System.out.println(signalEnum == signalEnum2);\n    System.out.println(signalEnum);\n    System.out.println(signalEnum2);\n}\n```\n\n![image-20220826015618559](java成神之路(基础).assets/image-20220826015618559.png)\n\n原因：\n\n\n\n\n\n### 异常处理\n\n> `ThrowAble`类下有两个重要的子类：`Error`和`Exception`,并且这两个子类下面也存在着大量的子类。\n>\n> `Error`表示系统或硬件级别的错误，由java虚拟机抛出异常，程序员无法处理。\n>\n> `Exception`表示程序级别的错误，是由于程序设计不完善而出现的问题，程序员必须手动处理\n\n#### 异常类型\n\n 主要分两大类：\n\n- 受检异常(checked   exception)\n- 非受检异常(unchecked   exception)\n\n\n\n##### 受检异常\n\n> 受检异常声明：在对应方法上通过`throws`关键字，声明一个异常。然后此方法在被调用的时候，调用方一定要对其做处理(要么捕获、要么向上抛出)，否则是无法通过编译的。\n>\n> 所以当我们希望调用者，必须处理一些特殊情况的时候，就可以声明受检异常。\n\n受检异常在io操作中使用的非常频繁，比如说`FileNotFoundException`异常以及`IOException`及其子类。\n\n比如：\n\n```java\npublic void test1() throws IOException {\n    IOUtils.readLines(new FileInputStream(\"filename\"),  StandardCharsets.UTF_8);\n}\npublic void test2()   {\n    try {\n        IOUtils.readLines(new FileInputStream(\"filename\"),  StandardCharsets.UTF_8);\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n查看 IOUtils.readLines()方法：发现此方法声明了受检异常：\n\n![image-20220808104023792](java成神之路(基础).assets/image-20220808104023792.png)\n\n##### 非受检异常\n\n> 非受检异常，在编码的时候不用强制捕获，但是如果不捕获，在出现异常的时候就会中断程序的运行。\n>\n> 一般来说都是运行时异常，为 `RuntimeException`及其子类。\n>\n> 比如说空指针异常(NPE)、数组下标越界异常(IOE)以及一些我们自定义的运行期间异常。对于非受检异常来说，如果代码编写的合理，这些异常都是可以避免的。\n\n#### 关键字\n\n- throws     方法声明异常\n\n- throw       后跟异常实例显示抛出异常\n\n- try            用来包裹一块可能出现异常的代码块\n\n- catch        跟在try代码后，指定异常类型，并对异常进行处理\n\n- finally        一些代码无论是否出现异常都会执行，可以定义在fianlly代码块李\n\n  \n\n#### 异常处理\n\n> 要么自己try    catch处理\n>\n> 要么向上抛出，交给调用者处理\n\n#### 自定义异常\n\n> 一般通过继承`RuntimeException`定义一个自定义异常，用于抛出一些错误的业务。\n\n```java\npublic class MyException  extends RuntimeException{\n    \n    private final String DEFAULT_ERROR_CODE = \"5000\";\n    private final String DEFAULT_ERROR_MSG = \"运行时异常\";\n    \n    String code;\n    String msg;\n    //someMethod\n    public MyException(Throwable cause, String code, String msg) {\n        super(cause);\n        this.code = code;\n        this.msg = msg;\n    }\n}\n```\n\n#### 异常链\n\n> 是指java在运行期捕获了一个异常，处理的时候，抛出了一个新的异常，所抛出的新的异常包含前一个异常的信息，如此形成一个异常链。\n\n如果抛出的异常不包含前一个异常信息的话，我们就不会清楚的知道这个异常具体出现的原因：\n\n```java\npublic void test1() {\n    try {\n        String str = null;\n        byte[] bytes = str.getBytes(StandardCharsets.UTF_8);\n    } catch (NullPointerException npe) {\n        throw new MyException(\"5000\", \"空指针异常\");\n    }\n}\n```\n\n![image-20220808111542845](java成神之路(基础).assets/image-20220808111542845.png)\n\n如果我们包含前一个异常信息，在异常抛出的时候可以，追溯到肯本原因：\n\n```java\npublic void test1() {\n。。。。\n    throw new MyException(npe, \"5000\", \"空指针异常\");\n。。。\n}\n```\n\n![image-20220808111646319](java成神之路(基础).assets/image-20220808111646319.png)\n\n#### try-with-resources\n\n> java对于资源的操作，比如说io流、数据库连接，这些资源在非常昂贵，必须在使用结束后显示的关闭资源。\n>\n> 即在finally代码块内调用对应资源的close()方法。\n\n```java\npublic void test2() {\n    BufferedReader bi = null;\n    try {\n        bi = new BufferedReader(new FileReader(\"filename\"));\n        String line;\n        while ((line = bi.readLine()) != null){\n            System.out.println(line);\n        }\n    } catch (IOException e) {\n        //dosomething\n    } finally {\n        try {\n            IOUtils.close(bi);\n        } catch (IOException e) {\n            //dosomething\n        }\n    }\n}\n```\n\n> java7 开始提供了一个跟好的处理资源的方式：try-with-resources 语句。这是一个类似于语法糖的语法，方便程序员编码，但是经过编译器编译后，都会转化成jvm认识的。\n\n将资源定义在try括号内，便无需我们手动去关闭资源了：\n\n```java\n@Test\npublic void test4() {\n    try( BufferedReader bi = new BufferedReader(new FileReader(\"filename\"))) {\n        String line;\n        while ((line = bi.readLine()) != null){\n            System.out.println(line);\n        }\n    } catch (IOException e) {\n        //dosomething\n    }\n}\n```\n\n可以使用jad反编译查看一下：\n\n发现编译器帮我们做了：\n\n![image-20220808114543526](java成神之路(基础).assets/image-20220808114543526.png)\n\n#### finally  & return\n\n- ffinally代码块一定会执行么？\n- return的结果是否被finally影响？\n- return和finally代码执行顺序，孰先孰后？\n\n##### finally代码块不一定执行\n\n> finally代码块不一定会执行\n\n- 当我们的代码在进入try代码块之前就已经return了，那么整个方法就结束了，finally代码块就不会执行\n- 当虚拟机强制停止的时候  exit(0),finally代码块就不会执行\n\n例：\n\n以下两种方式finally代码块都不会执行\n\n```java\npublic StringBuilder method1(Boolean flag) {\n    StringBuilder sb = new StringBuilder();\n    if (flag) {\n        sb.append(\"方法在try代码块之前return\\n\");\n        return sb;\n    }\n    try {\n\n    } catch (Exception e) {\n        System.out.println(\"进入try代码块\\n\");\n    } finally {\n        System.out.println(\"finally代码块执行\\n\");\n    }\n    return sb;\n}\npublic StringBuilder method2(Boolean flag) {\n    StringBuilder sb = new StringBuilder();\n    if (flag) {\n        System.exit(0);\n    }\n    try {\n\n    } catch (Exception e) {\n        System.out.println(\"进入try代码块\\n\");\n    } finally {\n        System.out.println(\"finally代码块执行\\n\");\n    }\n    return sb;\n}\n\n@Test\npublic void test1() {\n    method1(true);\n    method2(true);\n}\n```\n\n##### finally对return结果的影响\n\n> finally代码可能会对return的结果产生影响。\n>\n> 对于基本数据类型和一些不可变的引用类型return的结果不受finally的影响\n>\n> 对于可变的提供修改方法的引用类型，return的结果会受到finally的影响\n\n- 对于基本数据类型  和  一些不可变的比如说String\n\nfinally代码块执行但是不影响return的结果\n\n```java\npublic int method3() {\n    int i = 0;\n    try {\n        return i;\n    } finally {\n        System.out.println(\"finally代码块执行\");\n        i += 1;\n    }\n}\npublic String method4() {\n    String str = \"123\";\n    try {\n        return str;\n    } finally {\n        System.out.println(\"finally代码块执行\");\n        str += \"abc\";\n    }\n}\n@Test\npublic void test2() {\n    int i = method3();\n    System.out.println(\"method3返回结果：\" + i);\n\n    String str = method4();\n    System.out.println(\"method4返回结果：\" + str);\n}\n```\n\n![image-20220808130934740](java成神之路(基础).assets/image-20220808130934740.png)\n\n- 对于可修改的引用类型(比如说StringBuilder)\n\nfinally代码会执行且影响了返回的结果\n\n```java\npublic StringBuilder method5() {\n    StringBuilder sb = new StringBuilder(\"\");\n    try {\n        return sb.append(\"123\");\n    } finally {\n        System.out.println(\"finally代码块执行\");\n        sb.append(\"abc\");\n    }\n}\n\n@Test\npublic void test3() {\n    StringBuilder sb = method5();\n    System.out.println(\"method5返回结果：\" + sb.toString());\n}\n```\n\n![image-20220808131219548](java成神之路(基础).assets/image-20220808131219548.png)\n\n> 所以说我们可以得出一个结论：\n\nreturn会记住需要返回结果的字面量信息，对于基本数据类型来说就是值，对于引用类型来说就是引用地址的值。对于基本数据类型和不可变引用类型需要通过`=`等号赋值，那就直接修改了引用，而return所记住的引用指向的对象并没有被修改。那么对于可变引用类型来说，return所记住的引用指向的对象可以在finally中被修改。\n\n##### return和finally代码执行顺序\n\n> 其实在上一个例子中已经有结果了，我们可以发现返回的sb为 123abc。\n>\n> 所以说可以得出的结论是：\n>\n> return  的代码执行在finally代码块之前\n>\n> finally代码执行在return代码之后，在完全return之前\n\n\n\n<hr>\n\n### 集合\n\n> 集合相关简单关系如下图，没有列出所有的集合类\n\n![image-20220809103023147](java成神之路(基础).assets/image-20220809103023147.png)\n\n\n\n#### Iterable\n\n- `Iterable`接口提供了一个获取迭代器的抽象方法，各种集合类去实现它，返回各自需要的迭代器`Iterator`。这些迭代器一般作为各种集合的内部类。\n\n- 一个遍历方法  foreach(Consumer action)。各个集合实现\n- 一个获取分离迭代器的方法。①可以split集合，用于可能并行操作的场景。②遍历\n\n以ArrayList为例：\n\n```JAVA\n@Test\npublic void test1() {\n    List<String> list = new ArrayList<>(Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\"));\n\n    list.forEach(System.out::print);\n    System.out.println(\"        foreach\");\n\n    Spliterator<String> spliterator = list.spliterator().trySplit();\n    spliterator.forEachRemaining(System.out::print);\n    System.out.println(\"        spliterator   forEachRemaining\");\n\n    Spliterator<String> spliterator1 = list.spliterator();\n    while (spliterator1.tryAdvance(System.out::print)) ;\n    System.out.println(\"         spliterator   tryAdvance\");\n}\n```\n\n![image-20220809125359887](java成神之路(基础).assets/image-20220809125359887.png)\n\n使用trySplit方法将集合分割为多个小集合：每一次trySplit都会跟新 Spliterator的index属性\n\n```java\npublic void test3() {\n    List<String> list = new ArrayList<>(Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\"));\n    Spliterator<String> spliterator = list.spliterator();\n\n    Spliterator<String> spliteratorTemp = null;\n    while (null != (spliteratorTemp = spliterator.trySplit())) {\n        spliteratorTemp.forEachRemaining(System.out::print);\n        System.out.println();\n    }\n    spliterator.forEachRemaining(System.out::print);\n}\n```\n\n![image-20220809145504844](java成神之路(基础).assets/image-20220809145504844.png)\n\n#### collection\n\n> Collection接口中除了一些关于集合状态的方法合一些对集合操作的方法外，还有两个获取流的方法\n\n<img src=\"java成神之路(基础).assets/image-20220809150217164.png\" alt=\"image-20220809150217164\" style=\"zoom:50%;\" />\n\n##### 使用stream来对集合进行操作\n\n```java\n@Test\npublic void test1() {\n    System.out.println(\"===============流  转集合===============\");\n    List<String> list = new ArrayList<>(Arrays.asList(\"1\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"));\n    List<String> collect1 = list.stream().collect(Collectors.toList());\n    collect1.stream().forEach(System.out::print);\n    System.out.println();\n\n    System.out.println(\"===============遍历===============\");\n    list.stream().forEach(System.out::print);\n    System.out.println();\n\n    System.out.println(\"===============过滤===============\");\n    List<String> collect2 = list.stream().filter((ele) -> ele.equals(\"2\")).collect(Collectors.toList());\n    collect2.stream().forEach(System.out::print);\n    System.out.println();\n\n    System.out.println(\"===============映射===============\");\n    List<Integer> collect3 = list.stream().map(Integer::valueOf).collect(Collectors.toList());\n    collect3.stream().forEach(System.out::print);\n    System.out.println();\n\n    System.out.println(\"===============求和 求平均值===============\");\n    int sum = list.stream().mapToInt(Integer::valueOf).sum();\n    System.out.println(sum);\n\n    System.out.println(\"===============去重===============\");\n    List<String> collect4 = list.stream().distinct().collect(Collectors.toList());\n    collect4.stream().forEach(System.out::print);\n    System.out.println();\n\n    System.out.println(\"===============判断===============\");\n    final boolean b1 = list.stream().allMatch(ele -> \"2\".equals(ele));\n    final boolean b2 = list.stream().anyMatch(ele -> \"2\".equals(ele));\n    System.out.println(b1 + \" \" + b2);\n    System.out.println();\n\n    System.out.println(\"===============获取option===============\");\n    String s1 = list.stream().findAny().get();\n    String s2 = list.stream().findFirst().get();\n    System.out.println(s1 + \" \" + s2);\n    System.out.println();\n\n    System.out.println(\"===============对每一个元素进行操作===============\");\n    List<String> collect5 = list.stream().peek(ele -> {\n      if (ele.equals(\"2\")){\n          System.out.println(\"xxxx\");\n      }\n    }).collect(Collectors.toList());\n    collect5.stream().forEach(System.out::print);\n    System.out.println();\n\n}\n```\n\n\n\n#### Collectors\n\n> `Collectors`构造器私有化且未提供获取实例的方法，那么此类无法实例化。这是一个工具类，可以加快我们处理集合的效率。\n\n我们经常需要将一个处理过的Stream转化为集合类，需要调用collect()方法，此方法需要一个参数：Collector，实现Collector接口还是很麻烦的，所以Collectors提供了许多静态方法，给我们构建需要的Collector。\n\n+++以下例子基于着两个集合：\n\n```java\nfinal List<String> list1 = Arrays.asList(\"a\", \"ab\", \"abc\", \"abcd\", \"abcd\");\nfinal List<String> list2 = Arrays.asList(\"1\", \"12\", \"123\", \"1234\", \"1234\");\n```\n\n##### toList\n\n> `Collector.toList`方法，查看源码发现，默认转化为ArrayList。\n\n```java\nList<String> collect1 = list1.stream().filter(\"a\"::equals).collect(Collectors.toList());\n```\n\n##### toSet\n\n> `Collector.toSet`方法，查看源码发现，默认转化为HashSet。  转化为元素不重复集合\n\n```java\nfinal Set<String> collect2 = list1.stream().collect(Collectors.toSet());\n```\n\n##### toCollection\n\n> 以上的`toList、toSet`方法转化的是特定的集合，那么如果有特殊需求需要转化为自定义集合的话就需要使用`toCollection`方法。\n\n查看源码发现就是自定义集合类型：\n\n```java\nfinal LinkedList<String> collect3 = list1.stream().collect(Collectors.toCollection(() -> new LinkedList<>()));\n//lambda表达式写法\nfinal LinkedList<String> collect4 = list1.stream().collect(Collectors.toCollection(LinkedList::new));\n```\n\n##### toMap\n\n> 将集合元素转化为map，默认HashMap。`Collectors.toMap()`方法需要两个参数：keyMapper和valueMapper，两个参数都是`Function`接口的实现类，参数是集合元素，返回结果是对应key  value。\n\n```java\nfinal Map<String, Integer> map1 = list1.stream().collect(Collectors.toMap(String::toString, String::length));\n```\n\n> 如果转化后的map的key存在重复元素，会报`java.lang.IllegalStateException`异常。需要我们主动合并。也就是`Collectors.toMap`的几个重载\n\n这个合并的大致思路就是，会将存在重复记录的map节点提出来，然后重复记录的key对应的了两个value作为BinaryOperator接口的参数，返回结果类型和两个参数类型都一样。\n\n比如：上面的集合转化成map{ab=2, a=1, abc=3, abcd=4,abcd=4},这个map是存在key重复记录的，是不允许的，那么需要将这个map分为两个map1{ab=2, a=1, abc=3, abcd=4},map2{abcd=4}。然后将两个map对应key重复的记录的value提出来作为BinaryOperator接口apply(T t,T u)的参数，我们这里做一个相加，即apply(4,4) return 4 + 4;。那么最终的结果为 map{ab=2, a=1, abc=3, abcd=8}。\n\n```java\ntoMap(Function<? super T, ? extends K> keyMapper,\n                                Function<? super T, ? extends U> valueMapper,\n                                BinaryOperator<U> mergeFunction)\n```\n\n```java\nfinal Map<String, Integer> map2 = list1.stream().collect(Collectors.toMap(String::toString, String::length, Integer::sum));\nSystem.out.println(map2);\n```\n\n> 还有一个重载，可以自定义map\n\n```java\nfinal Map<String, Integer> map3 = list1.stream().collect(Collectors.toMap(String::toString, String::length, Integer::sum, LinkedHashMap::new));\n```\n\n##### collectingAndThen()\n\n> 此方法允许我们对转化后的集合再做一次操作\n\n这里的第二个参数，是一个函数式接口实现类，需要注意 第一个泛型 R是第一步流转集合的结果，也是函数式接口Function的apply(T t)方法的参数，第二个参数RR为apply(T t)方法返回结果，也是最终需要返回的结果，可以是任意的。这里返回集合\n\n```java\nFunction<R,RR> finisher\n```\n\n```java\nfinal List<String> collect5 = list1.stream().collect(Collectors.collectingAndThen(Collectors.toList(),\n        (list -> list.stream().filter(\"abc\"::contains).collect(Collectors.toList()))));\ncollect5.forEach(System.out::println);\n```\n\n\n\n##### joining\n\n> 将集合内元素拼接成字符串\n\n参数说明：\n\n第一个参数：分割符号\n\n第二个参数：返回结果字符串前缀\n\n第三个参数：返回结果字符串后缀\n\n```java\nfinal String joinResult = list1.stream().collect(Collectors.joining(\",\", \"<\", \">\"));\nSystem.out.println(joinResult);\n```\n\n\n\n##### counting\n\n> 统计个数\n\n```java\nfinal Long size = list1.stream().collect(Collectors.counting());\nSystem.out.println(size);\n```\n\n\n\n##### summarizingDouble/Long/Int()\n\n> 做统计\n\n这里对集合内字符串长度做统计，得出合、最大、最小值\n\n```java\nfinal IntSummaryStatistics intSummaryStatistics = list1.stream().collect(Collectors.summarizingInt(String::length));\nSystem.out.println(intSummaryStatistics.getSum());\nSystem.out.println(intSummaryStatistics.getMax());\nSystem.out.println(intSummaryStatistics.getMin());\n```\n\n\n\n##### groupBy\n\n> 以一定条件分组，这里以字符串长度分组\n\n```java\n//分组\nfinal Map<Integer, List<String>> map = list1.stream().collect(Collectors.groupingBy(String::length, Collectors.toList()));\nSystem.out.println(map);\n```\n\n##### partitioningBy\n\n> 特殊的分组，将集合分为两组，key值为boolean\n\n```java\n//特殊分组，以boolean作为map的key\nfinal Map<Boolean, List<String>> map1 = list1.stream().collect(Collectors.partitioningBy(ele -> ele.length() > 2\n));\nSystem.out.println(map1);\n```\n\n\n\n#### Set  &  List\n\n> `Set`和`List`接口都是`Collection`接口的子接口，用于存储同一类型的元素。\n\nList：元素按顺序插入，可重复\n\nSet：元素插入无序，不可重复。Set的实现由HashSet、TreeSet，虽然set插入无序但是TreeSet底层原理是红黑树，元素整体上大小有序。\n\n\n\n####  ArrayList  &  LinkedList  & Vector\n\n> 这三个类都是`List`的实现类。\n\n##### ArrayList\n\n> `ArrayList`底层是一个可边长数组，数据连续，当容量补不足的时候会进行扩容，扩1.5倍，使用Sysytem.arrayCopy()进行浅拷贝。\n>\n> ArrayList实现了`RandomAccess`接口，表明支持随机访问，搜索效率高。\n>\n> `elementData`使用`transient`修饰，优化序列化传输和存储\n>\n> 如果说在使用ArrayList之前知道需要存入集合的元素大致个数，可以一次性将集合扩容足`ensureCapacity(int minCapacity) `,避免频繁扩容导致降低集合效率。\n\n重要属性：\n\n- elementData 存放元素的数组\n- size    集合大小（元素个数）\n\n```java\ntransient Object[] elementData;\nprivate int size;\nprivate static final int DEFAULT_CAPACITY = 10;\n//private static final Object[] EMPTY_ELEMENTDATA = {};\n//private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n```\n\n\n\n######  优缺点\n\n优点：\n\n- 搜索效率高\n- 优化了序列话传输和序列化存储。（重写了WriteObject和ReadObject方法，不对null元素序列化传输）\n\n缺点：\n\n- 对插入不友好\n\n插入默认尾插法：如果插入时容量足够，直接在对应位置赋值即可，但是容量如果不足的化，首先需要扩容，扩容时就必须涉及数组的拷贝，效率自然受影响。\n\n如果说插入位置是程序员指定的，那么需要将该位置及其之后的元素都后移一位，然后再赋值，效率也会受影响。\n\n\n\n##### LinkedList\n\n> `LinkedList`除了实现了`List`接口，还实现了`Deque`接口，实现了`offer\\peek\\poll`等方法，对集合的操作更加灵活。\n>\n> `LinkedList`底层是一个双向链表，数据不连续，没有容量限制。\n>\n> 对插入友好，对访问不友好。`LinkedList`不支持随机访问。\n>\n> 链表的访问效率地下，特别的：如果我们每次访问的元素在链表尾部的时候，那么每次遍历都几乎需要循环整个链表。\n\n重要属性:\n\n- size  集合大小\n- first    头节点\n- last    尾节点\n\n```java\ntransient int size = 0;\ntransient Node<E> first;\ntransient Node<E> last;\n```\n\n###### 优缺点\n\n优点：\n\n- 没有容量限制，添加元素无需考虑扩容，且添加元素只需要修改引用，效率较高\n\n缺点：\n\n- 访问效率低下\n\n##### Vector\n\n> `Vector`的实现和`ArrayList`基本相同，主要存在如下不同处:\n\n- Vector  属于强同步类，而ArrayList非同步类\n- Vector默认每次扩容两倍，ArrayList扩容1.5倍\n- Arraylist对序列话传输和存储做了优化，而Vector没有\n\n> Vector关于扩容\n\n容量增长步数`capacityIncrement`如果不设置，默认每次扩两倍，如果设置，每次扩容capacityIncrement。\n\n```java\n//容量增长步数\nprotected int capacityIncrement;\n//扩容关键代码\nint newCapacity = oldCapacity + ((capacityIncrement > 0) ?\n                                 capacityIncrement : oldCapacity);\n```\n\n\n\n#### Collections\n\n> `Collections`的构造函数私有化被`private`修饰，不可实例化，除了构造方法外，存在很多被`static`修饰的静态方法，目的在于对集合进行操作。\n\n- 排序\n\n  > 调用的就是List的sort方法\n\n  ```java\n  //必须是Comparable的子类\n  void sort(List<T> list);\n  //可自定义比较器\n  void sort(List<T> list, Comparator<? super T> c);\n  ```\n\n- 搜索\n\n  > 二分查找。如果支持随机访问且集合不是很大，调用indexedBinarySearch方法，否则调用iteratorBinarySearch方法。\n\n  ```java\n  binarySearch(List<? extends Comparable<? super T>> list, T key);\n  binarySearch(List<? extends T> list, T key, Comparator<? super T> c);\n  ```\n\n  > 返回指定集合，指定元素的出现次数\n\n  ```java\n  static int frequency(Collection<?> c, Object o);\n  ```\n\n  > 返回目标集合在源集合中首次出现的下标。\n  >\n  > 返回目标集合在源集合中首次出现的下标。\n  >\n  > 没有则返回-1\n\n  ```java\n  public static int indexOfSubList(List<?> source, List<?> target) ;\n  public static int lastIndexOfSubList(List<?> source, List<?> target);\n  ```\n\n- 复制集合\n\n  > 将源集合复制到目标集合中\n\n  ```java\n  public static <T> void copy(List<? super T> dest, List<? extends T> src);\n  ```\n\n- 反转\n\n  > 将集合元素反转\n\n  ```java\n  void reverse(List<?> list);\n  ```\n\n  \n\n- 洗牌\n\n  > 打乱现有元素顺序，达到`洗牌`效果\n\n  ```java\n  void shuffle(List<?> list, Random rnd);\n  void shuffle(List<?> list)\n  ```\n\n- 交换\n\n  > 这个方法在reverse中也可能会使用到\n\n  ```java\n  swap(List<?> list, int i, int j);\n  ```\n\n- 填充\n\n  > 填充集合。以某个对象替换集合中的所有元素\n\n  ```java\n  void fill(List<? super T> list, T obj);\n  ```\n\n- 拷贝\n\n  > 将源集合中的元素拷贝到目标集合。`src`是源集合，`dest`是目标集合。\n  >\n  > 目标集合的`size`需要大于等于源集合，否则会报出`IndexOutofBoundsException`异常。\n  >\n  > 拷贝过后目标集合和源集合共享集合内的元素\n\n  ```java\n  void copy(List<? super T> dest, List<? extends T> src)\n  ```\n\n  ```java\n  @Test\n  public void test1() {\n      final StringBuffer sb1 = new StringBuffer(\"a\");\n      final StringBuffer sb2 = new StringBuffer(\"b\");\n      final StringBuffer sb3 = new StringBuffer(\"c\");\n      final StringBuffer sb4 = new StringBuffer(\"d\");\n      final StringBuffer sb5 = new StringBuffer(\"e\");\n      final StringBuffer sb6 = new StringBuffer(\"f\");\n      final List<StringBuffer> sbSource = Arrays.asList(sb1, sb2, sb3, sb4, sb5);\n      final List<StringBuffer> sbTarget = Arrays.asList(sb6, sb6, sb6, sb6, sb6, sb6);\n      Collections.copy(sbTarget, sbSource);\n      sb1.append(\"|update|\");\n  \n      sbTarget.forEach(System.out::print);\n  }\n  ```\n\n- 最大值最小值\n\n  > 获取一个集合的极值，如果元素未实现Comparable接口，需要自定义Comparator。\n\n  ```java\n  <T extends Object & Comparable<? super T>> T min(Collection<? extends T> coll);\n  <T> T min(Collection<? extends T> coll, Comparator<? super T> comp);\n  <T extends Object & Comparable<? super T>> T max(Collection<? extends T> coll);\n  <T> T max(Collection<? extends T> coll, Comparator<? super T> comp);\n  ```\n\n- 集合旋转特定距离\n\n  > 什么意思？相当于集合右移  distance % size()。右边被挤出来的元素添加到集合头部。\n  >\n  > 如果`distance`为正数，整体右移，负数整体左移。\n\n  比如：\n\n  ```java\n  @Test\n  public void test1(){\n      List<Integer> integers = Arrays.asList(0,1, 2, 3, 4, 5, 6, 7, 8, 9);\n      Collections.rotate(integers,5);\n      integers.stream().forEach(System.out::print);\n  }\n  ```\n\n  ![image-20220811130849708](java成神之路(基础).assets/image-20220811130849708.png)\n\n  ```java\n  public static void rotate(List<?> list, int distance);\n  ```\n\n- 转化集合\n\n  > 注意转化为不可变集合后，源集合任然可以进行修改操作并且可以直接影响到,不可变集合的不可变性。因为`Collections`转化不可变集合的操作是将源集合作为转换后不可变集合的属性。\n\n  ```java\n  //将目标集合转化成不可变集合，如果调用修改Api则会报出UnsupportedOperationException异常\n  public static <T> Collection<T> unmodifiableCollection(Collection<? extends T> c);\n  public static <K,V> Map<K,V> unmodifiableMap(Map<? extends K, ? extends V> m);\n  //转化为受检查的集合  在添加时会Class.isInstance(o)判断\n  <E> Collection<E> checkedCollection(Collection<E> c,Class<E> type);\n  //转化为同步集合\n  synchronizedCollection(Collection<T> c);\n  ```\n\n- 创建集合\n\n  > 返回的集合类型没有实现add等添加方法，如果做添加元素操作，会报出`UnsupportedOperationException`异常\n\n  ```java\n  //创建只有一个元素的集合\n  public static <T> Set<T> singleton(T o);\n  ```\n\n  > 返回空集合,返回的集合类型没有实现add等添加方法，如果做添加元素操作，会报出`UnsupportedOperationException`异常\n\n  ```java\n   <T> Set<T> emptySet();\n  ```\n\n  > 生成只有一个元素的集合，该集合不可变\n\n  ```java\n  //set\n  <T> Set<T> singleton(T o);\n  <T> List<T> singletonList(T o);\n  <K,V> Map<K,V> singletonMap(K key, V value);\n  ```\n\n  > 生成一个由指定对象的 n 个副本组成的不可变列表\n\n  ```java\n  //n拷贝个数      o 集合元素\n  <T> List<T> nCopies(int n, T o);\n  ```\n\n  > 生成一个线程安全的集合\n  \n  `Collections.SynchronizedCollection`和`Vector`的区别：\n  \n  ①两者实现同步的关键就在于使用`Synchronized`关键字实现，而`Vector`大部分代码使用的是同步方法，也就是锁的`this`。而`Collections.SynchronizedCollection`可以指定锁的对象`mutex`，如果不传默认锁的还是`this`。\n  \n  ②`Vector`的底层是一个对象数组，在其构造函数的重载中，可以直接将一个`Collection`转化为`Vector`，但是如果被转化的集合是一个`LinkedList`的时候，需要改变其底层数据结构，也就是需要调用`toArray()`方法，将链表转化为数组。而`Collections.SynchronizedCollection`是不需要改变集合底层结构的，同样的被转化的集合作为`Collections.SynchronizedCollection`的内部属性。\n  \n  ```java\n  <T> Collection<T> synchronizedCollection(Collection<T> c);\n  //mutex 作为对象监视器。如果主动设置，则锁的是mutex。否则默认锁的this(这也是和Vector的区别)\n  <T> Collection<T> synchronizedCollection(Collection<T> c, Object mutex);\n  ```\n  \n  \n\n#### Set如何保证元素不重复\n\n> `Set`的实现主要有两个，一个是`HashSet`，一个是`TreeSet`。特点是元素不重复\n\n- HashSet\n\n  `HashSet`基于`HashMap`实现，`HashMap`的`key`值不重复，`HashSet`的元素就是`HashMap`的key值。只能存在一个null元素（`hashMap`中，null的hash值为0）。\n\n  其判重方法是：首先使用`hash`值(散列值)判断，如果散列值不相等那么直接就不相等，如果散列值相等再使用`equals()`方法进行安全校验。原因在于：哈希值的比较效率高于对象的`equals()`方法。\n\n- TreeSet\n\n  `TreeSet`基于`TreeMap`实现，`TreeMap`底层是一颗红黑树(红黑树是对平衡二叉查找树的优化)。其内不可存储null元素(会报NPE异常)。\n\n  其判重方式是：①如果元素实现了`Comparable`接口，直接使用元素的`compareTo()`方法。②如果元素没有实现`Comparable`接口必须指定`Comparator`，调用`Comparator.compare()`方法。\n\n  都是子节点与父节点进行比较，比较结果小于0作为左孩子，大于0作为右孩子，等于0替换父节点value值。\n\n\n\n#### hashMap & hashTable\n\n> `HashTable`是一个较为古老的类，是一个线程安全的key - value键值对数据类型，其有一个`Property`子类，一般作为配置文件的工具类。\n>\n> `HashMap`可以认为是单线程环境下`HashTable`的替代品，其在避免哈希冲突、查找效率上都比`HashTable`要强。\n>\n> 一般情况下，`HashTable`已被弃用，单线程环境下使用`HashMap`，多线程环境需要保证线程安全的情况下使用`ConcurrentHashMap`。\n\n##### 区别\n\n- 线程安全\n\n  > `HashMap`非同步，多线程环境下需要同步，则使用`ConcurrentHashMap`。\n  >\n  > `HashTable`同步，使用`Synchronized`保证，同步方法，锁的是`this`。\n\n- 继承关系\n\n  > `HashMap`是`AbstractMap`的子类，并实现了`Map`接口。\n  >\n  > `HashTable`是`Dictionary`的子类(JDK1.0提出的)，并实现了`Map`接口。\n\n- 是否允许null值\n\n  > `HashMap`键和值都可以添加null值，null值作为键只能出现一次(hashMap的`hash()`方法，null对应的是0)，null值作为value可以出现多次(即多个键值对应value都是null)。\n  >\n  > `HashTable`键和值都可以不可以为null值，在`put`的时候，会对值进行空校验，会调用键的`hashCode()`方法。\n\n- 容量Capacity & 扩容机制\n\n  > `HashMap`容量默认`1<<4`(16)，每次扩容2倍，为2^n^。\n  >\n  > `HashTable`容量默认11，每次扩容2n+1。\n\n- hash值\n\n  > `HashMap`对`key`值的`hashCode`进行了哈希扰动，有效的降低了`HashMap`的哈希冲突。\n  >\n  > `HashTable`直接使用的键的`hashCode`\n\n- 遍历方式\n\n  > `HashMap`的遍历可以通过获取`EntryIterator、ValueIterator、KeyIterator`这些迭代器来遍历。\n  >\n  > `HashTable`的遍历：对于`key 和  value`来说，可以通过`keys()和elementa()`方法获取`Enumeration`进行遍历，对于`Map.entry`可以获取`EntrySet`再进行遍历。\n  >\n  > Iterator支持fast - fail，而`Enumeration`不支持。\n\n##### hashTable相关算法\n\n> 先了解`hashTable`的相关算法，相比于`HashMap`容易理解，同时后续和`HashMap`比较着理解，可以感受`HashMap`设计的巧妙。\n\n> 底层是数组+单向链表\n\n- 如何确定元素散列下标\n\n> hashTable使用的元素的哈希值，通过取余的方式获取散列下标。关键代码如下\n\n哈希值和0x7FFFFFFF按位与，是为了防止负数的出现。和tab.length除取余得到的是 (0 -  tab.length)，随机散列到数组中。\n\n```java\nindex = (hash & 0x7FFFFFFF) % tab.length;\n```\n\n- 扩容（reHash）\n\n> 首先了解两个属性`loadFactor`和`threadshold`分别为加载因子和临界值。加载因子默认为0.75，算上哈希冲突，所以说hashmap的存储效率一般不会超过百分之五十。\n\n存在如下关系：\n$$\nthreadshold = table.length * loadFactor\n$$\n\n\n> 扩容的目的是为了避免频繁哈希冲突，扩容的时机是当集合元素个数`count`大于临界值`loadfactor`时，进行扩容，扩为2倍加一，`loadfactor`也随之修改。\n>\n> 扩容的方法是，数组容量扩充，新建一个扩充后长度的数组，将旧数组元素放入新创建的数组。\n\n- 序列化\n\n> 序列话传输的时候会剔除空节点，同时这也是必须的，因为`hashTable`不支持key  或  value中任意的null值。\n\n\n\n##### hashMap相关算法\n\n> `hashMap`底层是数组 + 单向链表 + 红黑树\n>\n> `hashMap`是对单线程下`hashTable`的优化。\n>\n> 主要通过  ①位运算  ②截断链表 ③转换红黑树   进行优化\n\n- hashMap的capacity\n\n> `HashMap`的容量为 2^n^。\n\n通过一系列的移位运算和或运算找到任意数离其最近大于它的2^n^值，比如  5 ---> 8   、 11 -->  16、33 ---> 64。\n\n基本思想就是：\n\n5 的二进制表示为 0101，将高位第一位不为0的及所有低位置为1，即  0111，转换后加一，即 1000   => 8\n\n11的二进制表示为 1011，将高位第一位不为0的及所有低位置为1，即  1111，转换后加一，即 0001 0000   => 16\n\n- 如何确定散列下标\n\n> 前提是：`HashMap`的容量为2^n^。散列下标为哈希值和table.length - 1按位与\n\n`hashTable`是通过除取余的方式，同样的`hashMap`也是，也可以通过除取余的方式。\n\n但是当数组的长度为2^n^时候，除取余  =  hash()  &  table.length - 1。\n\n- hashMap的扰动函数\n\n> `hashTable`对key值的哈希值没做任何处理，会出现一个问题，就是如果key的哈希算法很糟糕的话，会很频繁的出现哈希冲突，通过拉链法解决冲突的话，链表将会拉的很长，且`hashTable`没有截断链表和转化红黑树的操作，如此查询效率将会降低。\n>\n> 所以针对如上`hashMap`做了优化，可以理解为`hashMap`不信任我们写的哈希算法，它自己会做一层处理，基本思想是将高16位和低16位进行按位异或(哈希值是int类型32位)，如此低16位既代表了整个哈希值的特征，在使用扰动后的哈希值来确定散列下标，可有效降低哈希冲突。\n\n- 扩容\n\n> hashMap的扩容方法是`reSize()`，扩容为2倍。\n>\n> 此方法不仅仅只做了扩容操作，它还会将链表缩短(缩短一倍)，比如在原数组(数组长度为len)下标j处有一个链表长度为5，经resize方法后，会将此链表拆为两份，分别为长度为2和长度为3的链表，分别放在 新数组(2 + len)j处和len + j处。\n\n- 转化红黑树\n\n> 当哈希表的链表过长会影响到查询的效率，所以需要转化为红黑树，利用红黑树的有序性质，可以使得查询效率逼近二分查找。\n\n转化红黑树的条件是：当链表长度等于8且table节点数组长度大于等于64\n\n如果不满足table节点数组长度大于64的话，会进行扩容处理，因为扩容存在缩短链表的操作。\n\n##### loadfactory\n\n> 加载因子为何默认为0.75，在hashMap中容量为2^n^，乘3/4刚好没有小数位\n\n\n\n##### 尽量设置初始容量\n\n> 在创建hashMap的时候建议一次性申请足够多的容量，避免频繁扩容，因为每次扩容都需要重建hash表。\n\n那么初始容量设置多少合适呢？\n\n需要考虑装载因子，hashMap的有效容量为实际容量的0.75，所以设置初始化容量的时候申请大小需要大于实际需要大小。 \n\n在hashMap的putall()方法中就有类型实现：\n\n```java\n//s 为需要容量大小， ft为实际申请容量大小\nfloat ft = ((float)s / loadFactor) + 1.0F;\n```\n\n在guaua包下也有类型实现：\n\n```java\npublic static <K extends @Nullable Object, V extends @Nullable Object>\n    HashMap<K, V> newHashMapWithExpectedSize(int expectedSize) {\n  return new HashMap<>(capacity(expectedSize));\n}\nstatic int capacity(int expectedSize) {\n    if (expectedSize < 3) {\n      checkNonnegative(expectedSize, \"expectedSize\");\n      return expectedSize + 1;\n    }\n    if (expectedSize < Ints.MAX_POWER_OF_TWO) {\n      // This is the calculation used in JDK8 to resize when a putAll\n      // happens; it seems to be the most conservative calculation we\n      // can make.  0.75 is the default load factor.\n      return (int) ((float) expectedSize / 0.75F + 1.0F);\n    }\n    return Integer.MAX_VALUE; // any large value\n}\n```\n\n#### Stream\n\n> 可以使用`Stream`来处理集合，结合`Lambda`表达式和函数式编程可以编写出简洁、高效的代码\n\n##### 特点\n\n- 无存储\n\n  > `Stream`不是一种数据结构，它并不存储数据，它只是数据源的一个视图(操作集合的说明书)，数据源可以是一个集合或数组。\n\n- 简洁\n\n  > `Stream`的特性就是为函数式编程而生，结合函数式编程可以编写出简洁高效的代码。\n\n- 惰式执行\n\n  > `Stream`上的操作不会立刻执行，而是在被消费的时候才会真正执行\n\n- 可消费性\n\n  > `Stream`可被消费，且只能被消费一次。一旦遍历过就会失效。想要在此操作必须重写生成流。\n\n  > 如下test2方法stringStream已被遍历过，再次对其操作会报出`java.lang.IllegalStateException: stream has already been operated upon or closed`错误。\n  >\n  > 必须如test3生成新的流。\n\n```java\n@Test\npublic void test2() {\n    final Stream<String> stringStream = Stream.of(\"1\", \"2\", \"3\");\n    stringStream.filter(\"2\"::equals);\n    stringStream.forEach(System.out::println);\n}\n@Test\npublic void test3() {\n    final Stream<String> stringStream = Stream.of(\"1\", \"2\", \"3\");\n    final Stream<String> stringStreamFilter = stringStream.filter(\"2\"::equals);\n    stringStreamFilter.forEach(System.out::println);\n}\n```\n\n\n\n##### Stream操作\n\n> 对于`Stream`流的处理主要有三种关键性操作：创建流、中间操作、最终操作\n\n###### 创建流\n\n- 通过集合类的stream方法创建流\n- 使用Stream.of(T t)创建流\n- 使用Arrays.stream(T[] t)创建流 。 Stream.of(T ...t)底层就是使用此方式\n\n```java\n//通过集合类创建流\nfinal Collection<String> strings = Arrays.asList(\"1\", \"2\", \"3\");\nfinal Stream<String> stream = strings.stream();\n\n//Stream创建流\nfinal Stream<String> stringStream = Stream.of(\"1\", \"2\", \"3\");\nfinal Stream<String> a = Stream.of(\"a\");\n\n//Arrays.stream(T[] t)\nfinal Stream<String> stream1 = Arrays.stream(new String[]{\"1\", \"2\", \"3\"});\n```\n\n\n\n###### 中间操作\n\n> 对`Stream`做处理，包括过滤、映射、排序等\n\n| 操作(Stream opration) | 说明                         | 参数                                    |\n| --------------------- | ---------------------------- | --------------------------------------- |\n| filter                | 过滤                         | Predicate<? super T> predicate          |\n| map                   | 映射                         | Function<? super T, ? extends R> mapper |\n| limit、skip           | 限制                         | long maxSize                            |\n| sorted                | 自然排序或指定比较器         | Comparator<? super T> comparator        |\n| distinct              | 使用元素的equals去除重复元素 |                                         |\n|                       |                              |                                         |\n\n\n\n###### 最终操作\n\n> `Stream`是集合或容器的视图，是对集合或容器的操作描述，但是如果我们想要得到结果的话，就需要使用最终操作来将流转化为我们想要的结果。遍历、统计(个数)、转化集合等。\n\n| 操作    | 说明     | 参数                                 |\n| ------- | -------- | ------------------------------------ |\n| foreach | 遍历     | Consumer<? super T> action           |\n| count   | 计数     |                                      |\n| Collect | 转化集合 | Collector<? super T, A, R> collector |\n\n##### Stream转化\n\n> Stream转化为IntStream、LongStream。。。。\n\n```java\nfinal IntStream intStream = stream.mapToInt(StringBuffer::length);\nfinal DoubleStream doubleStream = stream.mapToDouble(StringBuffer::length);\nfinal LongStream longStream = stream.mapToLong(StringBuffer::length);\n```\n\n\n\n#### 集合工具类\n\n> 许多开源机构为我们提供了操作集合的工具类。\n\n##### apache\n\n> Apache.commons下的commons-collectionsX包对java集合框架(java collection framework)做扩展。\n\n![image-20220818094842448](java成神之路(基础).assets/image-20220818094842448.png)\n\n- Bag -  简化了一个对象在集合中存在多个副本的操作\n- BidiMap -  提供双向映射，可通过键查找值，也可以通过值查找键\n- Iterators - 方便迭代\n- Transforming Decorators   在添加元素时，修改集合元素\n- CompositeCollection  需要统一处理多个集合时可用\n\n###### Bag\n\n> `Bag`简化了一个对象存在多个副本的操作。\n\nHashBag  & TreeBag\n\n> hashBag & TreeBag的继承关系如下图所示：\n>\n> TreeBag 相较于HashBag多实现一个接口 ： SortedBag即表现为一个有序的bag。\n>\n> HashBag其内封装了一个HashMap，key是元素，value是元素个数。\n>\n> TreeMap其内封装了一个TreeMap，key是元素，value是元素个数。\n\n![image-20220818151047171](java成神之路(基础).assets/image-20220818151047171.png)\n\n\n\n> hashBag&TreeBag的创建。\n\n```java\npublic HashBag() {\n    super(new HashMap<E, MutableInteger>());\n}\npublic HashBag(final Collection<? extends E> coll) {\n    this();\n    addAll(coll);\n}\n\nprivate transient Map<E, MutableInteger> map;\nprotected AbstractMapBag(final Map<E, MutableInteger> map) {\n    super();\n    this.map = map;\n}\n```\n\n> hashBag&TreeBag基本使用\n\n```java\n/**\n * hashBag底层是一个hashMap 元素是key值，添加个数是value\n * 可以通过add(object,nCopies)方法为每个元素添加n个副本\n * 如果add两次则会跟新value值（加一）\n */\nStringBuilder sb1 = new StringBuilder(\"a\");\nStringBuilder sb2 = new StringBuilder(\"b\");\nStringBuilder sb3 = new StringBuilder(\"c\");\nBag<Object> hashBag = new HashBag<>();\n\nhashBag.add(sb1);\nhashBag.add(sb1);\nhashBag.add(sb2, 3);\nhashBag.add(sb3, 3);\nSystem.out.println(\"Bag+元素个数:\" + hashBag.size());\nSystem.out.println(\"Bag中sb1个数:\" + hashBag.getCount(sb1));\nString result1 = hashBag.stream().map(Object::toString).collect(Collectors.joining(\",\", \"[\", \"]\"));\nSystem.out.println(\"HashBag 内容：\" + result1);\n//可以使用Collection作为构造方法参数\nBag<Object> hashBag2 = new HashBag<>(Arrays.asList(\"1\", \"2\", \"3\"));\nString result3 = hashBag2.stream().map(Object::toString).collect(Collectors.joining(\",\", \"[\", \"]\"));\nSystem.out.println(\"hashBag2 内容：\" + result3);\n\n/**\n * TreeBag：底层封装了一个TreeMap。\n * 其实可依发现HashBag中的元素是无序的，那么TreeBag就是一个有序的Bag\n */\nTreeBag<String> treeBag = new TreeBag<>(Arrays.asList(\"99\", \"2\", \"3\", \"7\"));\nString result2 = treeBag.stream().map(Object::toString).collect(Collectors.joining(\",\", \"[\", \"]\"));\nSystem.out.println(\"TreeBag 内容：\" + result2);\n```\n\n\n\nCollectionBag\n\n> `CollectionBag`没有无参构造，必须依赖一个`Bag`类型的参数。`CollectionBag`只是对`Bag`的封装，任何操作实际上操作的是封装的Bag。\n\n```java\n/**\n * CollectionBag的创建依赖于现有Bag，不可使用Collection作为构造方法参数\n *\n * 其内方法是对Bag的一层封装，实际调用的还是Bag的方法\n */\nBag<Object> collectionBag = CollectionBag.collectionBag(hashBag);\nString result4 = collectionBag.stream().map(Object::toString).collect(Collectors.joining(\",\", \"[\", \"]\"));\nSystem.out.println(\"CollectionBag的内容：\" + result4);\n\nBag<Object> collectionBag2 = CollectionBag.collectionBag(treeBag);\nString result5 = collectionBag2.stream().map(Object::toString).collect(Collectors.joining(\",\", \"[\", \"]\"));\nSystem.out.println(\"CollectionBag2的内容：\" + result5);\n```\n\n\n\nPredicatedBag & PredicatedSortedBag\n\n> `PredicatedBag`的构造器依赖一个现有Bag和一个`Predicate`，可以对加入进来的元素进行限制，比如不允许添加空元素。\n\n```java\n/**\n * 创建PredicatedBag也依赖一个现有Bag，以及一个‘判断器’\n */\nPredicatedBag<Object> predicatedBag = PredicatedBag.predicatedBag(collectionBag, Objects::nonNull);\nString result6 = predicatedBag.stream().map(Object::toString).collect(Collectors.joining(\",\", \"[\", \"]\"));\nSystem.out.println(\"predicatedBag的内容:\" + result6);\n```\n\n\n\nSynchronizedBag & SynchronizedSortedBag\n\n```java\n/**\n * SynchronizedBag同步的bag，使用Synchronized同步代码块实现同步。\n * 可以指定锁对象，如果不指定则锁this\n */\nSynchronizedBag<Object> synchronizedBag = SynchronizedBag.synchronizedBag(collectionBag);\nSynchronizedSortedBag<Object> synchronizedSortedBag = SynchronizedSortedBag.synchronizedSortedBag(treeBag);\n```\n\n\n\nTransformedBag\n\n> 对原集合进行转化，一般不会用这个，java8提供的`Stream API`有一个Map方法，可以将结果映射。\n\n- transformingBag 方法，只会对后面add进来的元素进行转换，而对之前的初始化的不会转化\n- transformedBag方法，会对后加的以及一开始初始化的都进行转化\n\n```java\n/**\n * TransformedBag\n */\nBag<Object> bag1 = TransformedBag.transformingBag(hashBag, Object::hashCode);\nbag1.add(\"XX\", 3);\nString result8 = bag1.stream().map(Objects::toString).collect(Collectors.joining(\",\", \"[\", \"]\"));\nSystem.out.println(\"TransformedBag.transformingBag \" + result8);\n\nBag<Object> bag2 = TransformedBag.transformedBag(hashBag, Object::hashCode);\nbag2.add(\"xx\",3);\nString result9 = bag2.stream().map(Objects::toString).collect(Collectors.joining(\",\", \"[\", \"]\"));\nSystem.out.println(\"TransformedBag.transformingBag \" + result9);\n```\n\n\n\nUnmodifiableBag\n\n> 不可修改的Bag。\n\n\n\nBagUtils\n\n> 协助生成bag，其实调用的就是`XXXBag.xxxBag()`方法，每一个Bag类都会有一个静态方法，用于生成Bag。\n\n```java\n/**\n * BagUtils  Bag工具类 协助生成Bag\n */\nfinal Bag<Object> bag = BagUtils.collectionBag(new HashBag<>());\n```\n\n###### BidiMap\n\n> BidiMap -  提供双向映射，可通过键查找值，也可以通过值查找键\n\nDualHashBidiMap\n\n> 双重hashMap。其内封装了两个hashMap，bidimap的put()方法中key-value有任意重复的此条记录会被覆盖\n\n```java\n/**\n * bidimap\n * - bidimap的put()方法中key-value有任意重复的此条记录会被覆盖\n */\n@Test\npublic void testBidiMap() {\n\n    final DualHashBidiMap<String, Integer> dualHashBidiMap = new DualHashBidiMap<>();\n    dualHashBidiMap.put(\"a\", 1);\n    dualHashBidiMap.put(\"b\", 2);\n    dualHashBidiMap.put(\"c\", 3);\n    dualHashBidiMap.put(\"d\", 3);\n    dualHashBidiMap.put(\"e\", 12);\n    dualHashBidiMap.put(\"e\", 123);\n\n    System.out.println(dualHashBidiMap.get(\"a\"));\n    System.out.println(dualHashBidiMap.getKey(1));\n    System.out.println(dualHashBidiMap.getKey(3));\n    System.out.println(dualHashBidiMap.values());\n    System.out.println(dualHashBidiMap.keySet());\n}\n```\n\n```bash\n1\na\nd\n[1, 2, 3, 123]\n[a, b, d, e]\n```\n\n\n\n###### iterators\n\n> `iterators`提供了许多迭代包装类使我们很容易迭代集合，并且支持逆向迭代\n\nArrayItertor\n\n> 数组迭代器，接收一个数组、迭代起始下标、迭代终止下标。\n\n> 只接受迭代数组，因为next()方法会调用，本地静态方法`Array.get(array,index)`\n\n```java\npublic static native Object get(Object array, int index)\n    throws IllegalArgumentException, ArrayIndexOutOfBoundsException;\n```\n\n> 简单使用\n\n```java\n /**\n * ArrayIterator 数组迭代器，接受一个数组、起始下标、终止下标\n */\nIterator<Object> arrayIterator1 = new ArrayIterator<>(Arrays.asList(\"1\", \"2\", \"3\").toArray(),0,2);\nwhile (arrayIterator1.hasNext()) {\n    System.out.println(arrayIterator1.next());\n}\n```\n\n\n\nArrayListIterator\n\n> 接收一个数组，起始下标，终止下标。\n>\n> 对`ArrayIterator`的拓展，支持正向迭代、也支持反向迭代。\n\n```java\n/**\n * ArrayListIterator \n * 支持正向迭代、逆向迭代\n */\nArrayListIterator<Object> arrayListIterator2 = new ArrayListIterator<>(Arrays.asList(\"1\", \"2\", \"3\",\"4\", \"5\", \"6\").toArray(), 2, 6);\nwhile (arrayListIterator2.hasNext()) {\n    System.out.println(arrayListIterator2.next());\n}\nwhile (arrayListIterator2.hasPrevious()) {\n    System.out.println(arrayListIterator2.previous());\n}\n```\n\n\n\nBoundedIterator\n\n> 有边界的迭代器，接收三个参数`Iterator`迭代器、`offeset`偏移量、`max`迭代数量。\n>\n> 如下表示从下标2开始、迭代2个元素，结果是 3、4\n\n```java\nList<String> list = Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\");\nBoundedIterator<String> boundedIterator = new BoundedIterator<>(list.iterator(), 2, 2);\nwhile (boundedIterator.hasNext()) {\n    System.out.println(boundedIterator.next());\n}\n```\n\nCollectionIterator\n\n```java\n//比较器，会影响迭代结果\nprivate Comparator<? super E> comparator = null;\n//迭代器\nprivate List<Iterator<? extends E>> iterators = null;\n//待比较的元素\nprivate List<E> values = null;\n//迭代器是否还有值\nprivate BitSet valueSet = null;\nprivate int lastReturned = -1;\n```\n\n```java\nCollatingIterator(final Comparator<? super E> comp, final Iterator<? extends E>[] iterators)\nCollatingIterator(final Comparator<? super E> comp, final Collection<Iterator<? extends E>> iterators)\n```\n\n> 接收一个或多个迭代器和一个比较器，迭代结果会按一定顺序输出(原集合元素顺序不变)。\n\n```java\nSystem.out.println(\"CollatingIterator\");\nList<String> list1 = Arrays.asList(\"5\", \"4\", \"1\", \"2\", \"3\");\nList<String> list2 = Arrays.asList(\"2\", \"1\", \"c\", \"d\", \"e\");\nCollatingIterator<String> collatingIterator = new CollatingIterator<>(String::compareTo, list1.iterator(), list2.iterator());\nwhile (collatingIterator.hasNext()) {\n    System.out.print(collatingIterator.next());\n}\n```\n\n输出：\n\n> [21]54123[cde]\n\nMapIterator\n\n> util包下的map的迭代，如果想迭代key或value，需要借助entry。\n\n```java\nSystem.out.println(\"MapIterator\");\nfinal HashMap<Object, Object> map = new HashMap<>(8);\nmap.put(\"1\", \"a\");\nmap.put(\"2\", \"b\");\nmap.put(\"3\", \"c\");\nmap.put(\"4\", \"d\");\nmap.put(\"5\", \"e\");\nmap.put(\"6\", \"f\");\nmap.put(\"7\", \"g\");\nmap.put(\"8\", \"h\");\n//entry迭代器\nfinal Iterator<Map.Entry<Object, Object>> iterator =\n        map.entrySet().iterator();\nwhile (iterator.hasNext()) {\n    final Map.Entry<Object, Object> next = iterator.next();\n    System.out.println(\"key值:\" + next.getKey() + \"value值:\" + next.getValue());\n}\n//key迭代器\nmap.keySet().iterator();\n//value迭代器\nmap.values().iterator();\nfinal HashedMap<Object, Object> hashedMap = new HashedMap<>(map);\nfinal MapIterator<Object, Object> hashedMapIterator = hashedMap.mapIterator();\nwhile (hashedMapIterator.hasNext()) {\n    System.out.println(hashedMapIterator.next());\n    System.out.println(\"key值:\" + hashedMapIterator.getKey() + \"value值:\" + hashedMapIterator.getValue());\n}\n```\n\n\n\n###### CollectionUtils\n\n> `cpache`的集合工具类，提供很多有用的方法，此工具类在java8之前很有用，但java8的Stream  api提供了类似功能，因此许多方法都可以用stream代替。\n\nignor  null\n\n添加元素时忽略null值\n\n```java\nfinal List<String> listX = new ArrayList<>(Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\"));\nfinal List<String> listY = new ArrayList<>(Arrays.asList(\"1\", \"2\", \"c\", \"b\", \"5\"));\nSystem.out.println(CollectionUtils.addIgnoreNull(listX, null));\nSystem.out.println(CollectionUtils.addIgnoreNull(listX, \"6\"));\n```\n\nmerge & sort\n\n> 合并排序，如果不指定比较器，则会自然排序，如果指定比较器则按指定比较器来排序\n\n```java\nSystem.out.println(\"merge  and  sort\");\nfinal List<String> collate1 = CollectionUtils.collate(listX, listY);\nSystem.out.println(collate1);\nfinal List<String> collate2 = CollectionUtils.collate(listX, listY, String::compareTo);\nSystem.out.println(collate2);\n```\n\n安全空检查\n\n> 很多时候对集合遍历的时候，需要对集合进行安全空检查，CollectionUtils为我们提供了一套方式\n\n```java\nSystem.out.println(\"安全空检查\");\nSystem.out.println(CollectionUtils.isEmpty(listX));\nSystem.out.println(CollectionUtils.isNotEmpty(listX));\n```\n\n交集  并集  外集\n\n```java\nSystem.out.println(\"交集\" + CollectionUtils.intersection(listX, listY));\nSystem.out.println(\"并集\" + CollectionUtils.union(listX, listY));\nSystem.out.println(\"外集\" + CollectionUtils.subtract(listX, listY));\n```\n\n\n\n###### 小结\n\n> java8的Stream可以适用于大部分的集合操作。\n\n交集 外集 并集\n\n```java\nfinal List<String> collect1 = listX.stream().filter(listY::contains).collect(Collectors.toList());\nSystem.out.println(\"交集\" + collect1);\nfinal List<String> collect2 = listX.stream().filter(ele -> !listY.contains(ele)).collect(Collectors.toList());\nSystem.out.println(\"外集\" + collect2);\n\nSystem.out.println(\"Stream 合并集合\");\nfinal ArrayList<List<String>> lists = new ArrayList<>();\nlists.add(listX);\nlists.add(listY);\nfinal List<Object> collect = lists.stream().flatMap(Collection::stream).collect(Collectors.toList());\nSystem.out.println(\"并集\"+collect);\n```\n\n其他的诸如过滤、排序、转换(映射)等Stream都可以\n\n\n\n#### Arrays.asList(T ...t)\n\n> 使用此方式创建集合需要注意什么？\n\n- 此方式创建的集合是Arrays的一个子类ArrayList，并未实现增删方法，不可对其进行==增删==操作。\n\n  会报出`java.lang.UnsupportedOperationException`\n\n- 可进行修改操作\n\n- 可将其作为参数，构造真正的ArrayList\n\n\n\n#### 集合中的fail -fast\n\n> fail- fast 快速失败，一种一旦检测出系统异常就会立刻上报的机制，此种机制可使系统避免在有安全隐患的情况下继续运行，常用的比如说参数校验。\n>\n> 看一下集合中的fail-fast机制：\n\n常常出现在迭代中，防止下标越界或迭代不完全，以arrayList为例\n\nexpectedModCount此属性在获取迭代器的时候会赋值为modCount，如果在迭代时我们通过修改集合改变modeCount则会报出此异常\n\n```java\nfinal void checkForComodification() {\n    if (modCount != expectedModCount)\n        throw new ConcurrentModificationException();\n}\n```\n\n> 对集合进行增删操作会触发fail-fast机制\n\n```java\nfinal List<String> list = new ArrayList<>(Arrays.asList(\"1\", \"2\", \"3\"));\nfinal Iterator<String> iterator = list.iterator();\nwhile (iterator.hasNext()) {\n  //list.remove(\"1\");\n  //list.add(\"1\");\n  iterator.next();\n}\n```\n\n> foreach也会触发fail-fast机制，因为其底层就是使用迭代器迭代的\n\n如果安装了阿里代码规约插件的话，那么已经帮你提示出来了\n\n```java\nfinal List<String> list = new ArrayList<>(Arrays.asList(\"1\", \"2\", \"3\"));\nfor (String s : list) {\n    list.add(\"a\");\n}\n```\n\n反编译看一下字节码\n\n![image-20220821180247553](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208211804530.png)\n\n\n\n####  集合中的fail - safe\n\n> 为了避免fail-fast机制，可以使用采用fail-safe机制的集合类，这样的类在对集合进行操作的时候不会直接操作集合内容，而是通过拷贝一份，在拷贝的内容上操作，最后需要同步更改，则同步更改。\n\n\n\n##### CopyOnWriteArrayList\n\n> 这就是一个fail-safe集合类。\n>\n> 其内部的add  、reomve、set等操作都使用ReentrantLock保证同步，任何操作都是在拷贝对象数组上进行，最后再替换原集合对象数组。\n\n> COW集合的迭代器:其内部包含了一个源集合对象数组的快照、副本、拷贝(snapshot)，任何迭代都是在此对象数组上完成的。并且由于COW在修改对象数组的时候，COW都会拷贝一份，所以并不会影响迭代器中的拷贝所指向的对象数组\n\n> 使用COW代替ArrayList就不会发生CME异常\n\n```java\nCopyOnWriteArrayList<String> cowList = new CopyOnWriteArrayList<>(Arrays.asList(\"1\",\"2\",\"3\"));\nfor (String s : cowList) {\n    if (\"1\".equals(s)){\n        cowList.remove(s);\n    }\n}\n```\n\n\n\n但是也造成了一个问题：我们对集合的修该，修改对象数组，是对迭代器不可见的，因为在集合修改的时候，会使用System.arrayCopy()方法生成一个新的对象数组。\n\n```java\nCopyOnWriteArrayList<String> cowList = new CopyOnWriteArrayList<>(Arrays.asList(\"1\",\"2\",\"3\"));\nIterator<String> iterator = cowList.iterator();\n//fail-sfae 集合修改\nfor (String s : cowList) {\n    if (\"1\".equals(s)){\n        cowList.remove(s);\n    }\n}\n//已经修改\nSystem.out.println(cowList);\n//但对迭代器不可见\nwhile (iterator.hasNext()) {\n    System.out.println(iterator.next());\n}\n```\n\n打印结果：\n\n```bash\n[2, 3]\n1\n2\n3\n```\n\n\n\n###### 特点\n\n- copy-on-write，写时复制，所有修改操作在快照上操作\n- 同步，使用ReenTrantLock\n- 写时加锁，避免拷贝出多个副本，导致并发写\n- 读时不加锁，读写分离。会导致弱一致性问题：读取的不是最新数据\n\n\n\n##### 循环中remove\n\n> fail-fast机制出现于迭代器中修改集合操作，触发fail-fast机制，导致并发异常。\n\n- forii   普通for循环\n- iterator  的remove方法  （主要思想就是在修改modCount的同时修改expectedModCount）\n- fail-safe集合（fail-safe集合的迭代器一般不支持remove方法，直接使用集合的remove方法）\n- 增强for：fail-fast机制在next方法中调用，在修改集合后避免使用next方法即可\n\n```java\nList<String> list = new ArrayList<>(Arrays.asList(\"1\",\"2\",\"3\"));\nfor (String s : list) {\n    if (\"1\".equals(s)){\n        list.remove(s);\n    }\n    break;\n}\nSystem.out.println(list);\n```\n\n\n\n### IO\n\n> 文件操作是编程一部分，学习一下IO流。\n\n####  字符流&字节流\n\n> 从名称来看区别在于流的传输方式：字节  or    字符。\n\n有了字节流为何还需要字符流？\n\n字符流可以认为是字节流＋编码方式。编码方式指导字节流如何处理字节，将其组合成字符。原因就在于方便操作，对于中文可能不同的编码方式得到的字节数据是不同的，那么使用字节流读取可能出现乱码的情况，那么有了字符流可以指定编码，指导字节流读几个字节作为一个汉字。\n\n\n\n##### 位、字节、字符\n\n- Bit   最小二进制单位，0或1.\n- Byte  字节，1 Byte = 8 Bit，取值 [-128,127]\n- Char 字符，1Char = 16Bit，人能直观认识的最小单位，取值 [0,2^16^-1]\n\n##### 字节流\n\n> 操作字节，用于读取单个字节或字节数组，直接对文件进行操作，无需缓冲区（读出来的数据直接就可以用）。\n>\n> 主要操作类是：InputStream和OutputStream的子类\n\nInputStream常用子类：\n\n- FileInputStream：文件输入流，用于读取文件信息到内存中。\n- ByteArrayInputStream：字节数组输入流\n- ObjectInputStream: 对象输入流\n- FilterInputStream  过滤流\n\n\n\nOutputStream常用子类：\n\n- FileOutputStram:文件输出流，用于将数据输出到文件中\n- ByteArrayOutputStream:字节数组输出流\n- ObjectOutputStream:对象输出流\n- FilterOutputStream  \n\n###### FileInputStream & FileOutputStream\n\n> 用于读取文件信息到内存和将内存中的数据输出到文件\n\n查看一下FileInputStream  api\n\n```java\n//文件描述实例，由java创建，不用我们创建\nprivate final FileDescriptor fd;\n//文件路径\nprivate final String path;\n//用于读取、写入、映射和操作文件的通道。与FileInputStream唯一关联。底层，不用管\nprivate FileChannel channel = null;\n//对象锁，阻塞io，使用Synchronized关键字阻塞\nprivate final Object closeLock = new Object();\n//资源是否关闭\nprivate volatile boolean closed = false;\n\n//使用文件名创建一个文件输入流会调用FileInputStream(File file)方法\npublic FileInputStream(String name) throws FileNotFoundException；\npublic FileInputStream(File file) throws FileNotFoundException；\n//打开流，本地方法由c\\C++编写，无需主动调用，构造方法已经调用，且是私有方法\nprivate native void open0(String name) throws FileNotFoundException;\nprivate void open(String name) throws FileNotFoundException {open0(name);}\n//从流中读取一个字节，声明式异常，需要主动处理\npublic int read() throws IOException；\nprivate native int read0() throws IOException\n//从流中读取off开始读取len个字符到字符数组中指定下标处,并返回读取长度。一般来说从0开始\nprivate native int readBytes(byte b[], int off, int len) throws IOException;\npublic int read(byte b[]) throws IOException {\n    return readBytes(b, 0, b.length);\n}\n//跳过指定长度字符，返回跳过长度。移动指针\npublic long skip(long n) throws IOException {\n  return skip0(n);\n}\nprivate native long skip0(long n) throws IOException;\n//剩余字节数\npublic int available() throws IOException {\n  return available0();\n}\nprivate native int available0() throws IOException;\n//关闭流，必须关闭资源\npublic void close() throws IOException；\n```\n\n查看一下FileOutputStream  api\n\n```java\n//是否追加文件内容。默认false，即覆盖\nprivate final boolean append;\npublic FileOutputStream(String name) throws FileNotFoundException；\npublic FileOutputStream(String name, boolean append) throws FileNotFoundException；\npublic FileOutputStream(File file) throws FileNotFoundException；\npublic FileOutputStream(File file, boolean append) throws FileNotFoundException；\n//open  open0\n//写入文件，字节byte可直接转化为int，安全不会溢出，没有负数\nprivate native void write(int b, boolean append) throws IOException;\nprivate native void writeBytes(byte b[], int off, int len, boolean append) throws IOException;\n```\n\n\n\n> 常用操作：这里使用try with resource语法糖，编译器会自动帮我们关闭资源，可以反编译查看\n\n```java\n@Test\npublic void inputStreamTest1() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile/test.txt\";\n    try (FileInputStream fin = new FileInputStream(filePath)) {\n        //跳过指定长度字节\n        final long skip = fin.skip(3L);\n        System.out.println(skip);\n        final byte[] bytes = new byte[5];\n        //从1开始读取4个字节，放入字节数组指定下标处\n        final int read = fin.read(bytes, 1, 4);\n        System.out.println(read);\n        for (byte aByte : bytes) {\n            System.out.println(Character.valueOf((char) aByte));\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n@Test\npublic void outputStreamTest1() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile/test.txt\";\n    try (final FileOutputStream fop = new FileOutputStream(filePath, true)) {\n        fop.write(\"可爱\".getBytes());\n        fop.write(\"abc\".getBytes());\n        //刷新流，将此之前的所有数据给操作系统，让操作系统写入硬件设备\n        fop.flush();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n###### ByteArrayInputStream & ByteArrayOutputStream\n\n> 字节数组输入输出流。内部组合一个字节数组，用于缓冲数据。\n\n```java\n@Test\npublic void byteArrayInputStreamTest1() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile/test.txt\";\n    try (final FileOutputStream fop = new FileOutputStream(filePath, true);\n         final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(\"abcd\".getBytes(StandardCharsets.UTF_8))) {\n        System.out.println((char)byteArrayInputStream.read());\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n@Test\npublic void byteArrayOutputStreamTest1() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile/test.txt\";\n    try (final FileOutputStream fop = new FileOutputStream(filePath, true);\n         final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(1024)) {\n        //写入到字节数组\n        byteArrayOutputStream.write(\"可可爱爱\".getBytes());\n        //一次性写入到，另一个输出流\n        byteArrayOutputStream.writeTo(fop);\n        //刷新流，将此之前的所有数据给操作系统，让操作系统写入硬件设备\n        fop.flush();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n###### ObjecInputStream & ObjectOutputStream\n\n> 对象输入输出流，一般用于序列化操作，又称为序列化流和反序列化流。ObjectOutputStream用于将对象序列化输出到文件中，持久化保存，ObjecInputStream用于将对象从文件中读出来。\n>\n> 一般用于数据传输，或当某个对象实例生命周期已经结束，但是需要保存其状态，以便下此直接反序列化恢复的情况。\n\n首先作为字节流，它拥有字节流的所有相关操作\n\n```java\n@Test\npublic void objectOutputStreamTest1() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile/objectTest.txt\";\n    try (final ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(filePath,false))) {\n        //写入到字节数组\n        objectOutputStream.write(\"xxx\".getBytes());\n        //刷新流，将此之前的所有数据给操作系统，让操作系统写入硬件设备\n        objectOutputStream.flush();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n作为对象流，设计目的就是为了操作对象:\n\n- class类必须实现Serializable接口，否则会报出`java.io.NotSerializableException`异常\n- 序列号serialVersionUID对应唯一类，不可随意修改，在反序列化时会去匹配。如果修改则报出`java.io.InvalidClassException`异常\n- 被transient修饰的属性在序列化时会被忽略\n\n例子：\n\n```java\n@Data\n@Accessors(chain = true)\nclass Person   implements Serializable {\n    private static final long serialVersionUID = -8861126921891657698L;\n  \n    String str1;\n    transient String str2;\n    final String str3 = \"123\";\n    static String str4;\n    int age;\n    Date birthday;\n}\n@Test\npublic void objectInputStreamTest1() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile/objectTest.txt\";\n    try (final ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(filePath))) {\n        final Person o = (Person) objectInputStream.readObject();\n        System.out.println(o);\n    } catch (IOException | ClassNotFoundException e) {\n        e.printStackTrace();\n    }\n}\n@Test\npublic void objectOutputStreamTest2() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile/objectTest.txt\";\n    try (final ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(filePath, false))) {\n        final Person person = new Person();\n        person.setStr1(\"str1\")\n                .setStr2(\"str2\")\n                .setAge(1)\n                .setBirthday(Calendar.getInstance().getTime());\n        objectOutputStream.writeObject(person);\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n\n\n###### FilterInputStream & FilterOutputStream\n\n> 过滤流，装饰器模式，可以对字节流进行包装实现额外功能。\n\n过滤流常用子类：\n\n- DateInputStream ：基本数据类型流，提供基本数据类型读取写入操作方法\n- BufferedInputStream : 缓冲输出流,其内维护一个字节数组，避免每次都和文件交互\n- PushbackInputStream\n- LineNumberInputStream\n\n> DateInputStream ,基本数据类型流，提供对基本数据类型写入、读取操作方法，其对基本字节流做了一个封装，约定如何写入字节，底层还是调用基本字节流写入字节。比如int占32位，4个字节，那么通过移位运算将其拆分为四个字节逐个写入字节，读取时逐个读取，并按写入规则转化数据。\n\n例一：\n\n```java\n@Test\npublic void dataOutputStreamTest1() {\n    String filePath = \"D:\\\\File\\\\Desktop\\\\blogXX\\\\foot\\\\testfile\\\\dataStreamFile.txt\";\n    try (final DataOutputStream dataOutputStream = new DataOutputStream(new FileOutputStream(filePath, false))) {\n        //作为字节流，拥有字节流相关操作，写入字节或字节数组\n        //dataOutputStream.write(\"开开心心\".getBytes(StandardCharsets.UTF_8));\n        dataOutputStream.writeUTF(\"可可爱爱\");\n        dataOutputStream.writeUTF(\"可可爱爱\");\n        dataOutputStream.writeUTF(\"开开心心\");\n        dataOutputStream.flush();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n@Test\npublic void dataInputStreamTest1() {\n    String filePath = \"D:\\\\File\\\\Desktop\\\\blogXX\\\\foot\\\\testfile\\\\dataStreamFile.txt\";\n    try (final DataInputStream dataInputStream = new DataInputStream(new FileInputStream(filePath))) {\n        while (dataInputStream.available()>0){\n            System.out.println(dataInputStream.readUTF());\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n\n\n> BufferedOutputStream  缓冲输出流，其内部维护一个字节数组，数据首先存放于字节数组，当调用flush方法或字节数组已经满了的情况，将字节数组中的字节一次性写入文件。如此不必频繁通过io通道和文件打交道。\n>\n> BufferedInputStream 缓冲输入流，内部有一个缓冲数组，数据读出来先存放于缓存数组中，当真正需要的时候将数据拷贝出来。\n\n例二：\n\n```java\n@Test\npublic void bufferedOutputStreamTest1() {\n    String filePath = \"D:\\\\File\\\\Desktop\\\\blogXX\\\\foot\\\\testfile\\\\bufferStreamFile.txt\";\n    try (final FilterOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(filePath, false), 1024)) {\n        //作为字节流，拥有字节流相关操作，写入字节或字节数组\n        bufferedOutputStream.write(\"abcde\".getBytes(StandardCharsets.UTF_8));\n        bufferedOutputStream.flush();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n@Test\npublic void bufferedInputStreamTest1() {\n    String filePath = \"D:\\\\File\\\\Desktop\\\\blogXX\\\\foot\\\\testfile\\\\bufferStreamFile.txt\";\n    try (final FilterInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(filePath))) {\n         byte[] bytes = new byte[1024];\n        while (bufferedInputStream.available() > 0) {\n            bufferedInputStream.read(bytes);\n            System.out.println(Arrays.toString(bytes));\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n\n\n#####  字符流\n\n> 操作字符，需要缓冲区，操作Reader、Writer的子类\n\n![image-20220824221348711](java成神之路(基础).assets/image-20220824221348711.png)\n\nRead常用子类：\n\n- InptStreamReader ：将字节输入流转为字符输入流\n- StreamDecoder:流解码器\n\n- FileReader  文件输入流\n- BufferedReader：缓存字符输入流\n\nWriter常用子类\n\n- OutputStreamWriter:将字符输出流转化为字节输出流\n\n- FileWriter   文件输出流\n- BufferedReader  缓存字符输出流\n\n\n\n###### InputSteamReader & OutputStreamWriter\n\n> 字节字符转化流。以规定的流解码器去读取字节数组，最后和转化为字符输出，我们只需要指定编码集。\n\n例一：\n\n```java\n@Test\npublic void testFileOutputStream1() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile\";\n    try (final OutputStreamWriter outputStreamWriter = new OutputStreamWriter(new FileOutputStream(new File(filePath, \"dataStreamFile.txt\")), StandardCharsets.UTF_8)) {\n        outputStreamWriter.write(\"hhhhhhhhhhhh哈哈哈哈\");\n        outputStreamWriter.flush();\n    } catch (IOException e) {\n    }\n}\n@Test\npublic void testFileInputStream1() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile\";\n    try (final InputStreamReader inputStreamReader = new InputStreamReader(new FileInputStream(new File(filePath, \"dataStreamFile.txt\")), StandardCharsets.UTF_8)) {\n        final char[] buffer = new char[1024];\n        int len = 0;\n        while ((len = inputStreamReader.read(buffer)) > 0) {\n            System.out.println(String.valueOf(buffer, 0, len));\n        }\n    } catch (IOException e) {\n    }\n}\n```\n\n\n\n###### FileReader  & FileWriter\n\n> 文件输入输出流，操作文件的便利类。\n>\n> 对InputStreamReader的封装。无需指定字符集，默认使用系统文件字符集。\n\n查看系统文件字符集：\n\n```java\n\nfinal String s = AccessController.doPrivileged(\n\tnew GetPropertyAction(\"file.encoding\"));\nSystem.out.println(s);\n```\n\n![image-20220824231942206](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208242319424.png)\n\n```java\n@Test\npublic void testFileWriter1() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile\";\n    try (final FileWriter fileWriter = new FileWriter(new File(filePath,\"dataStreamFile.txt\"))){\n        fileWriter.write(\"12331\");\n        //追加写入，返回this，类似于StringBuilder 的append\n        fileWriter.append(\"xxxxxx\").append(\"追加\");\n        //将流刷入操作系统，让操作系统去写入硬件，最终结果是否写入成功由操作系统决定\n        //如果不刷新，流也不关闭，数据不会写入硬件\n        fileWriter.flush();\n    }catch (IOException e){\n    }\n}\n@Test\npublic void testFileReader1() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile\";\n    try(final FileReader fileReader = new FileReader(new File(filePath,\"dataStreamFile.txt\"))){\n        final char[] buffer = new char[1024];\n        int len  = 0;\n        while ((len = fileReader.read(buffer)) > 0) {\n            System.out.println(String.valueOf(buffer,0, len));\n        }\n    }catch (IOException e){\n    }\n}\n```\n\n###### BufferedReader & BufferedWriter\n\n> 缓冲字符流，上面的FileRead存在不可自定义字符编码的问题，那么使用BufferedReader可完美解决此问题。\n>\n> BufferedReader 是对OutputStreamReader的增强和包装，其内提供了读取一行字符的方法，以及将所有字符读出以Stream<String>流的方式返回。以上都是基于字符数组实现，默认容量是8192。\n\n例子：\n\n```java\n@Test\npublic void testBufferedWriter1() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile\";\n    try (final BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(filePath, \"dataStreamFile.txt\")), StandardCharsets.UTF_8))) {\n        bufferedWriter.write(\"可可爱爱\");\n        bufferedWriter.write(\"快快乐乐\");\n        bufferedWriter.write('a');\n        bufferedWriter.write(96);\n        bufferedWriter.write(new char[]{'x','x'});\n        bufferedWriter.write(\"\\n\");\n        bufferedWriter.write(\"\\t\");\n        //新起一行\n        bufferedWriter.newLine();\n        bufferedWriter.write(\"开开心心\");\n    } catch (IOException e) {\n\n    }\n}\n\n@Test\npublic void testBufferedReader1() {\n  String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile\";\n  try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(new File(filePath, \"dataStreamFile.txt\")), StandardCharsets.UTF_8))) {\n    final char[] chars = new char[1];\n    final int read = bufferedReader.read();\n    System.out.println(new String(chars, 0, 1));\n    String buffer = \"\";\n    while ((buffer = bufferedReader.readLine()) != null) {\n      System.out.println(buffer);\n    }\n    //一次性读出来\n    BufferedReader bufferedReader1 = new BufferedReader(new InputStreamReader(new FileInputStream(new File(filePath, \"dataStreamFile.txt\")), StandardCharsets.UTF_8));\n    bufferedReader1.lines().forEach(System.out::println);\n  } catch (IOException e) {\n\n  }\n}\n```\n\n\n\n###### 字符流需要手动flush\n\n> 如果操作字符流方法内没有自动帮我们flush，那么想要将数据刷入文件需要手动flush\n\n```java\n@Test\npublic void testFlush() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile\";\n    OutputStreamWriter outputStreamWriter = null;\n    try {\n        outputStreamWriter = new OutputStreamWriter(new FileOutputStream(new File(filePath, \"dataStreamFile.txt\")));\n        //如此写入不了，没有flush 也没有 关闭流\n        outputStreamWriter.write(\"你好呀\");\n    } catch (IOException e) {\n    }\n}\n```\n\n\n\n\n\n##### 字节流与字符流转化\n\n> java io包下除了字节流与字符流以外，还包含一组字节流-字符流转化流。\n\nInputStreamReader，是Reader的子类属于字符流，可以将输入的字节流转化为输入的字符流。\n\nOutputStreamWriter，是Writer的子类属于字符流，可以将输出的字符流转换为输出的字节流。\n\n##### 输入输出流\n\n> 输入输出流是相对于参考系来说的，此参考系为存储数据的介质，往介质中存数据则为输入流，从介质中读出数据则为输出流。\n\n比如：\n\n将文件中数读出来，存到内存中，则为输入流，使用FileInputStream、FileReader\n\n将内存中的数据输出到文件中，则为输出流，使用FileOutputStream、FileWriter\n\n\n\n### 反射\n\n> 反射式java为程序员提供的强大机制，赋予程序可以在运行期间，知道任意类的所有属性和方法，调用或修改任意对象的属性和方法的能力。\n>\n> Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。而这也是Java被视为动态语言的一个关键性质。\n\n#### Class类\n\n> Class类用于封装加载到jvm中的类(包括接口和类)。当一个类被装载进jvm就会生成一个与之唯一对应的Class对象，通过这个Class对象我们就知道此类的所有信息。\n>\n> 在程序运行时，jvm会检查所需加载的类对应的Class对象是否已经加载，如果没有加载，jvm会根据类名查找对应的Class文件，并将其加载入jvm，jvm会保证每个class类只会生成唯一对应的class对象。\n\n获取Class对象的方式：\n\n- 对象.getClass()方法\n- 类名.class\n- Class.forName(\"class类全路径\")  第二个参数表示是否触发初始化，默认触发，且只触发一次\n\n```java\n@Test\npublic void test() {\n    final ClassPerson classPerson = new ClassPerson();\n    //对象.getClass\n    final Class<? extends ClassPerson> aClass = classPerson.getClass();\n    //类名.class\n    final Class<ClassPerson> classPersonClass = ClassPerson.class;\n    try {\n        //Class.forName  第二个参数boolean值表示是否触发初始化\n        final Class<?> aClass1 = Class.forName(\"com.roily.booknode.javatogod._04reflect.ClassPerson\");\n        final Class<?> aClass2 = Class.forName(\"com.roily.booknode.javatogod._04reflect.ClassPerson\", true, ClassLoader.getSystemClassLoader());\n   \t\t   System.out.println(VM.current().addressOf(aClass1));\n            System.out.println(VM.current().addressOf(aClass2));\n        } catch (Exception e) {\n        }\n        System.out.println(VM.current().addressOf(aClass));\n        System.out.println(VM.current().addressOf(classPersonClass));\n}\n```\n\n![image-20220825100540111](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208252320148.png)\n\n\n\n#### 反射能干什么\n\n- 使用反射创建实例对象\n- 使用反射获取一个实例对象，所属类的所有信息(类信息[父类、接口、注解]、属性、方法[包括私有方法、构造方法])\n\n\n\n##### 使用反射创建实例\n\n> 除了new关键字可创建实例对象，反射机制也可创建实例。\n>\n> 主要有两种方式：\n>\n> ①class.newInstance()\n>\n> ②获取构造方法，执行构造方法\n\n###### isInstance\n\nisInstance()方法是instanceOf 关键字的平替，如果返回true则可正常转化类型\n\n```java\n/**\n * Class 类Api isInstance\n * isInstance方法，是instanceOf的平替\n */\n@Test\npublic void testIsInstance() {\n    System.out.println(\"如果Object参数为该类实例，返回true\" + ClassPerson.class.isInstance(new ClassPerson()));\n    System.out.println(\"如果Object参数为该类或其任意子类的实例，返回true\" + ClassPerson.class.isInstance(new ClassSon()));\n    System.out.println(\"如果Object参数为该接口实现类，返回true\" + InterfaceTest.class.isInstance(new InterfaceTestImpl()));\n    //如果是数组类型，可强制转化不报CastException异常\n    final Object[] objects = new Object[1024];\n    System.out.println(objects.getClass().isInstance(new Integer[11]));\n}\n```\n\n###### newInstance\n\nnewInstance()方法创建实例：\n\n```java\npublic class ClassPerson {\n    public ClassPerson() {\n         System.out.println(\"公开构造器\");\n    }\n}\npublic class ClassPersonPrivate {\n    private ClassPersonPrivate() {\n        System.out.println(\"私有构造器\");\n    }\n}\n```\n\n> 如果此类的构造器是public的，则可使用class.newInstance()方法创建实例，且会触发类的初始化。\n>\n>  如果此类的构造器是private的，则不可使用class.newInstance()方法创建实例，会报java.lang.IllegalAccessException异常。\n\n```java\n/**\n * 如果此类的构造器是public的，则可使用class.newInstance()方法创建实例\n * 切会触发类的初始化\n */\n@Test\npublic void testNewInstance1() throws InstantiationException, IllegalAccessException {\n    final ClassPerson classPerson = ClassPerson.class.newInstance();\n    System.out.println(classPerson);\n}\n/**\n * 如果此类的构造器是private的，则不可使用class.newInstance()方法创建实例\n * 会报java.lang.IllegalAccessException异常\n */\n@Test\npublic void testNewInstance2() throws InstantiationException, IllegalAccessException {\n    final ClassPersonPrivate classPersonPrivate = ClassPersonPrivate.class.newInstance();\n    System.out.println(classPersonPrivate);\n}\n```\n\n\n\n###### getConstractor\n\n> 获取任意Class对象的非私有构造器，可以指定构造参数\n\n```java\n/**\n * Class的getConstructor方法可以获取，任意类的非私有构造器\n * 可以指构造参数\n */\n@Test\npublic void testGetConstructor() throws Exception {\n    final Class<ClassPerson> classPersonClass = ClassPerson.class;\n    //无参构造\n    final Constructor<ClassPerson> constructorWithOutParams = classPersonClass.getConstructor(null);\n    final ClassPerson classPerson1 = constructorWithOutParams.newInstance(null);\n    System.out.println(classPerson1);\n    //有参构造\n    final Constructor<ClassPerson> constructorWithParams = classPersonClass.getConstructor(String.class);\n    final ClassPerson classPerson2 = constructorWithParams.newInstance(\"小可爱\");\n    System.out.println(classPerson2);\n}\n```\n\n![image-20220825110704311](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208252320961.png)\n\n> 当然对于private私有构造器，不可以获取。\n>\n> 会报出`java.lang.NoSuchMethodException`异常\n\n```java\n@Test\npublic void testGetConstructor2() throws Exception {\n    final Constructor<ClassPersonPrivate> constructor = ClassPersonPrivate.class.getConstructor(null);\n    constructor.newInstance(null);\n}\n```\n\n###### getDeclaredConstructor\n\n> 获取任意类的构造器，如果是private的需要设置为可访问的\n\n```java\n/**\n * Class的getDeclaredConstructor方法可以获取，任意类的构造器\n * 可以指构造参数,如果是私有需要设置可访问,否则会爆出IllegalAccessException异常\n */\n@Test\npublic void testGetDeclaredConstructor1() throws Exception {\n    final Constructor<ClassPerson> declaredConstructor1 = ClassPerson.class.getDeclaredConstructor(null);\n    declaredConstructor1.newInstance(null);\n    final Constructor<ClassPersonPrivate> declaredConstructor2 = ClassPersonPrivate.class.getDeclaredConstructor(null);\n    //设置可访问\n    declaredConstructor2.setAccessible(true);\n    declaredConstructor2.newInstance(null);\n}\n```\n\n\n\n##### 属性、方法\n\n> 使用反射操作属性、方法\n\n###### 属性\n\n> 获取属性Field\n\n```java\n//修改name属性为pubilc\npublic String name;\n```\n\n> 使用`getField()`方法只能获取`public`属性。\n>\n> 使用`getDeclaredField()`获取所有属性，设置`setAccessible(true)`可对非pulic属性进行访问\n\n```java\n@Test\npublic void testField1() throws Exception {\n    //getField获取public 属性\n    final Field name = ClassPerson.class.getField(\"name\");\n    System.out.println(\"field name :  => \" + name.getName());\n    System.out.println(\"field type :  => \" + name.getType());\n}\n@Test\npublic void testField2() throws Exception {\n    final Field[] fields =  ClassPerson.class.getDeclaredFields();\n    Arrays.asList(fields).forEach(field -> field.setAccessible(true));\n    for (Field field : fields) {\n        System.out.println(\"field name :  => \" + field.getName());\n        System.out.println(\"field type :  => \" + field.getType());\n    }\n}\n```\n\n> 可通过反射动态修改对象属性\n\n```java\n@Test\npublic void testField3() throws Exception {\n    final ClassPerson classPerson = new ClassPerson();\n    System.out.println(\"ClassPerson =>\" + classPerson);\n    //得到所有\n    final Field[] fields = classPerson.getClass().getDeclaredFields();\n    Arrays.asList(fields).forEach(field -> {\n        field.setAccessible(true);\n        Object obj;\n        switch (field.getName()) {\n            case \"name\":\n                obj = \"name\";\n                break;\n            case \"age\":\n                obj = 20;\n                break;\n            case \"num\":\n                obj = 10;\n                break;\n            case \"values\":\n                obj = new String[]{\"values\"};\n                break;\n            default:\n                obj = null;   break;\n        }\n        try {\n            field.set(classPerson,obj);\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n    });\n    System.out.println(classPerson);\n}\n```\n\n![image-20220825184025386](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208252320662.png)\n\n###### 方法\n\n> 通过反射调用方法\n\n```java\n@Test\npublic void testMethod1() throws Exception {\n    final ClassPerson classPerson = new ClassPerson();\n    System.out.println(\"ClassPerson =>\" + classPerson);\n    //获取public方法\n    final Method methodWithoutParam = classPerson.getClass().getMethod(\"publicMethod\");\n    System.out.println(\"方法名:=>\" + methodWithoutParam.getName());\n    methodWithoutParam.invoke(classPerson);\n    //获取public方法\n    final Method methodWithParam = classPerson.getClass().getMethod(\"publicWithParamMethod\", String.class, int.class);\n    System.out.println(\"方法名:=>\" + methodWithParam.getName());\n    methodWithParam.invoke(classPerson, \"str\", 100);\n}\n```\n\n![image-20220825185606816](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208252320034.png)\n\n\n\n##### 使用反射获取其他信息\n\n> 使用反射获取其他信息\n\n```java\n/**\n * 使用反射获取其他信息\n */\n@Test\npublic void testGetOtherInfo() throws FileNotFoundException {\n    final String string = new String();\n    final Class<TestClass> testClassClass = TestClass.class;\n    System.out.println(\"类名  => \" + testClassClass.getSimpleName());\n    System.out.println(\"类全限定名  => \" + testClassClass.getName());\n    System.out.println(\"包名  => \" + testClassClass.getPackage());\n    //获取类加载器，我们写的类，一般都是应用类加载器，也叫app加载器\n    System.out.println(\"类加载器  =>\");\n    //其他加载器，扩展类加载器ext,引导类加载器我们得不到会返回null\n    System.out.println(\"扩展类加载器 =>\" + testClassClass.getClassLoader().getParent());\n    System.out.println(\"扩展类加载器 =>\" + testClassClass.getClassLoader().getParent().getParent());\n    //注意如果注解的保留策略需设置为@Retention(RetentionPolicy.RUNTIME)\n    System.out.println(\"runtime注解，运行期由VM保留  => \" + testClassClass.getAnnotation(AnnotationTest.class));\n    for (Class<?> anInterface : testClassClass.getInterfaces()) {\n        System.out.println(\"获取接口  => \" + anInterface);\n    }\n    System.out.println(\"获取父类  => \" + testClassClass.getSuperclass());\n    System.out.println(\"获取类路径下，也就是classes根目录下的某个资源文件输入流   => \" + testClassClass.getResourceAsStream(\"/test.properties\"));\n\n}\n```\n\n![image-20220825234832246](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208252348911.png)\n\n#### 工厂模式 + 反射实现ioc\n\n> `Spring IOC`的实现就是基于反射 + 工厂模式实现的。\n\n\n\n##### 不使用反射\n\n> 不使用反射利用工厂模式创建bean，这里就以简单工厂模式实现\n\n```java\npublic interface Fruit {\n    /**\n     * 描述\n     */\n    void describe();\n}\npublic class Apple implements Fruit{\n    String name;\n    @Override\n    public void describe() {\n        System.out.println(this.name);\n    }\n}\npublic class Banana implements Fruit{\n    String name;\n    @Override\n    public void describe() {\n        System.out.println(this.name);\n    }\n}\npublic class Orange implements Fruit{\n    String name;\n    @Override\n    public void describe() {\n        System.out.println(this.name);\n    }\n}\n```\n\n```java\npublic class MyCustomizeFactory {\n\t\t//bean工厂\n    final static HashMap<String, Object> mapFactory = new HashMap<>();\n    public static Fruit getInstance(String beanName) {\n        Fruit fruit = (Fruit) mapFactory.get(beanName);\n        if (!ObjectUtils.isEmpty(fruit)) {\n            return fruit;\n        }\n        switch (beanName) {\n            case \"Apple\":\n                fruit = new Apple(beanName);\n                break;\n            case \"Orange\":\n                fruit = new Orange(beanName);\n                break;\n            case \"Banana\":\n                fruit = new Banana(beanName);\n                break;\n            default:\n                System.out.println(\"error\");\n                break;\n        }\n        mapFactory.put(beanName, fruit);\n        return fruit;\n    }\n}\n```\n\n> 测试\n\n```java\npublic static void main(String[] args) {\n    final Fruit apple = MyCustomizeFactory.getInstance(\"Apple\");\n    System.out.println(apple);\n    final Fruit banana = MyCustomizeFactory.getInstance(\"Banana\");\n    System.out.println(banana);\n}\n```\n\n> 如此实现存在一个问题：如果添加实现类的话需要修改工厂代码，不符合开闭原则\n\n![image-20220826002732640](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208260027034.png)\n\n##### 使用反射\n\n> 我们只需要知道此类的全限定名即可通过反射创建此对象\n\n```java\npublic static Fruit getInstanceWithReflect(String name, String className) {\n        Fruit fruit = (Fruit) mapFactory.get(className);\n        if (!ObjectUtils.isEmpty(fruit)) {\n            return fruit;\n        }\n        try {\n            fruit = (Fruit) Class.forName(className).newInstance();\n        } catch (Exception e) {\n            System.out.println(\"error\");\n        }\n        mapFactory.put(name, fruit);\n        return fruit;\n    }\n```\n\n> 测试\n\n```java\n final Fruit apple = MyCustomizeFactory.getInstanceWithReflect(\"apple\",\"com.roily.booknode.javatogod._04reflect.factoryioc.Apple\");\n        System.out.println(apple.getClass());\n        final Fruit banana = MyCustomizeFactory.getInstanceWithReflect(\"banana\",\"com.roily.booknode.javatogod._04reflect.factoryioc.Banana\");\n        System.out.println(banana.getClass());\n        final Fruit orange = MyCustomizeFactory.getInstanceWithReflect(\"orange\",\"com.roily.booknode.javatogod._04reflect.factoryioc.Orange\");\n        System.out.println(orange.getClass());\n```\n\n> 结合配置文件，一次性创建工厂，之后只需去工厂取bean即可\n\n创建bean配置文件\n\n![image-20220826005204288](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208260052813.png)\n\n工厂类添加方法\n\n```java\npublic static Fruit getInstanceWithReflect(String name) {\n    return (Fruit) mapFactory.get(name);\n}\n```\n\n测试：\n\n程序运行触发初始化，对应bean只创建一次放入工厂，想要就去拿\n\n```java\nstatic {\n    final InputStream in = ClientTest.class.getResourceAsStream(\"/bean.properties\");\n    final Properties properties = new Properties();\n    try {\n        properties.load(in);\n        properties.keySet().forEach(ele -> MyCustomizeFactory.getInstanceWithReflect((String) ele, (String) properties.get(ele)));\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\npublic static void main(String[] args) {\n    final Fruit apple = MyCustomizeFactory.getInstanceWithReflect(\"Apple\");\n    System.out.println(apple.getClass());\n    final Fruit banana = MyCustomizeFactory.getInstanceWithReflect(\"Banana\");\n    System.out.println(banana.getClass());\n    final Fruit orange = MyCustomizeFactory.getInstanceWithReflect(\"Orange\");\n    System.out.println(orange.getClass());\n}\n```\n\n![image-20220826005421217](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208260054512.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/foot/读书笔记/java成神之路(基础)/java成神之路(基础).md b/foot/读书笔记/java成神之路(基础)/java成神之路(基础).md
--- a/foot/读书笔记/java成神之路(基础)/java成神之路(基础).md	(revision 1e0ddc60a5238b79afe5920cd79ce47708f9c510)
+++ b/foot/读书笔记/java成神之路(基础)/java成神之路(基础).md	(date 1661450870957)
@@ -120,7 +120,7 @@
 }
 ```
 
-![image-20220729135114407](java成神之路(基础).assets/image-20220729135114407.png)
+![image-20220729135114407](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208260159591.png)
 
 
 
