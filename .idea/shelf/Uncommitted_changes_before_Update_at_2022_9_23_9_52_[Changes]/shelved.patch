Index: .idea/shelf/Uncommitted_changes_before_Update_at_2022_9_6__23_36__Changes_.xml
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_2022_9_6__23_36__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_2022_9_6__23_36__Changes_.xml
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_2022_9_6__23_36__Changes_.xml	(revision 503c32114df0bd8694780b42caa77dddeed5e390)
+++ /dev/null	(revision 503c32114df0bd8694780b42caa77dddeed5e390)
@@ -1,4 +0,0 @@
-<changelist name="Uncommitted_changes_before_Update_at_2022_9_6,_23_36_[Changes]" date="1662478616720" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_2022_9_6,_23_36_[Changes]/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Update at 2022/9/6, 23:36 [Changes]" />
-</changelist>
\ No newline at end of file
Index: .idea/shelf/Uncommitted_changes_before_Update_at_2022_9_6,_23_36_[Changes]/shelved.patch
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_2022_9_6,_23_36_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_2022_9_6,_23_36_[Changes]/shelved.patch
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_2022_9_6,_23_36_[Changes]/shelved.patch	(revision 503c32114df0bd8694780b42caa77dddeed5e390)
+++ /dev/null	(revision 503c32114df0bd8694780b42caa77dddeed5e390)
@@ -1,209 +0,0 @@
-Index: foot/读书笔记/java成神之路(基础)/java成神之路(基础).md
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>## java成神之路读书笔记\n\n> 借鉴地址Gitee Pages 完整阅读:http://hollischuang.gitee.io/tobetopjavaer\n>\n> 作者：Hollis ，阿里巴巴技术专家，51CTO 专栏作家，CSDN 博客专家，掘金优秀作者， 《程序员的三门课》联合作者，《Java 工程师成神之路》系列文章作者;热衷于分享计算 机编程相关技术，博文全网阅读量数千万。\n\n\n\n### 面向对象\n\n> java是一种面向对象的编程语言\n\n#### 面向过程\n\n> 什么是面向过程？\n\n面向过程(Procedure Oriented)是一种以过程为中心的编程思想，是一种自顶而下的编程模式。简单来说，面向过程的开发范式中，程序员需要把问题分解成一个一个步骤，每个步骤用函数实现，依次调用即可。\n\n面向过程的编程语言以诸多流程控制语句来实现一个功能，整体表现为流程化。\n\n**优缺点**\n\n> 优点\n\n流程化，执行效率高\n\n> 缺点\n\n维护困难，复用性差\n\n\n\n#### 面向对象\n\n面向对象（Object Oriented），java是一种面向对象的编程语言。在面向对象的开发过程中，回将某件事情进行抽象，将一件事物的方法属性封装到一个类中，通过多个类之间的组合调用来实现某种功能。\n\n\n\n#### 面向对象三大基本特征\n\n> 封装、继承、多态\n\n##### 封装\n\n> 如果一个类希望其他类访问其内部属性存在不同限制，那么我们可以将其方法和属性设置不同的访问权限，这就是封装。\n\n访问级别有以下几种\n\n- public    所有类都可以访问\n- protected   受保护的，默认访问级别，同级别包下的类可以访问\n- private  私有的，任何其他类都不可以访问，只供其内部访问\n\n> 一般来说如果不是清楚的知道一个类的属性或方法需要被其他类访问，我们会将其设置为私有属性，不对外暴露。\n\n\n\n##### 继承\n\n> 继承是java为我们提供的可以实现代码复用的一种能力。可以拥有现有类的所有属性和功能（包括私有属性和私有方法），并且可以在此基础上进行扩展。\n\n\n\n##### 多态\n\n> \u200B\tjava中的多态指的是同一种操作，作用于不同的实例可以有不同的结果。是一种运行时状态，只有在运行期间才会直到调用的具体方法是什么。\n>\n> \u200B\t具体表现形式为父类或接口的引用指向子类或实现类的实例。调用父类或接口中定义或声明的方法，会根据传入的不同的子类或实现类来表现不同的逻辑。\n\n多态机制使具有不同内部结构的对象可以共享相同的外部接口。\n\n\n\n> 编译期&运行期\n\n编译期指的是，将源代码编译成另一个中间语言，在此期间会做一些代码规范检查，以及编译期间代码优化。\n\n运行期，指的是程序运行在内存中，进行交互。\n\n###### 编译期间多态\n\n> 在编译期间已经明确知道，具体类型，知道调用什么方法。\n\n比如说方法重载、可以通过参数列表的不同确定调用的具体方法。\n\n###### 运行期多态\n\n> 指的是在运行期间才会确认具体类型，才会知道调用的方法，需要`extends``implament`关键字一层一层去找。\n\n比如说使用父类或接口的引用，指向子类或实现类的实例。\n\n```java\npublic class Demo {\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException {\n        Class<?> sonClass = Class.forName(\"com.roily.booknode.javatogod._01faceobj.extendsiscompile.Son\");\n        Person son = (Person) sonClass.newInstance();\n        son.method1();\n        Class<?> daughterClass = Class.forName(\"com.roily.booknode.javatogod._01faceobj.extendsiscompile.Daughter\");\n        Person daughter = (Person) daughterClass.newInstance();\n        daughter.method1();\n    }\n}\n\nclass Person {\n    void method1() {\n        System.out.println(\"method1\");\n    }\n}\n\nclass Son extends Person {\n    @Override\n    void method1() {\n        System.out.println(\"son method01\");\n    }\n}\nclass Daughter extends Person {\n    @Override\n    void method1() {\n        System.out.println(\"Daughter method01\");\n    }\n}\n```\n\n![image-20220729135114407](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208260159591.png)\n\n\n\n#### 重写和重载\n\n> 重写（Overriding）和重载（Overloading）是两个比较重要的概念。\n\n##### 重载\n\n> 指的是在同一个类中，多个方法的方法名称相同而方法签名不同的现象称为重载，这些方法互称为重载方法。\n\n方法签名：方法名+参数列表。（也就是方法名相同，参数列表不同才会构成重载）\n\n返回类型不同不会构成重载。\n\n- 方法名相同，参数列表不同\n- 可以改变返回类型\n- 可以修改访问修饰符\n- 可以声明新的检查异常\n- 重载可以发生在一个类中，或在子类和父类中\n\n\n\n##### 重写\n\n> 严格意义上指的是子类中定义了和父类相同方法签名，且符合重写要求的方法，那么称子类重写了父类的方法。\n>\n> 接口声明抽象方法，其实现类实现抽象方法，对应方法上可以加上@OverWriting注解，也可以称为重写，更多的称为实现。\n\n```java\npublic class OverWriting {\n    public static void main(String[] args) {\n        final Animal dog = new Dog();\n        dog.bark();\n    }\n}\nclass Animal {\n    void bark() {\n        System.out.println(\"动物叫\");\n    }\n}\nclass Dog extends Animal {\n    @Override\n    void bark() {\n        System.out.println(\"狗叫\");\n    }\n}\n```\n\n`输出：狗叫`\n\n> 这里子类实例指向父类引用，是多态的表现行式，编译期间会去检查父类中是否存在对应调用方法。而运行期间具体需要调用哪个方法，需要根据具体指向的实例来决定\n\n\n\n方法重写的条件需要具备以下条件和要求：\n\n> 两同两小一大\n\n- 两同（方法签名相同）\n  - 方法名相同\n  - 参数列表相同\n\n- 两小\n  - 返回类型的范围需要相等或更小（比如父类返回ArrayList子类就不能返回list）\n  - 抛出的检查异常范围要比父类被重写方法要小\n- 一大\n  - 访问级别限制，比被重写方法访问范围要大(即父类是protected的那么子类重写的方法不能申明为private)\n\n> 其他\n\n- 不能重写被final标识的方法\n- 重写的前提是继承\n\n```java\nclass Person {\n    void method1(int a, int b) {\n        System.out.println(\"XX\");\n    }\n    ArrayList<Integer> method2() {\n        return null;\n    }\n}\nclass Student extends Person {\n    /**\n     * 两同\n     * - 方法名和参数列表相同\n     */\n    @Override\n    void method1(int a, int b) {\n        System.out.println(\"XX\");\n    }\n    /**\n     * 两小\n     * - 返回参数要比被重写方法要小（范围）\n     */\n    //@Override\n    //List<Integer> method2() {\n    //    //通过不了编译\n    //    return null;\n    //}\n}\n```\n\n> 子类的返回范围比父类的大，通过不了编译，反过来就行\n\n\n\n#### 继承&实现\n\n> 继承的关键字`extends`，实现关键字`implements`。\n\n\n\n##### 继承\n\n> 通过继承可以拥有父类的所有属性和方法，实现代码的重用。继承可以发生在类与类之间，这个类可以是具体的也可以是抽象的，同时继承也可以发生在接口与接口之间。\n\n> 如果说可以从某个类中抽出来可以供于公共使用的功能，那么就可以抽出一个父类出来，其他类去继承这个父类，以继承的方式来实现对代码的重用。但前提是这个抽出来的这个父类得保持稳定，也就是少量修改，且这个父类得对其他类都得适用。\n\n一般来说不会使用继承来实现重用，特别是继承至具体的类，如果说非得继承可以继承至抽象类。\n\n\n\n##### 实现\n\n> 实现发生在类与接口或抽象类之间，如果说一组业务的处理方式是一样的那么就可以制定抽象（制定标准），具体业务去实现定义的抽象\n\n```java\n/**\n * 可以实现一个接口\n */\ninterface IPerson{\n    /**\n     * 抽象方法\n     */\n    void method();\n}\nclass Teacher implements IPerson{\n\n    @Override\n    public void method() {\n        \n    }\n}\n\n/**\n * 可以是类实现抽象类的抽象方法\n */\nabstract class AbstractPerson{\n    \n    abstract void method();\n    \n}\nclass StudentImpl extends AbstractPerson{\n    \n    @Override\n    void method() {\n        \n    }\n}\n\n/**\n * 可以是抽象类实现接口\n */\nabstract class AbstractPersonX implements IPerson{\n    @Override\n    public void method() {\n\n    }\n}\n```\n\n\n\n\n\n#### java单继承\n\n> `java`通过`extends`关键字实现继承，且不支持多继承。\n\n##### 为什么\n\n> 菱形问题：假设B和C都继承自A，B和C都继承了父类A的所有属性和方法，如果java支持多继承的话，此刻有一个D继承自B和C，那么类D就同时拥有类B和类C的所有属性和方法，并且类D继承了两份来自于A的属性和方法，拥有同名属性和相同方法签名的方法是通过不了编译的，且如果通过编译，在调用的时候也会产生歧义。\n\n<img src=\"https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282250770.png\" alt=\"image-20220728231808420\" style=\"zoom:50%;\" />\n\n##### java可以多实现\n\n> java不支持多继承但是支持多实现\n\n如下例子，我们在InterfaceA和InterfaceB中定义了两个同名的方法，然后使用ClassC实现它们，发现实现类对于相同方法只实现了一次。\n\n```java\n/**\n * 但是java可以多实现，且java8之后接口中可以定义default方法\n */\ninterface InterfaceA {\n    void method1();\n}\ninterface InterfaceB {\n    void method1();\n    \n    void method2();\n}\nclass ClassC implements InterfaceA, InterfaceB {\n    @Override\n    public void method1() {\n        System.out.println(\"method1\");\n    }\n    @Override\n    public void method2() {\n        System.out.println(\"method2\");\n    }\n}\n```\n\n> 对于接口而言它只是一个标准、抽象，实现类按照约定实现标准。方然也可以指定标准，使用某个接口的引用指向实现类的实例。\n\n```java\n@Test\npublic void test1() {\n    InterfaceB classC1 = new ClassC();\n    InterfaceA classC2 = new ClassC();\n}\n```\n\n> 接口中可以定义default方法，且我们可以使用Implement从多个接口中继承得到多个默认方法，特别的如果说两个接口存在相同方法签名的方法，实现类会被要求强制重写同名方法签名的方法来解决菱形问题。\n\n```java\ninterface InterfaceC {\n    default void method1() {\n        System.out.println(\"InterfaceC default1方法\");\n    }\n}\ninterface InterfaceD  {\n    default void method1() {\n        System.out.println(\"InterfaceD default1方法\");\n    }\n}\n/**\n * 可以使用implement从多个接口中得到多个default方法，\n * 如果存在菱形问题，会强制要求实现类重写同名方法\n */\nclass ClassD implements InterfaceC, InterfaceD {\n    @Override\n    public void method1() {\n        InterfaceC.super.method1();\n    }\n}\n```\n\n\n\n\n\n#### 五大基本原则\n\n> \u200B\t面向对象五大基本原则，指导程序员编码，符合五大基本原则的程序，健壮性、可维护性和可扩展性都大大提高。\n\n##### 五大基本原则，都旨在：\n\n- 高内聚、低耦合\n- 面向抽象、接口，而不是面向具体、实现\n\n##### 单一职责\n\n> 适用于方法、接口和类。一个类的职责尽量单一，只有一个引起它的变化。\n\n对于方法而言，我们一般都遵守其单一职责原则\n\n对于接口而言，抽象方法尽量要求要少，如果方法太多可以进行接口拆分\n\n对于类而言，一般来说都不会严格遵守单一职责，比如说有一个类UserService，进行堆用户的增删改查，那么这个类想要严格遵守大一职责，完全可以拆分为四个类。\n\n所以说，单一职责尽量遵守，类、接口、方法不要过于臃肿。在业务要求基础之上，合理遵守。\n\n\n\n##### 开闭原则\n\n> 对扩展开放、对修改关闭。\n\n1、对扩展开放，意味着有新的需求时，可以在现有代码上进行扩展，以适应新的变化。\n\n2、对修改关闭，当软件或系统一旦设计完成，可以独立完成工作，而不要其进行任何修改的尝试\n\n> 开闭原则的重点在于，面向接口、抽象编程而不是面向实现、具体编程。\n>\n> 因为抽象也就是接口相对稳定，接口定义了一套标准，如果说接口添加新的抽象方法，那么就必须修改其实现类，所以说对于修改是关闭的。\n>\n> 而如果说现在有了一个新的需求，可以通过实现现有接口定义一个新的类，配合多态可以对当前系统功能进行扩展，所以说对扩展开放。\n\n> 而不能面向具体，一般来说会以继承或组合的方式实现具体类的复用。具体并没有一套标准，也就是说父类修改对应逻辑，并不会要求子类修改，也就是对修改开放，违背开闭原则。\n\n##### 里氏替换原则\n\n> 里氏替换原则知道我们如何使用继承，是一种编程思想。\n>\n> 要求软件实体：子类必须能够替换其基类，并且不改变业务逻辑。\n\n\n\n###### 里氏替换原则和继承的关系\n\n- 继承\n\n  > 继承是java提供的一种可以实现代码复用的语法，但是继承是侵入式的，如果在继承的过程中子类重写了父类的方法，那么说明父类的方法并不通用。\n\n- 里氏替换原则\n\n  > 里氏替换原则是一种编程思想，用于在指导我们合理使用继承。只有遵守了里氏替换原则，才可以实现继承复用。\n\n\n\n##### 依赖倒置原则\n\n> 面向接口编程，依赖于抽象。\n>\n> 具体定义：高层模块不依赖于底层模块，二者都依赖于抽象；抽象不依赖于具体，具体依赖于抽象。\n\n\n\n##### 接口隔离原则\n\n> 将臃肿的大接口拆分为一个个小接口，可以使用接口继承或实现多个接口的方式来实现多个接口定义的抽象方法。\n>\n> 如果一个接口过于庞大，或存在一些不必要实现的方法时，这是一种接口污染。\n\n\n\n#### 继承和组合\n\n> 继承和组合都是java用于实现代码复用的技术之二。优先考虑组合，尽量避免使用继承。\n\n继承\n\n> 继承(Inheritance)是一种联结类与类的层次模型。指的是一个类(子类、子接口)继承另外一个类(父类、父接口)的功能。并且可以增加自己新的功能的能力。继承是一种`AS-a`的关系。\n\n![image-20220729130759731](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282250283.png)\n\n组合\n\n> 组合(Composition)体现的是整体与部分、拥有的关系，即`has-a`关系。\n\n![image-20220729131252923](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282251014.png)\n\n\n\n##### 组合&继承关系\n\n继承是一种侵入式的代码结构，在继承关系中，父类的内部细节对于子类是可见的（继承是一种白盒式代码复用），如果父类的代码逻辑发生改变，那么如果子类调用了父类的类方法，子类的逻辑也会随之修改，甚至出错。（继承是一种编译期概念，在编译器就确认了类与类的关系）\n\n组合是将现有对象进行拼装组合来实现较复杂的业务逻辑，将对象作为内部的一个属性，组合进来的对象其内部实现细节是不可见的（黑盒式代码复用）。（如果说组合进来的是一个接口或抽象类型，那么在编译期无法确认其具体类型，只有在运行期间才会确认，所以一定程度上复用性更高）\n\n\n\n###### 对比\n\n|                             组合                             |                         继承                         |\n| :----------------------------------------------------------: | :--------------------------------------------------: |\n|            不会破坏封装，整体类与局部类之间松耦合            | 破坏封装，子类依赖于父类，表现为父类与父类之间前耦合 |\n|         组合进来的可以是一个抽象，因此具有一定扩展性         |                   可通过定义新方法                   |\n| 整体类对组合进来的类进行包装，并可以做一些拓展，就是装饰器模式和代理模式 |                                                      |\n|             创建整体对象的时候，必须创建局部对象             |           创建子类对象，会自动创建父类对象           |\n|                                                              |                                                      |\n\n\n\n##### 如何选择\n\n> 多用组合、少用继承。\n\n- 在同等情况下优先选择组合，利于扩展\n- 继承也有用处，如果当前类必须要向基类进行向上转型，则可以考虑使用继承\n\n\n\n#### 构造函数和默认构造函数\n\n> 构造函数配合`new`关键字，用于创建实例对象和给成员变量赋值。\n\n> 构造函数长什么样子？\n\n构造函数和普通方法很相似，①构造函数名为类名②构造函数不声明返回类型，返回当前类对象\n\n> 构造函数的重载\n\n构造函数根据参数列表的不同可以实现重载。并且可以为特殊属性给与默认值。\n\n```java\nclass Person{\n    int age;\n    String name;\n    String address;\n    Boolean sex;\n    \n    private Person(int age, String name, String address, Boolean sex){\n        this.age = age;\n        this.name = name;\n        this.address = address;\n        this.sex = sex;\n    }\n    public Person(int age, String name, String address){\n        return Person(age,name,address,false);\n    }\n}\n```\n\n\n\n> 如果当前类没有构造函数，编译器会自动生成一个无参构造函数。其成员变量会被赋予默认值。\n\n##### 如果没有构造函数\n\n> 会生成默认构造函数\n\n```java\npublic class ConstructorTest {\n    int i;\n    String str;\n}\n```\n\n反编译后：\n\n```java\npublic class ConstructorTest{\n    public ConstructorTest(){\n    }\n    int i;\n    String str;\n}\n```\n\n##### 如果存在构造函数\n\n> 会使用定义的构造函数，此刻空参构造函数不可用。\n\n```java\nclass ConstructorTest2 {\n    int i;\n    String str;\n    public ConstructorTest2(int i) {\n        this.i = i;\n    }\n}\n```\n\n反编译后：\n\n```java\nclass ConstructorTest2{\n    public ConstructorTest2(int i){\n        this.i = i;\n    }\n    int i;\n    String str;\n}\n```\n\n\n\n#### 类变量、成员变量和局部变量\n\n> `java`中如果从，生命周期，作用域和内存角度去看，`java`的变量分为，类变量、成员变量和局部变量。\n\n##### 类变量\n\n> 类变量被`static`修饰，属于类，生命周期等同于类的生命周期，当一个类被类加载器成功加载到方法区，其就已经存在与方法区。当类被卸载的时候也跟着消失。\n\n##### 成员变量\n\n> 成员变量属于实例，生命周期等同于实例，当一个实例被new出来(或反射等其他方式)，会为其赋值，跟随实例存在于堆内存中。当实例对象被回收时，他也跟着消失。\n\n##### 局部变量\n\n> 局部变量存在于栈内存，一般存在于方法参数，循环体或方法中。\n\n```java\npublic class Demo2 {\n    //类变量\n    final static String str1 = \"abc\";\n    static String str2 = \"abc\";\n \n    //成员变量\n    String str3 = \"abc\";\n\n    //局部变量\n    void method01(String str1) {\n        String str2 = \"abc\";\n        for (StringBuilder str = new StringBuilder(\"abc\"); str.toString().equals(\"abc\"); ) {\n        }\n    }\n}\n```\n\n\n\n#### 访问修饰符\n\n- public  \n\n> 公开的，被public修饰的成员变量和方法对所有类都是可见的，所有类和对象都可以直接访问\n\n- private\n\n> 私有的，被private修饰的成员变量和方法是私有的，只有当前类有访问权限。即便是子类也不可以访问\n\n- protected\n\n> 受保护的，被protected修饰的成员变量和方法是受保护的的，只有当前类和与其处于同一包下的类有访问权限。除非是子类\n\n- default\n\n> 默认的，被default修饰的成员变量和方法是受保护的的，只有当前类和与其处于同一包下的类有访问权限。即便是子类\n\n```java\npackage com.roily.booknode.javatogod._01faceobj.extendsiscompile;\n\npublic class Demo3 {\n    public String str1;\n    String str2;\n    private String str3;\n    protected String str4;\n}\n```\n\n子类不在同一个包下：\n\n```java\npackage com.roily.booknode.javatogod._01faceobj;\n\nimport com.roily.booknode.javatogod._01faceobj.extendsiscompile.Demo3;\npublic class TestDemo extends Demo3{\n    void method1(){\n        System.out.println(str1);\n        System.out.println(str4);\n    }\n}\n```\n\n> 可见如果不指定属性和方法的访问级别的话，默认为default。\n\n\n\n#### java的值传递\n\n> `java`关于关于参数的传递只有值传递，在传递参数的时候会将参数进行拷贝，在方法体中操作的都是拷贝的参数。\n\n##### 形参、实参\n\n> 形参：在定义方法的时候使用的参数，[参数类型+形参名称]，目的是为了接收参数\n>\n> 实参：在抵用方法的时候，被调方法会被传入一个参数 [参数名]，这个参数就叫实参\n\n```java\n/**\n * @param str 形参\n */\nvoid method(String str) {\n}\nvoid method2() {\n    /**\n     * 123  实参\n     * str  实参\n     */\n    method(\"123\");\n    String str = \"123\";\n    method(str);\n}\n```\n\n\n\n##### 为什么说java只有值传递\n\n> 对于基本数据类型来说，它只有值的概念，所以对于基本数据类型的值传递没有任何异议。\n>\n> 对于引用数据类型来说，在对引用类型的参数进行传递的时候，会将参数进行拷贝，在方法体内实际操作的是拷贝的副本，如果我们没有改变引用关系而直接操作属性，是会对原对象有影响的，应为两个引用指向的是同一个对象。\n\n例：\n\n```java\n/**\n * 基本数据类型，只有值的概念\n *\n * @param i\n */\nvoid simpType(int i) {\n    i = 999;\n}\n\nvoid referenceType1(StringBuilder sb) {\n    sb.append(\"追加\");\n}\n\nvoid referenceType2(StringBuilder sb) {\n    sb = new StringBuilder();\n    sb.append(\"追加\");\n}\n\n@Test\npublic void test1() {\n    System.out.println(\"基本数据类型\");\n    int i = 1;\n    System.out.println(\"原值：\" + i);\n    simpType(i);\n    System.out.println(\"修改后：\" + i);\n\n    System.out.println(\"引用数据类型，未修改引用\");\n    final StringBuilder sb1 = new StringBuilder(\"123\");\n    System.out.println(\"原值：\" + sb1.toString());\n    referenceType1(sb1);\n    System.out.println(\"修改后：\" + sb1.toString());\n\n    System.out.println(\"引用数据类型，修改引用\");\n    final StringBuilder sb2= new StringBuilder(\"123\");\n    System.out.println(\"原值：\" + sb2.toString());\n    referenceType2(sb2);\n    System.out.println(\"修改后：\" + sb2.toString());\n}\n```\n\n![image-20220730124812628](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282251391.png)\n\n- 对于基本数据类型来说，值传递没有异议\n\n原始参数通过值传递给方法。这意味着对参数值的任何更改都只存在于方法的范围内。当方法返回时，参数将消失，对它们的任何更改都将丢失\n\n- 对于引用数据类型来说\n\n也就是说，引用数据类型参数(如对象)也按值传递给方法。这意味着，当方法返回时，传入的引用仍然引用与以前相同的对象。但是，如果对象字段具有适当的访问级别，则可以在方法中更改这些字段的值\n\n> 引用类型传递的时候发生了什么？\n\nvoid referenceType1(StringBuilder sb)方法\n\n<img src=\"https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282251594.png\" alt=\"image-20220730125529126\" style=\"zoom:67%;\" />\n\nvoid referenceType2(StringBuilder sb)方法\n\n<img src=\"https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282251668.png\" alt=\"image-20220730125718516\" style=\"zoom: 67%;\" />\n\n\n\n<hr>\n\n\n### java基础\n\n#### 8大基本数据类型\n\n> Java中有8种基本数据类型分为三大类。\n\n- 字符型\n\nchar\n\n- 布尔型\n\nboolean\n\n- 数值型\n\n1.整型：byte、short、int、long\n\n2.浮点型：float、double\n\n\n\n##### 取值范围\n\n> 在`java`中整数类型属于有符号类型，第一位用来表示符号0代表整数1代表负数。\n\n比如说byte类型，占1字节8位，那么他的表示范围为：\n\n最大值：0111 1111  (2^7^-1)\n\n最小值：1000 0000  (-2^7^)\n\n> 这里会有一个疑问？ 1000 0000 为什么 表示-2^7^呢？不是 -0么？\n\n第一点：在计算机中，数据的运算是以补码进行的[源码反码补码](https://juejin.cn/post/7092566574816559111)\n\n第二点：为了防止 +0 和-0的出现，约定了 补码 1000 0000代表 -128 且移除 -0概念\n\n以一个找规律的方式解释：\n\n| 原码      | 反码      | 补码         | 值（10进制） |\n| --------- | --------- | ------------ | ------------ |\n| 0111 1111 | 0111 1111 | 0111 1111    | 127          |\n| 0000 0000 | 0000 0000 | 0000 0000    | 0            |\n| ......    | ......    | ......       | ......       |\n| 1000 0001 | 1111 1110 | 1111 1111    | -1           |\n| 1000 0010 | 1111 1101 | 1111 1110    | -2           |\n| 1000 0011 | 1111 1100 | 1111 1101    | -3           |\n|           |           | 补码不断减一 |              |\n| 1111 1111 | 1000 0000 | 1000 0001    | -127         |\n| 无法表示  | 无法表示  | 1000 0000    | -128         |\n\n###### 整型\n\n> 取值范围\n\n| 数据类型 | 字节数、位数 | 范围                  |\n| -------- | ------------ | --------------------- |\n| byte     | 1字节、8位   | 【-128，127】         |\n| short    | 2字节、16位  | 【-2^15^, 2^15^-1】   |\n| Int      | 4字节、32位  | 【-2^31^  , 2^31^-1】 |\n| long     | 8字节、64位  | 【-2^63^,  2^63^-1】  |\n|          |              |                       |\n\n> 溢出问题\n\n由于整型的存储空间是有限的，那么就会存在溢出问题\n\n这是因为int只占32位\n\n0111 1111\n\n0111 1111   +\n\n-------------------------\n\n1111 1110（补）=》 1111 1101(反) =》1000 0010(原)   =  -2\n\n```java\n/**\n * 溢出问题\n */\n@Test\npublic void test2() {\n    final int value = Integer.MAX_VALUE + Integer.MAX_VALUE;\n    System.out.println(value);\n}\n```\n\n![image-20220730161454604](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282251646.png)\n\n###### 浮点数\n\n[定点数&浮点数](https://juejin.cn/post/7126230681465651230/)\n\njava为我们提供了float和double两个浮点数数据类型，分别占4字节32位和8字节64位。\n\n相较于float(单精度),double(双精度)其表示的范围更大，且精度更高。\n\n> 存储结构\n\nfloat:        1位符号位，8位指数位，23位尾数位\n\ndouble： 1位符号位，11位指数位，52位尾数位\n\n> 浮点数存在精度问题，对于金额有严格精度要求的业务，不可使用浮点数来表示金额。\n\n\n\n##### 自动装箱与拆箱\n\n> 八大基本数据类型自动装箱与自动拆箱。八大基本数据类型都有对应的对象类型，自动装箱拆箱的意思就是在需要基本数据类型需要转化为对应的包装类型的时候不需要程序员主动的去操作，而是编译器会自动帮我们去做。\n\n除了`int`对应的包装类型为`Integer`，``char`对应包装类型为`Character`外其他基本数据类型对应的包装类型都为对应基本数据类型首字母大写。\n\n> `Java`是一种面向对象的编程语言，一切皆对象，为何需要基本数据类型？\n\n基本数据类型，相较于对象类型运算简单。\n\n> 包装类型存在的意义？\n\n基本数据类型的包装类型，不仅仅只有值的概念，其扩展了额外的方法(比如equals)。且对于集合框架来说，需要的是对象类型，我们无法将基本数据类型放进去。\n\n\n\n###### 装箱&拆箱\n\n> 装箱\n\n```java\nint i = 10;\nInteger i2 = new Integer(i);\n或\nInteger i2 = Integer.valueOf(i);\n```\n\n> 拆箱\n\n```java\nInteger i = new Integer(10);\nint i2 = i.intValue();\n```\n\n\n\n###### 自动装箱拆箱\n\n> 基本数据类型在需要转化为对应包装类型的时候，无需程序员手动操作\n\n```java\nInteger i = 10;\nint i2 = i;\n```\n\n对其进行反编译可以发现确实自动帮我们转化了：\n\n![image-20220731161053533](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282251870.png)\n\n> 还有就是集合的泛型是一个对象类型，但是我们在编码的时候可以直接将基本数据类型放入，因为编译器会帮我们自动装箱。\n\n```java\nList<Integer> ints = new ArrayList<>();\nints.add(10);\n```\n\n反编译看：\n\n![image-20220731161803912](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282251026.png)\n\n###### 问题\n\n> 自动装箱与拆箱虽然给我们编码带来了方便，但也会有一些问题。\n\n- 对于基本数据类型来说，我们只关心其数值，在自动装箱过后，超过缓存范围的包装类型，必须使用equals判等。不可使用 `==`\n- 将包装类型拆箱的过程中，可能胡出现空指针异常(NPE)\n\n```java\nInteger methodRe(){\n    return null;\n}\n@Test\npublic void testRe(){\n    int i = methodRe();\n}\n```\n\n\n\n##### 基本数据类型的池化技术\n\n> 基本数据类型（除了double、float）都有缓存技术，会缓存一定范围内的对象，原因就是`jvm`认为在此范围内的对象很常用，在需要使用的时候直接去池中拿取，而无需重新创建。\n\n\n\n###### 缓存范围\n\n除了`Character`没有负数概念，其缓存范围为：【0,127】,Boolean缓存范围 {true,false}\n\n其他都是：【-128,127】\n\n> 需要注意的是Integer的缓存范围是可配置的，其他的是固定的。\n\n```java\n@Test\npublic void testCache() {\n\n    System.out.println(\"========char==========\");\n    Character c1 = 127;\n    Character c2 = 127;\n    Character c3 = 128;\n    Character c4 = 128;\n    System.out.println(c1 == c2);\n    System.out.println(c3 == c4);\n\n    System.out.println(\"========byte==========\");\n    Byte b1 = 127;\n    Byte b2 = 127;\n    Byte b3 = -128;\n    Byte b4 = -128;\n    System.out.println(b1 == b2);\n    System.out.println(b3 == b4);\n\n    System.out.println(\"========short==========\");\n    Short s1 = 127;\n    Short s2 = 127;\n    Short s3 = -129;\n    Short s4 = -129;\n    System.out.println(s1 == s2);\n    System.out.println(s3 == s4);\n\n    System.out.println(\"========int==========\");\n    Integer i1 = 127;\n    Integer i2 = 127;\n    Integer i3 = -129;\n    Integer i4 = -129;\n    System.out.println(i1 == i2);\n    System.out.println(i3 == i4);\n\n    System.out.println(\"========long==========\");\n    Long l1 = 127L;\n    Long l2 = 127L;\n    Long l3 = -129L;\n    Long l4 = -129L;\n    System.out.println(l1 == l2);\n    System.out.println(l3 == l4);\n  \n    System.out.println(\"========Boolean==========\");\n    Boolean bb1 = false;\n    Boolean bb2 = false;\n    System.out.println(bb1 == bb2);\n}\n```\n\n![image-20220731163829088](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282251176.png)\n\n\n\n###### new关键字\n\n> 特别的，如果使用`new`关键字创建包装类型，其不会存放于缓存池中，而是存放于堆内存中\n\n```java\n@Test\npublic void testCache2() {\n    Integer i1 = new Integer(128);\n    Integer i2 = 128;\n    System.out.println(i1 == i2);\n    System.out.println(\"equals方法：\" + i1.equals(i2));\n}\n```\n\n![image-20220731163644314](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282252694.png)\n\n\n\n###### 问题\n\n> 池化技术可有效的节省内存空间，但是也会给我们带来一些问题。对于基本数据类型我们一般来说只关心其数值的大小，并不会去关心其对象具体。所以说对于基本数据类型的判等一般采用equals方法，这样即便数据超过缓存范围也可以准确判断。\n\n\n\n###### 谁负责缓存\n\n> java中会有专门的类负责缓存\n\n有ByteCache用于缓存Byte对象\n\n有ShortCache用于缓存Short对象\n\n有LongCache用于缓存Long对象\n\n有CharacterCache用于缓存Character对象\n\n有IntegerCache用于缓存Integer对象\n\n\n\n##### 对于boolean属性如何命名及返回值如何定义\n\n> `Boolean`作为实体类的属性的时候如何命名？`success`or `isSuccess`?，`Boolean`作为方法返回参数的时候使用基本类型还是包装类型？\n\n\n\n###### boolean作为属性\n\n> 我们测试`Boolean`作为属性？其生成的`getter`和`setter`方法是什么样子的，对RPC框架有什么影响。\n\n存在四种情况：\n\n```java\nBoolean success;\nBoolean isSuccess;\nboolean success;\nboolean isSuccess;\n```\n\n分别举例：\n\n> 使用Lombok自动生成getter和setter方法，编译查看对应代码\n\n```java\n@Data\nclass BooleanType1{\n    boolean success;\n}\n@Data\nclass BooleanType2{\n    boolean isSuccess;\n}\n@Data\nclass BooleanType3{\n    Boolean success;\n}\n@Data\nclass BooleanType4{\n    Boolean isSuccess;\n}\n```\n\n> 编译后查看：\n\n```java\nclass BooleanType1 {\n    boolean success;\n    public boolean isSuccess() {\n        return this.success;\n    }\n    public void setSuccess(boolean success) {\n        this.success = success;\n    }\n}\nclass BooleanType2 {\n    boolean isSuccess;\n    public boolean isSuccess() {\n        return this.isSuccess;\n    }\n    public void setSuccess(boolean isSuccess) {\n        this.isSuccess = isSuccess;\n    }\n}\nclass BooleanType3 {\n    Boolean success;\n    public Boolean getSuccess() {\n        return this.success;\n    }\n    public void setSuccess(Boolean success) {\n        this.success = success;\n    }\n}\nclass BooleanType4 {\n    Boolean isSuccess;\n    public Boolean getIsSuccess() {\n        return this.isSuccess;\n    }\n    public void setIsSuccess(Boolean isSuccess) {\n        this.isSuccess = isSuccess;\n    }\n}\n```\n\n这里可以发现如果属性是基本数据类型的`boolean`生成的getter和setter方法是:isXXXX()和setXXX();\n\n如果是包装类型生成的getter和setter方法是getXXX()和setXXX()\n\n这里可以发现，如果是基本数据类型`boolean`作为属性的话，属性名success和isSuccess其对应的getter和setter方法是相同的。那么如果我们的属性名是isSuccess的话，在部分RPC框架中，得到的getter方法是isSuccess()，会误认为对应的属性名称是success，会导致获取不到属性，从而报出异常。\n\n> 所以说对于实体类如果存在Boolean数据类型的属性，使用包装类型。\n\n###### boolean对序列化的影响\n\n> 使用FastJson  JACKSON、GSON这几个常见JSON序列话对比区别。\n\n> 同样的对于基本数据类型的boolean，对不同的序列话工具会有不同的结果。而对于包装类型则没有影响。\n\nfastjson和jackson是通过反射得到所有的getter方法（getXXX或isXXXX），然后认为 XXXX就是字段名称，并得到对应的值，直接序列化成对应JSON字符串。\n\nGson则是通过反射，遍历对象对应类的属性，再序列话成json字符串。\n\n```java\n@Test\npublic void test() throws JsonProcessingException {\n\n    Gson gson = new Gson();\n    ObjectMapper om = new ObjectMapper();\n\n    BooleanType1 booleanType1 = new BooleanType1(true);\n    System.out.println(\"booleanType1\");\n    System.out.println(\"FastJson:boolean success: => \" + JSON.toJSON(booleanType1));\n    System.out.println(\"Gson:boolean success: => \" + gson.toJson(booleanType1));\n    System.out.println(\"JackSon:boolean success: => \" + om.writeValueAsString(booleanType1));\n\n    BooleanType2 booleanType2 = new BooleanType2(true);\n    System.out.println(\"booleanType2\");\n    System.out.println(\"FastJson:boolean isSuccess: => \" + JSON.toJSON(booleanType2));\n    System.out.println(\"Gson:boolean isSuccess: => \" + gson.toJson(booleanType2));\n    System.out.println(\"JackSon:boolean isSuccess: => \" + om.writeValueAsString(booleanType2));\n\n    BooleanType3 booleanType3 = new BooleanType3(true);\n    System.out.println(\"booleanType3\");\n    System.out.println(\"FastJson:Boolean success: => \" + JSON.toJSON(booleanType3));\n    System.out.println(\"Gson:Boolean success: => \" + gson.toJson(booleanType3));\n    System.out.println(\"JackSon:Boolean success: => \" + om.writeValueAsString(booleanType3));\n\n    BooleanType4 booleanType4 = new BooleanType4(true);\n    System.out.println(\"booleanType4\");\n    System.out.println(\"FastJson:Boolean isSuccess: => \" + JSON.toJSON(booleanType4));\n    System.out.println(\"Gson:Boolean isSuccess: => \" + gson.toJson(booleanType4));\n    System.out.println(\"JackSon:Boolean isSuccess: => \" + om.writeValueAsString(booleanType4));\n}\n```\n\n![image-20220801145946307](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282252654.png)\n\n> 对于boolean isSuccess 不同的JSON序列化工具，生成的JSON字符串并不是一样的。那么如果对于同一对象使用不同序列化工具序列化和反序列化会产生什么结果？\n\n```java\n@Test\npublic void testSer() throws IOException {\n\n    BooleanType2 booleanType2 = new BooleanType2(true);\n    //使用fastjson序列话\n    String jsonStr = JSON.toJSONString(booleanType2);\n    System.out.println(\"json字符串：=》\" + jsonStr);\n    //分别使用 fastJson 、 GSON  、 JackSon反序列化\n    BooleanType2 t1 = JSON.toJavaObject(JSON.parseObject(jsonStr), BooleanType2.class);\n    System.out.println(\"FastJson反序列化后=》\" + t1);\n\n    ObjectMapper om = new ObjectMapper();\n    BooleanType2 t2 = om.readValue(jsonStr, BooleanType2.class);\n    System.out.println(\"Jackson反序列化后=》\" + t2);\n\n    Gson gson = new Gson();\n    BooleanType2 t3 = gson.fromJson(jsonStr, BooleanType2.class);\n    System.out.println(\"Gson反序列化后=》\" + t3);\n}\n```\n\n![image-20220801152221308](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282252408.png)\n\n> 还是Gson出现的问题，对于同一个类，使用不同的序列化工具进行，序列话和反序列化，对象会产生前后不一致问题。\n\n同样的对于fastjson和jackson来说，会根据success通过反射来找对应得setter方法，将属性set进去。而Gson会通过反射去找success属性，发现没找打，那么就只能赋予默认值false。\n\n> 又一次证明了只能使用success而不可以使用isSuccess\n\n###### Boolean  or   boolean\n\n> 编码得时候使用Boolean  还是 boolean\n\n- 对于实体类的属性，一律使用包装类型\n- 对于远程调用的接口来说，必须使用包装类型。避免默认值的出现\n- 对于局部变量来说使用基本数据类型\n\n###### 小结\n\n> 对于布尔值如何命名和使用success还是isSuccess。\n\n第一：布尔值命名必须去掉 is\n\n第二：除了局部变量，其他地方一律使用包装类型\n\n#### String\n\n> `String`在`java`中很常用，看似简单，也有很多知识点。\n\n##### 不可变性\n\n对象的不可变性指的是什么？\n\n对象的不可变性指的是在对象创建完成，我们不可以调用方法来修改其属性。\n\n\n\n######  现象\n\n> 在编程中我们常常通过等号和加号来\"修改\"字符串的值，为什么还是不可变得呢？\n\n比如：\n\n```java\nString str1 = \"abc\";\nstr1 = \"123\";\n//\nString str1 = \"abc\";\nstr1 += \"123\"; \n```\n\n这不是修改了么？\n\n> 这里两种方式好像都修改了str1的值，其实是修改了str1的引用，将str1指向了一个新的字符串对象。\n>\n> 对于字符串相加，回收先得到相加后的结果，创建对应字符串，然后赋予引用。\n\n图示：\n\n<img src=\"https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282252745.png\" alt=\"image-20220731210311597\" style=\"zoom:67%;\" />\n\n<img src=\"https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282252053.png\" alt=\"image-20220731210337273\" style=\"zoom:67%;\" />\n\n\n\n###### String为什么是不可变的\n\n> 简单理解一下为什么String不可变\n\n打开`String`类的源码，可以发现`String`底层是一个字符数组，且该属性被`final`修饰：\n\n```java\nprivate final char value[];\n```\n\n那么此刻自然就想到被`final`修饰的对象不可变。\n\n> 其实被`final`修饰的对象不可变指的是，不可以修改其引用，如果说我可以通过调用对象提供的修改方法那么完全是可以修改的。\n\n\n\n那么String类不可变的真正原因是什么呢？\n\n- 首相String类被final修饰，也就是不可以被继承，我们知道继承及侵入式的，不可以继承那么就没有子类可以破坏其不可变性。（不仅仅是String八大基本数据类型的包装类型都是fianl的）\n- String类底层是一个字符数组，其作为String的属性，被private修饰，也就是不提供外部访问\n- String类底层是一个字符数组，其作为String的属性，被final修饰，不可修改字符数组引用\n- 最后一点也是最重要的，String类中未提供任何修改其字符数组的方法（无论是私有的还是公开的），其内部方法返回的都是一个String\n\n\n\n###### String真的不可变吗\n\n> 我们直到`Java`提供了一个很强大的机制，就是反射，那么我们是否可以通过反射来破坏String底层数组的private和final呢？\n\n写一个测试案例：可以通过反射来修改被fianl修饰的属性\n\n```java\n@Test\npublic void testFinal() throws NoSuchFieldException, IllegalAccessException {\n  TestFinal testFinal = new TestFinal();\n  System.out.println(testFinal.sb + \":\" + VM.current().addressOf(testFinal.sb));\n  final Field sb = testFinal.getClass().getDeclaredField(\"sb\");\n  final StringBuilder abc = new StringBuilder(\"abc\");\n  //反射破坏不可修改\n  sb.setAccessible(true);\n  sb.set(testFinal, abc);\n  System.out.println(testFinal.sb + \":\" + VM.current().addressOf(testFinal.sb));\n}\nclass TestFinal {\n    final StringBuilder sb = new StringBuilder(\"123\");\n}\n```\n\n结果很意外，被final修饰的属性其值可以被改变，且其内存地址也发生了改变，也就是sb的引用也别修改了\n\n![image-20220731214248215](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282252499.png)\n\n同理我们尝试修改String的字符数组：\n\n```java\n/**\n * 我们都知道String其内部是字符数组，且是私有的，那么我们是否可以通过反射修改其私有属性\n */\n@Test\npublic void test3() throws NoSuchFieldException, IllegalAccessException {\n    String str = \"123\";\n    System.out.println(str + \":\" + VM.current().addressOf(str));\n\n    final Field value = str.getClass().getDeclaredField(\"value\");\n    value.setAccessible(true);\n    value.set(str, \"abc\".toCharArray());\n    System.out.println(str + \":\" + VM.current().addressOf(str));\n\n    String str2 = \"123\";\n    System.out.println(str2 + \":\" + VM.current().addressOf(str2));\n\n    String str3 = \"abc\";\n    System.out.println(str3 + \":\" + VM.current().addressOf(str3));\n}\n```\n\n> 结果有令人很惊讶\n\n- 可以修改String的属性字符数组的值，且不会修改其引用\n- String str2 = \"123\";为何值为”abc“，这里我只能猜测，String的缓存池中记录着这么一个 ”123“字符串，但是其内部的字符数组指向的是['a','b','c']\n\n![image-20220731215113520](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282252628.png)\n\n\n\n###### String为什么设计成不可变的\n\n> \n\n\n\n- 缓存池\n\n  > String是很常用的，为了避免频繁创建相同的字符串，JVM特地在堆内存中开辟了一块空间叫字符串缓存池，专门用于缓存已创建的字符串。\n\n  如果说需要的字符串在缓存池中存在，那么直接去缓存池中取即可，不用再去创建。\n\n- 安全\n\n  > 字符串用于存储的内容还是很广泛的，密码、url、账号信息等等，如果说String可以很容易的被改变，那么整个系统奖没有可信度可言了。\n\n- 线程安全\n\n  > 线程安全性问题，只出现在可修改的数据上，String不可变那么自动保证线程安全。\n\n- 拷贝安全\n\n  > 我们知道在深拷贝的时候，需要考虑对象属性的拷贝，以不影响原型对象，而String不可变在拷贝的时候无需考虑他的拷贝。\n\n- hash缓存\n\n  > 当字符串作为哈希实现的key值的时候。在对这些散列实现进行操作时，经常调用hashCode()方法。\n  >\n  > 不可变性保证了字符串的值不会改变，其哈希值也不会变，只有在首次哈希的时候会计算哈希值，之后会直接去取已计算的哈希值。\n\n  ```java\n  /** Cache the hash code for the string */\n  private int hash; // Default to 0\n  public int hashCode() {\n      int h = hash;\n      if (h == 0 && value.length > 0) {\n          char val[] = value;\n          for (int i = 0; i < value.length; i++) {\n              h = 31 * h + val[i];\n          }\n          hash = h;\n      }\n      return h;\n  }\n  ```\n\n###### 小结\n\n> 以上提到的String的缓存池技术，hashCode()缓存技术，都旨在与提高性能，因为String是非常常用的数据类型，对于它的性能即便是小小的提升，映射到整个java生态中，也是庞大的提升。\n\n\n\n##### substring\n\n> 介绍subString方法的原理，以及在jdk6和jdk6之后版本中的不同之处，jdk6中的substring方法的问题\n\n\n\n###### JDK6中substring的实现原理\n\n> String底层是一个字符数组，在jdk6中String有三个成员变量：`char value[]` `int offset` `int count`。分别表示字符数组、起始下标、字符个数。\n\n```java\nString(int offset, int count, char value[]) {\n    this.value = value;\n    this.offset = offset;\n    this.count = count;\n}\n\npublic String substring(int beginIndex, int endIndex) {\n    //check boundary\n    return  new String(offset + beginIndex, endIndex - beginIndex, value);\n}\n```\n\n在调用substring方法的时候会返回一个新的string对象，但其内部的字符数组引用任然指向原堆中的字符数组，只不过其实下标和字符数量不同。\n\n图示：\n\n![image-20220731235844909](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282252536.png)\n\n\n\n###### JDK6中substring存在的问题\n\n> 由于截取的字符串和原字符串引用的是同一个字符数组，如果原字符串很大，但是截取的部分很小，那么就会导致，原来很长的字符串所指向的字符数组即便不会使用也一直会被引用，就会无法回收，导致内存泄漏。 还有就是效率问题，我只需要截取一小段，却引用了整个字符数组。\n>\n> 解决方式是截取后的字符串重新创建一个字符串。\n\n```java\nx = x.substring(x, y) + \"\"\n```\n\n\n\n###### jdk7对于sbustring的优化\n\n> 优化方式是调用sbustring方法生成的字符串其内部字符数组的引用，指向一个新创建的字符数组。\n\n```java\n//JDK 7\npublic String(char value[], int offset, int count) {\n    //check boundary\n    this.value = Arrays.copyOfRange(value, offset, offset + count);\n}\n\npublic String substring(int beginIndex, int endIndex) {\n    //check boundary\n    int subLen = endIndex - beginIndex;\n    return new String(value, beginIndex, subLen);\n}\n```\n\n![image-20220801000754715](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282252644.png)\n\n\n\n##### replcae\n\n```java\n//将所有的replacement字符替换为target字符\npublic String replace(CharSequence target字符, CharSequence replacement) {\n    return Pattern.compile(target.toString(), Pattern.LITERAL).matcher(\n            this).replaceAll(Matcher.quoteReplacement(replacement.toString()));\n}\n//将所有的replacement字符串替换为target字符串\npublic String replaceAll(String regex, String replacement) {\n    return Pattern.compile(regex).matcher(this).replaceAll(replacement);\n}\n//将首个replacement字符串替换为target字符串\npublic String replaceFirst(String regex, String replacement) {\n    return Pattern.compile(regex).matcher(this).replaceFirst(replacement);\n}\n```\n\n\n\n##### 字符串拼接\n\n\n\n###### 通过+拼接\n\n> 字符串通过`+`拼接的原理\n\n```java\npublic void test1() {\n  String str1 = \"abc\" + \"123\";\n  System.out.println(str1);\n}\n\nvoid method(String str1, String str2) {\n  final String strX = str1 + \",\" + str2;\n}\n```\n\n反编译后：\n\n```java\npublic void test1() {\n  String str1 = \"abc123\";\n  System.out.println(str1);\n}\n\nvoid method(String str1, String str2) {\n  (new StringBuilder()).append(str1).append(\",\").append(str2).toString();\n}\n```\n\n- 对于编译时期就知道字面量的字符串，进行常量折叠\n- 对于编译器不确定的变量，会使用StringBuilder.append拼接\n\n\n\n###### 通过concat拼接\n\n> 会重新生成一个字符串对象，其内部的字符数组也是通过ArrayCopy新拷贝出来的。\n\n```java\npublic String concat(String str) {\n    int otherLen = str.length();\n    if (otherLen == 0) {\n        return this;\n    }\n    int len = value.length;\n    char buf[] = Arrays.copyOf(value, len + otherLen);\n    str.getChars(buf, len);\n    return new String(buf, true);\n}\n```\n\n\n\n###### StringBuffer&StringBuilder\n\n> 可以使用在这两类对字符串进行拼接，最后toString返回即可\n\n###### 第三方工具类\n\n> StringUtils，可以使用Spring提供的也可以是apache提供的，都是一个用法，将一个String数组或集合，以某个字符分割拼接\n\n```java\n@Test\npublic void testAppendByUtil(){\n    String[] value = {\"hello\", \"你好\", \"hello\"};\n    String result = StringUtils.join(value, \",\");\n    System.out.println(result);\n}\n```\n\nhello,你好,hello\n\n\n\n###### String的join方法\n\n\n\n```java\n@Test\npublic void testAppendByStr(){\n    String join = String.join(\",\", \"hello\", \"你好\", \"hello\", \"4\");\n    System.out.println(join);\n}\n```\n\nhello,你好,hello,4\n\n\n\n###### 性能对比\n\n```java\n@Test\npublic void testAppend() {\n    StopWatch stopWatch = new StopWatch();\n    stopWatch.start(\"使用+拼接字符串\");//任务说明\n    String str1 = \"\";\n    for (int i = 0; i < 50000; i++) {\n        //str1 += \"a\";  拼接代码\n    }\n    stopWatch.stop();\n    System.out.println(stopWatch.getLastTaskName() +\"消耗时长：\"+stopWatch.getTotalTimeNanos());\n}\n```\n\n```java\n使用+拼接字符串消耗时长：1942387300\n使用StringBuilder拼接字符串消耗时长：2846001\n使用StringBuffer拼接字符串消耗时长：4217800\n使用concat拼接字符串消耗时长：5055200\n使用StringUtils  join拼接字符串消耗时长：39924299\n```\n\n结果是：StringBuilder > StringBuffer  >  concat> StringUtils > `+`\n\n> StringBuffer  append方法基于StringBuilder实现，同时也是同步的，性能差一点点。\n\n> concat每次循环，都会进行数组拷贝，创建新字符串，性能差点。但也是为了保证字符串的不可变性\n\n> StringUtils底层使用的StringBuilder实现，拼接过程存在很多其他操作，回去判断对象是否为空等，性能也差点\n\n> `+`号是我们很常用的，性能却最差，这是为什么呢？\n\n查看使用`+`拼接字符串的反编译后的代码：\n\n> 发现每次循环都会new一个StringBuilder出来，再进行append，性能自然不会很高了。频繁的创建对象，也是对内存资源的浪费。\n\n```java\nvoid append1() {\n    StopWatch stopWatch = new StopWatch();\n    stopWatch.start(\"使用+拼接字符串\");\n    String str1 = \"\";\n    for (int i = 0; i < 50000; i++) {\n        str1 += \"a\";\n    }\n    stopWatch.stop();\n    System.out.println(stopWatch.getLastTaskName() + \"消耗时长：\" + stopWatch.getTotalTimeNanos());\n}\n```\n\n```java\nvoid append1()\n{\n    StopWatch stopWatch = new StopWatch();\n    stopWatch.start(\"\\u4F7F\\u7528+\\u62FC\\u63A5\\u5B57\\u7B26\\u4E32\");\n    String str1 = \"\";\n    for(int i = 0; i < 50000; i++)\n        str1 = (new StringBuilder()).append(str1).append(\"a\").toString();\n\n    stopWatch.stop();\n    System.out.println((new StringBuilder()).append(stopWatch.getLastTaskName()).append(\"\\u6D88\\u8017\\u65F6\\u957F\\uFF1A\").append(stopWatch.getTotalTimeNanos()).toString());\n}\n```\n\n###### 小结\n\n> 对于循环体内字符串的拼接禁止使用`+`，采用`StringBuilder`的`append`的方式进行字符串拼接。有并发需求时，使用`StringBuffer`代替`StringBuilder`。\n\n\n\n##### StringBuffer & StringBuilder\n\n> String是不可变的，java还为我们提供了两个可变的用于操作字符串的类，StringBuffer  & StringBuilder\n\nStringBuilder和StringBuilder都是AbstractStringBuilder的子类。底层也是字符数组，使用一个成员变量count来表示字符数组已使用的字符数。\n\n```java\nchar[] value;\n\nint count;\n```\n\n> StringBuilder是非线程安全的，StringBuffer是线程安全的（使用Synchronized保证）。\n\n\n\n\n\n##### String.valueOf  & Intege.toString\n\n> 将一个`Integer`转化为`String`有几种方式？\n\n```java\n@Test\npublic void test(){\n    int i = 10;\n    String str1 = i + \"\";\n    String str2 = Integer.valueOf(i).toString();\n    String str3 = String.valueOf(10);\n}\n```\n\n> 第一种方式使用`StringBuilder`\n\n```java\nString str1 = (new StringBuilder()).append(i).append(\"\").toString();\n```\n\n> 第二种和第三种都是使用`Integer.toString()`\n\n\n\n##### switch支持String\n\n> jdk7之后`switch`添加了对`String`的支持。\n>\n> `switch`目前支持的类型有Character, Byte, Short, Integer, String, or an enum，`switch`真正意义上只支持整型，对于`Character`会转化成ASCII码，ASCII是一个`int`类型的数据。`String`会优先通过`hashCode`判断，然后再通过`equals`进行安全检查，`hashCode`也是`int`类型的\n\n###### int&short&byte\n\n代码：\n\n```java\n@Test\npublic void testInt() {\n    int i = 10;\n    switch (i) {\n        case 1:\n            System.out.println(1);\n            break;\n        case 2:\n            System.out.println(2);\n            break;\n        case 3:\n            System.out.println(3);\n            break;\n        default:\n            System.out.println(i);\n    }\n}\n```\n\n反编译查看：\n\n> 没什么特别的，switch对int支持很好。对Short和byte也是一样的，不支持long\n\n```java\npublic void testInt()\n{\n    int i = 10;\n    switch(i)\n    {\n    case 1: // '\\001'\n        System.out.println(1);\n        break;\n\n    case 2: // '\\002'\n        System.out.println(2);\n        break;\n\n    case 3: // '\\003'\n        System.out.println(3);\n        break;\n\n    default:\n        System.out.println(i);\n        break;\n    }\n}\n```\n\n\n\n###### char\n\n代码：\n\n```java\n@Test\npublic void testChar() {\n    char c = 'a';\n    switch (c) {\n        case 'a':\n            System.out.println('a');\n            break;\n        case 'b':\n            System.out.println('b');\n            break;\n        case 'c':\n            System.out.println('c');\n            break;\n        default:\n            System.out.println(c);\n    }\n}\n```\n\n反编译查看：\n\n> 会将char转化成对应的ascii码值，再通过整型switch\n\n```java\npublic void testChar()\n{\n    char c = 'a';\n    switch(c)\n    {\n    case 97: // 'a'\n        System.out.println('a');\n        break;\n    case 98: // 'b'\n        System.out.println('b');\n        break;\n    case 99: // 'c'\n        System.out.println('c');\n        break;\n    default:\n        System.out.println(c);\n        break;\n    }\n}\n```\n\n\n\n###### string\n\n代码：\n\n```java\n@Test\npublic void testString() {\n    String str = \"abc\";\n    switch (str) {\n        case \"abc\":\n            System.out.println(\"a\");\n            break;\n        case \"bac\":\n            System.out.println(\"b\");\n            break;\n        case \"cab\":\n            System.out.println(\"c\");\n            break;\n        default:\n            System.out.println(str);\n    }\n}\n```\n\n反编译查看：\n\n> 发现首先获取哈希值，哈希值是整型，然后进行switch，最后使用equals进行安全判断。\n\n```java\npublic void testString()\n{\n    String str = \"abc\";\n    String s = str;\n    byte byte0 = -1;\n    switch(s.hashCode())\n    {\n    case 96354: \n        if(s.equals(\"abc\"))\n            byte0 = 0;\n        break;\n\n    case 97284: \n        if(s.equals(\"bac\"))\n            byte0 = 1;\n        break;\n\n    case 98244: \n        if(s.equals(\"cab\"))\n            byte0 = 2;\n        break;\n    }\n    switch(byte0)\n    {\n    case 0: // '\\0'\n        System.out.println(\"a\");\n        break;\n\n    case 1: // '\\001'\n        System.out.println(\"b\");\n        break;\n\n    case 2: // '\\002'\n        System.out.println(\"c\");\n        break;\n\n    default:\n        System.out.println(str);\n        break;\n    }\n}\n```\n\n\n\n##### 字符串缓存池\n\n> 创建字符串的方式有以下两种方式:\n\n```java\n@Test\npublic void testStrCache(){\n    String str1 = \"abc\";\n    String str2 = new String(\"abc\");\n}\n```\n\n- 第一种方式通过\"字面量\"的形式赋值，字符串如果在缓存池中不存在，则会创建并放入缓存池\n- 第二种方式会将字符串对象当作一个普通的对象类型，放在堆内存中\n\n> 当我们使用字面量创建字符串的时候，jvm会对此字符串进行检查，如果该字符串在缓存池中不存在，则会创建该字符串，并将其放入字符串缓存池；如果该字符串存在，那么直接将缓存池中的字符串对象的引用返回。\n\n```java\n@Test\npublic void testStrCache2(){\n    String str1 = \"abc\";\n    String str2 = String.valueOf(\"abc\");//String.valueOf也是字面量，调用toString方法直接返回\n    String str3 = \"abc\";\n    System.out.println(str1 == str2);//true\n    System.out.println(str2 == str3);//true\n    System.out.println(str1 == str3);//true\n}\n```\n\n\n\n> 字符串缓存池在内存中的哪个位置\n\njdk7之前，字符串缓存池在永久代中。\n\njdk7中，由于后续版本计划通过元空间代替永久代，所以先将字符串缓存池从永久代移出，暂时放入堆内存。\n\njdk8中，彻底废除了永久代，使用元空间代替永久代，字符串常量池从堆内存，移动到永久代。\n\n##### String长度限制？\n\n> `String`存不存在长度限制呢？\n\n- 在编译期间不可以超过 2^16^-1 = 65535\n\n  也就是我们在使用字面量对字符串赋值的时候如果字符串长度大于等于65535，就通过不了编译\n\n- 运行期间限制：不能超过int的范围\n\n\n\n#### java中的各种关键字\n\n\n\n##### transient\n\n> 短暂瞬时的意思，java提供的关键字，用于修饰成员变量。如果一个变量被`transient`修饰，当对象需要序列化传输、或存储时，会忽略该变量。\n>\n> 当我们不希望对象的某个变量需要被序列化的时候，比如我们定义一个变量，该变量我们只希望它在当前系统中使用，而不希望他在上下游系统传输，可以使用`transient`修饰。\n\n被transient修饰的引用类型也就是对象类型，在被反序列化的时候初始化为null，基本数据类型为默认值int就是0。\n\n> 创建一个对象，注意需要实现序列化接口支持序列化操作。如果存在特殊需求可以重写writeObjec方法和readObject方法。\n\n```java\n@Data\nclass TransientTestClass implements Serializable {\n    private static final long serialVersionUID = 9167810647635375505L;\n  \n    private String str;\n    private Integer value;\n    private transient String name;\n    private transient int age;\n}\n```\n\n> 将对象序列化持久化到本地\n\n```java\nString filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile\";\n\n@Test\npublic void test1() throws IOException {\n    final TransientTestClass transientTestClass = new TransientTestClass();\n    transientTestClass.setName(\"element\");\n    transientTestClass.setStr(\"element\");\n    transientTestClass.setValue(123);\n    //序列化到文件\n    final ObjectOutputStream objectOutputStream = new ObjectOutputStream(\n            new FileOutputStream(new File(filePath, transientTestClass.getClass().getName())));\n    objectOutputStream.writeObject(transientTestClass);\n    objectOutputStream.flush();\n    objectOutputStream.close();\n}\n```\n\n> 再通过反序列化将文件中的对象读出来，查看其属性值\n\n```java\n/**\n * 读出来，使用对象接收看看\n */\n@Test\npublic void test2() throws IOException, ClassNotFoundException {\n    final ObjectInputStream objectInputStream = new ObjectInputStream(\n            new FileInputStream(new File(filePath, TransientTestClass.class.getName())));\n    TransientTestClass transientTestClass = (TransientTestClass) objectInputStream.readObject();\n    System.out.println(transientTestClass);\n}\n```\n\n> 结果也如我们说的一样\n\n![image-20220801235653264](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282252970.png)\n\n##### instanceof\n\n> java关键字，类似于一个二元操作符，用于判断`instanceOf`左右两边对象类型是否一致。\n\n```java\n@Test\npublic void test() {\n    System.out.println(InstanceofTest.class instanceof Object);\n    System.out.println(\"InstanceofTest.class\" instanceof String);\n    System.out.println(Integer.valueOf(10) instanceof Integer);\n\n    Object o = Integer.valueOf(10);\n    System.out.println(o instanceof String);\n}\n```\n\n![image-20220802000331345](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282252444.png)\n\n\n\n##### synchronized\n\n[synchronized](https://juejin.cn/post/7077457448290189348)\n\n> 后续重点看\n\n\n\n##### volatile\n\n[volatile](https://juejin.cn/post/7077459563963908109)\n\n> 后续重点看\n\n\n\n##### final\n\n[final](https://juejin.cn/post/7077469542946979847)\n\n> `final`是`java`提供的关键字，表示该部分不可修改，可修饰类、方法、变量。\n\n######  final修饰类\n\n> final 修饰类表示该类不可以被继承。一般是类的自我保护，不希望子类对父类造成破坏。\n\n> 比如说`String`和八大基本数据类型的包装类型\n\n\n\n###### final修饰方法\n\n> 表示该方法不可以被子类重写，但是可以在本类中重载。\n\n\n\n###### final修饰变量\n\n> 被final修饰的变量如果是基本数据类型则其不可变，如果是引用数据类型则其引用地址不可变。\n\n> 作为局部变量\n\n不管是引用类型还是基本数据类型，都不可以使用等号赋值。但是如果引用数据类型存在修改方法的时候是可以修改对象的引用的。\n\n```java\n@Test\npublic void test01() {\n    final StringBuilder sb = new StringBuilder(\"abc\");\n    final int i = 10;\n    sb.append(\"123\");\n    System.out.println(sb.toString());\n}\n```\n\n\n\n> 作为成员变量\n\n```java\nclass MemberField {\n    /**\n     * 被static final修饰，属于类不可变。必须1、在声明的时候赋值 2、或static代码块中赋值\n     */\n    static final StringBuilder sb1 = new StringBuilder();\n    /**\n     * 被final修饰，属于实例，不可变。必须1、在声明的时候赋值 2、非static代码块中赋值 3、构造方法赋值\n     */\n    final StringBuilder sb2 ;\n    {\n        sb2 = new StringBuilder();\n    }\n}\n```\n\n\n\n##### static\n\n> 用于修饰成员变量、方法或代码块，被static修饰的成员变量称为静态成员变量或类变量属于类，被static修饰的代码块称为静态代码块。\n\n###### 静态成员变量\n\n> 也称为类变量，它不属于类的某个实例，它被所有该类的实例共享，因此存在线程安全问题。\n>\n> 如果类变量没有被private修饰，可以使用”类名.变量名“的方式访问。\n\n###### 静态方法\n\n> 和静态变量一样，静态方法也属于类，以`类名 。方法名`调用，在此期间不必创建类的实例，因此会方便许多。\n\n> 比如说集合工具类返回空集合Collections.emptyList();\n\n> java8支持在接口中定义静态方法\n\n```java\ninterface IStaticMethod{\n    static void method1() {\n        Collections.emptyList();\n    }\n    default void method2(){\n    }\n}\n```\n\n\n\n###### 静态代码块\n\n> 静态代码块会在类初始化的时候，将所有静态代码组合成一个`cinit<>`方法，由类加载器执行。一个类在其一个生命周期内只加载一次，所以说对于静态代码块，在类生命周期中只执行一次。\n\n```java\npublic class AboutStatic {  \n    static int a;\n    static {\n        a = 1;\n        System.out.println(\"静态代码块执行\");\n    }\n    {\n        System.out.println(\"非静态代码块执行\");\n    }\n    public static void main(String[] args) {\n        for (int i = 0; i < 100; i++) {\n            new AboutStatic();\n        }\n    }\n}\n```\n\n<img src=\"https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282252302.png\" alt=\"image-20220802164043054\" style=\"zoom:67%;\" />\n\n###### 静态类\n\n> 静态内部类定义于普通类内部，可以和普通类一样使用。\n>\n> 下面列出类：内部类、静态内部类和匿名内部类写法\n\n```java\npublic class AboutStaticClass {\n    static class StaticClass {\n        int a;\n        static int b;\n    }\n    class InnerClass {\n        int a;\n        //不可以定义静态变量\n        //static int b;\n    }\n    void method() {\n        AboutStaticClass.InnerClass innerClass = new AboutStaticClass.InnerClass();\n    }\n    //匿名内部类写法\n     IInterface ia = new IInterface() {\n        @Override\n        public void method() {\n        }\n    };\n}\nclass TestClass {\n    public static void main(String[] args) {\n        AboutStaticClass.StaticClass staticClass = new AboutStaticClass.StaticClass();\n        System.out.println(AboutStaticClass.StaticClass.b);\n    }\n}\n@FunctionalInterface\ninterface IInterface{\n    void method();\n}\n```\n\n##### const\n\n> const和final相似，用于后期扩展。\n\n\n\n#### 枚举\n\n> 枚举类型是java5引入的，由一组固定常量组成的合法类型。\n\n##### 在枚举引入之前如何定义一组常量\n\n> java在枚举引入之前，我们一般会用一组int常量值，来表示一组固定的数据。比如使用1、2、3、4来表示春、夏、秋、冬。\n\n```java\n/**\n * 枚举类型一般会被系统共享，所以其访问修饰符一般为public\n */\nclass Season {\n    public static final int SPRING = 1;\n    public static final int SUMMER = 2;\n    public static final int AUTUMN = 3;\n    public static final int WINTER = 4;\n}\n```\n\n> 可以根据传入的int值来判断对应季节\n\n```java\n@Test\npublic void test1() {\n    final int spring = Season.SPRING;\n    season(spring);\n}\npublic void season(int value) {\n    switch (value) {\n        case 1:\n            System.out.println(\"春天\");\n            break;\n        case 2:\n            System.out.println(\"夏天\");\n            break;\n        case 3:\n            System.out.println(\"秋天\");\n            break;\n        case 4:\n            System.out.println(\"冬天\");\n            break;\n        default:\n            System.out.println(\"输入不合法\");\n            break;\n    }\n}\n```\n\n这种方法称作int枚举模式。存在一些安全问题，就如上面判断季节的方法，default分支是我们不愿意看到的场景，如果说我们不加校验可能会产生问题。并且Season这个类打印出来的也只是一个int值1、2、3、4，表面并不能看出任何的意思。所以说int枚举模式他的安全性和可读性是不可观的。\n\n> 当然了我们也可以使用字符串作为枚举值，但是字符串的比较算法相对来说比较浪费性能，也是不可取的。\n\n\n\n##### 定义枚举\n\n> 由于int枚举和字符串枚举存在着缺陷，java5引入了枚举类型`enum type`，接下来我们看如何定义一个枚举。\n\n使用enum声明一个枚举，在枚举类中列举枚举值，使用逗号隔开，尾部使用分号结尾。\n\n```java\nenum Season2 {\n    SPRING, SUMMER, AUTUMN, WINTER;  \n}\n```\n\n并且我们还可以为枚举定义属性：\n\n```java\n@AllArgsConstructor\nenum Season3 {\n    SPRING(1, \"春天\"),\n    SUMMER(1, \"春天\"),\n    AUTUMN(1, \"春天\"),\n    WINTER(1, \"春天\");\n    int code;\n    String msg;\n}\n```\n\n##### 特点\n\n- 简约\n- 和普通class类一样，枚举类可以单独存在，也可以存在于其他java类中\n- 枚举类可以实现接口\n- 也可以定义新的属性和方法\n\n\n\n##### switch对于枚举的支持\n\n> 使用枚举改造上面代码\n\n```java\npublic void seasonUseEnum(Season2 season) {\n    System.out.println(Season2.SPRING);\n    switch (season) {\n        case SPRING:\n            System.out.println(\"春天\");\n            break;\n        case SUMMER:\n            System.out.println(\"夏天\");\n            break;\n        case AUTUMN:\n            System.out.println(\"秋天\");\n            break;\n        case WINTER:\n            System.out.println(\"冬天\");\n            break;\n        default:\n            System.out.println(\"输入不合法\");\n            break;\n    }\n}\n\n@Test\npublic void test2() {\n    seasonUseEnum(Season2.SPRING);\n}\n```\n\n> 如此判断季节的方法对于传入参数存在类型限制，不会再有不合法参数的出现。一般来说我们会对枚举添加表示域的属性和对应的描述，方便统一管理。\n\n```java\npublic void seasonUseEnum(Season3 season) {\n    System.out.println(Season2.SPRING);\n    final StringBuilder sb = new StringBuilder();\n    switch (season) {\n        case SPRING:\n        case WINTER:\n        case AUTUMN:\n        case SUMMER:\n            sb.append(season.msg);\n            break;\n        default:\n            System.out.println(\"输入不合法\");\n            break;\n    }\n    System.out.println(sb.toString());\n}\n@Test\npublic void test3() {\n    seasonUseEnum(Season3.SPRING);\n}\n```\n\n\n\n###### jad查看原理\n\n> 可以使用jad 反编译一下，查看一下底层原理\n\n可以得出如下结论：\n\n- 枚举类经过编译器编译后会被当作普通类处理，继承自 `java.lang.Enum`\n- 每一个枚举项是一个 `final static`的成员变量。天生是一个单例\n\n\n\n```java\nfinal class Season3 extends Enum\n{\n    private Season3(String s, int i, int code, String msg)\n    {\n        super(s, i);\n        this.code = code;\n        this.msg = msg;\n    }\n    public static final Season3 SPRING;\n    public static final Season3 SUMMER;\n    public static final Season3 AUTUMN;\n    public static final Season3 WINTER;\n    int code;\n    String msg;\n    private static final Season3 $VALUES[];\n    static \n    {\n        SPRING = new Season3(\"SPRING\", 0, 1, \"\\u6625\\u5929\");\n        SUMMER = new Season3(\"SUMMER\", 1, 1, \"\\u6625\\u5929\");\n        AUTUMN = new Season3(\"AUTUMN\", 2, 1, \"\\u6625\\u5929\");\n        WINTER = new Season3(\"WINTER\", 3, 1, \"\\u6625\\u5929\");\n        $VALUES = (new Season3[] {\n            SPRING, SUMMER, AUTUMN, WINTER\n        });\n    }\n}\n```\n\n> 但是要想知道switch对枚举的支持的原理，其实就在构造函数内，会调用super(s,i)。s是String类型为枚举项的字段名称，i为自动生成的编号。\n>\n> 我们使用jad对switch相关代码反编译一下：\n\n- 首先枚举类中的每一个枚举都是一个单例对象，在使用new 关键字创建实例的时候会为各个实例添加一个编号 ordinal\n- 在引用了枚举类的类中，会在static代码块中初始化一个int类型的数组，用于描述各个枚举值对应的编号\n- switch还是对int做操作\n\n```java\n {\n     static final int $SwitchMap$com$roily$booknode$javatogod$_01faceobj$javakeywords$aboutenum$Season3[];\n     static \n     {\n         $SwitchMap$com$roily$booknode$javatogod$_01faceobj$javakeywords$aboutenum$Season3 = new int[Season3.values().length];\n         $SwitchMap$com$roily$booknode$javatogod$_01faceobj$javakeywords$aboutenum$Season3[Season3.SPRING.ordinal()] int= 1;\n         $SwitchMap$com$roily$booknode$javatogod$_01faceobj$javakeywords$aboutenum$Season3[Season3.WINTER.ordinal()] = 2;\n         $SwitchMap$com$roily$booknode$javatogod$_01faceobj$javakeywords$aboutenum$Season3[Season3.AUTUMN.ordinal()] = 3;\n         $SwitchMap$com$roily$booknode$javatogod$_01faceobj$javakeywords$aboutenum$Season3[Season3.SUMMER.ordinal()] = 4;\n     }\n }\npublic void seasonUseEnum(Season3 season)\n{\n    System.out.println(Season2.SPRING);\n    StringBuilder sb = new StringBuilder();\n    switch(_cls1..SwitchMap.com.roily.booknode.javatogod._01faceobj.javakeywords.aboutenum.Season3[season.ordinal()])\n    {\n    case 1: // '\\001'\n    case 2: // '\\002'\n    case 3: // '\\003'\n    case 4: // '\\004'\n        sb.append(season.msg);\n        break;\n    default:\n        System.out.println(\"\\u8F93\\u5165\\u4E0D\\u5408\\u6CD5\");\n        break;\n    }\n}\n```\n\n##### 枚举是单例的最佳实践\n\n> 单例的实现方式存在很多，懒汉式、饿汉式、双重检验锁、静态内部类、枚举\n\n单例的设计主要考虑两个问题：\n\n- 延时加载\n\n  > 在希望使用的时候才进行单例创建，在未正真使用不创建。那么双重检验锁、静态内部类符合需求\n\n- 线程安全\n\n  > 单例实现的复杂问题在于需要考虑线程安全问题，同时兼虑性能。懒汉式非线程安全。\n\n1、懒汉式可实现，但非线程安全\n\n2、饿汉式不行，饿汉式单例的创建由类加载器实现，但线程安全\n\n3、懒汉式配合Synchronized可实现，但影响性能(会对访问单例也进行加锁操作,但访问是没有线程安全问题的)\n\n4、双重检验锁可延时加载：是对懒汉式+锁机制的优化。避免读时加锁\n\n5、静态内部类可实现且线程安全，也是类加载器保证的线程安全\t\n\n###### 为何枚举是单例的最佳实现？\n\n- 枚举天生单例，且线程安全，枚举作为内部类可实现延时加载。\n- 枚举可避免序列化、或反射 破坏单例 （枚举的序列化是定制的，序列化时会将枚举项名记录，反序列化时会根据枚举项名称找到对应枚举项）\n\n以上编写枚举反编译查看枚举中的每一个枚举项都被final static 修饰，且在static代码块中初始化，这也就是饿汉式单例的实现。\n\n###### 尝试使用反射破坏单例\n\n我们知道单例的实现，重点在于构造函数私有化，并提供获取实例的方法，那么我们就来破坏构造方法的私有性\n\n首先写一个单例类：\n\n```java\npublic class SingleDemo implements Serializable {\n    private static final long serialVersionUID = -6489201409969990006L;+\n    private static SingleDemo singleDemo;\n    //构造方法私有化\n    private SingleDemo() {\n    }\n    public static SingleDemo getInstance() {\n        if (null == singleDemo){\n            singleDemo = new SingleDemo();\n        }\n        return singleDemo;\n    }\n}\n```\n\n```java\n@Test\npublic void testSingle() {\n    final SingleDemo instance1 = SingleDemo.getInstance();\n    final SingleDemo instance2 = SingleDemo.getInstance();\n    System.out.println(instance1 == instance2);\n}\n```\n\n![image-20220826013226826](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282253867.png)\n\n反射破坏单例：\n\n```java\nfinal SingleDemo instance1 = SingleDemo.getInstance();\nfinal Constructor<? extends SingleDemo> declaredConstructor = instance1.getClass().getDeclaredConstructor();\ndeclaredConstructor.setAccessible(true);\nfinal SingleDemo singleDemo = declaredConstructor.newInstance(null);\nSystem.out.println(instance1 == singleDemo);\n```\n\n![image-20220826013415047](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282253301.png)\n\n###### 序列化破坏单例\n\n先执行test1，再执行test2\n\n```java\n@Test\npublic void test1() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile\";\n    final SingleDemo instance1 = SingleDemo.getInstance();\n    try (final ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(new File(filePath, \"object.txt\")))) {\n        //将instance写入文件\n        objectOutputStream.writeObject(instance1);\n        objectOutputStream.flush();\n    } catch (IOException e) {\n    }\n}\n@Test\npublic void test2() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile\";\n    final SingleDemo instance1 = SingleDemo.getInstance();\n    SingleDemo sngleDemo = null;\n    try (final ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(new File(filePath, \"object.txt\")))) {\n        //将instance写入文件\n        sngleDemo = (SingleDemo) objectInputStream.readObject();\n    } catch (IOException | ClassNotFoundException e) {\n    }\n    System.out.println(sngleDemo == instance1);\n    System.out.println(sngleDemo);\n    System.out.println(instance1);\n}\n```\n\n![image-20220826014043371](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282253856.png)\n\n\n\n###### 枚举可避免以上问题\n\n> 尝试使用反射破坏枚举单例：枚举的构造方法除枚举自定义的还有Enum类中的code。\n>\n> 会报出`IllegalArgumentException`异常，不可以使用反射创建枚举对象。\n\n```java\n@Test\npublic void test2() throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {\n    final Constructor<? extends SignalEnum> declaredConstructor = SignalEnum.SIGNAL_ENUM.getClass().getDeclaredConstructor(String.class,int.class);\n    declaredConstructor.setAccessible(true);\n    final SignalEnum signalEnum = declaredConstructor.newInstance(\"signalEnum\",2);\n    System.out.println(signalEnum == SignalEnum.SIGNAL_ENUM);\n    System.out.println(SignalEnum.SIGNAL_ENUM);\n    System.out.println(signalEnum);\n}\n```\n\n![image-20220826015207256](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208260152336.png)\n\n> 尝试使用序列化破坏枚举单例\n\n先执行testx  再执行testy\n\n结果是true，表示序列化不会破坏枚举单例。\n\n```java\n@Test\npublic void testx() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile\";\n    final SignalEnum signalEnum = SignalEnum.SIGNAL_ENUM;\n    try (final ObjectOutputStream objectOutputStream = new ObjectOutputStream(\n            new FileOutputStream(new File(filePath, \"object2.txt\")))) {\n        //将instance写入文件\n        objectOutputStream.writeObject(signalEnum);\n        objectOutputStream.flush();\n    } catch (IOException e) {\n    }\n}\n\n@Test\npublic void testy() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile\";\n    final SignalEnum signalEnum = SignalEnum.SIGNAL_ENUM;\n    SignalEnum signalEnum2 = null;\n    try (final ObjectInputStream objectInputStream = new ObjectInputStream(\n            new FileInputStream(new File(filePath, \"object2.txt\")))) {\n        //将instance写入文件\n        signalEnum2 = (SignalEnum) objectInputStream.readObject();\n    } catch (IOException | ClassNotFoundException e) {\n    }\n    System.out.println(signalEnum == signalEnum2);\n    System.out.println(signalEnum);\n    System.out.println(signalEnum2);\n}\n```\n\n![image-20220826015618559](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282245977.png)\n\n原因：\n\n枚举类型拒绝反射创建实例。\n\n枚举类型在序列话的时候会将枚举项，对应名称序列化，而具体信息不会序列话，在反序列化时，会根据枚举项名称，调用valueOf方法返回枚举项。\n\n\n\n\n\n\n\n\n\n### 异常处理\n\n> `ThrowAble`类下有两个重要的子类：`Error`和`Exception`,并且这两个子类下面也存在着大量的子类。\n>\n> `Error`表示系统或硬件级别的错误，由java虚拟机抛出异常，程序员无法处理。\n>\n> `Exception`表示程序级别的错误，是由于程序设计不完善而出现的问题，程序员必须手动处理\n\n#### 异常类型\n\n 主要分两大类：\n\n- 受检异常(checked   exception)\n- 非受检异常(unchecked   exception)\n\n\n\n##### 受检异常\n\n> 受检异常声明：在对应方法上通过`throws`关键字，声明一个异常。然后此方法在被调用的时候，调用方一定要对其做处理(要么捕获、要么向上抛出)，否则是无法通过编译的。\n>\n> 所以当我们希望调用者，必须处理一些特殊情况的时候，就可以声明受检异常。\n\n受检异常在io操作中使用的非常频繁，比如说`FileNotFoundException`异常以及`IOException`及其子类。\n\n比如：\n\n```java\npublic void test1() throws IOException {\n    IOUtils.readLines(new FileInputStream(\"filename\"),  StandardCharsets.UTF_8);\n}\npublic void test2()   {\n    try {\n        IOUtils.readLines(new FileInputStream(\"filename\"),  StandardCharsets.UTF_8);\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n查看 IOUtils.readLines()方法：发现此方法声明了受检异常：\n\n![image-20220808104023792](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282250788.png)\n\n##### 非受检异常\n\n> 非受检异常，在编码的时候不用强制捕获，但是如果不捕获，在出现异常的时候就会中断程序的运行。\n>\n> 一般来说都是运行时异常，为 `RuntimeException`及其子类。\n>\n> 比如说空指针异常(NPE)、数组下标越界异常(IOE)以及一些我们自定义的运行期间异常。对于非受检异常来说，如果代码编写的合理，这些异常都是可以避免的。\n\n#### 关键字\n\n- throws     方法声明异常\n\n- throw       后跟异常实例显示抛出异常\n\n- try            用来包裹一块可能出现异常的代码块\n\n- catch        跟在try代码后，指定异常类型，并对异常进行处理\n\n- finally        一些代码无论是否出现异常都会执行，可以定义在fianlly代码块李\n\n  \n\n#### 异常处理\n\n> 要么自己try    catch处理\n>\n> 要么向上抛出，交给调用者处理\n\n#### 自定义异常\n\n> 一般通过继承`RuntimeException`定义一个自定义异常，用于抛出一些错误的业务。\n\n```java\npublic class MyException  extends RuntimeException{\n    \n    private final String DEFAULT_ERROR_CODE = \"5000\";\n    private final String DEFAULT_ERROR_MSG = \"运行时异常\";\n    \n    String code;\n    String msg;\n    //someMethod\n    public MyException(Throwable cause, String code, String msg) {\n        super(cause);\n        this.code = code;\n        this.msg = msg;\n    }\n}\n```\n\n#### 异常链\n\n> 是指java在运行期捕获了一个异常，处理的时候，抛出了一个新的异常，所抛出的新的异常包含前一个异常的信息，如此形成一个异常链。\n\n如果抛出的异常不包含前一个异常信息的话，我们就不会清楚的知道这个异常具体出现的原因：\n\n```java\npublic void test1() {\n    try {\n        String str = null;\n        byte[] bytes = str.getBytes(StandardCharsets.UTF_8);\n    } catch (NullPointerException npe) {\n        throw new MyException(\"5000\", \"空指针异常\");\n    }\n}\n```\n\n![image-20220808111542845](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282250911.png)\n\n如果我们包含前一个异常信息，在异常抛出的时候可以，追溯到肯本原因：\n\n```java\npublic void test1() {\n。。。。\n    throw new MyException(npe, \"5000\", \"空指针异常\");\n。。。\n}\n```\n\n![image-20220808111646319](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282250767.png)\n\n#### try-with-resources\n\n> java对于资源的操作，比如说io流、数据库连接，这些资源在非常昂贵，必须在使用结束后显示的关闭资源。\n>\n> 即在finally代码块内调用对应资源的close()方法。\n\n```java\npublic void test2() {\n    BufferedReader bi = null;\n    try {\n        bi = new BufferedReader(new FileReader(\"filename\"));\n        String line;\n        while ((line = bi.readLine()) != null){\n            System.out.println(line);\n        }\n    } catch (IOException e) {\n        //dosomething\n    } finally {\n        try {\n            IOUtils.close(bi);\n        } catch (IOException e) {\n            //dosomething\n        }\n    }\n}\n```\n\n> java7 开始提供了一个跟好的处理资源的方式：try-with-resources 语句。这是一个类似于语法糖的语法，方便程序员编码，但是经过编译器编译后，都会转化成jvm认识的。\n\n将资源定义在try括号内，便无需我们手动去关闭资源了：\n\n```java\n@Test\npublic void test4() {\n    try( BufferedReader bi = new BufferedReader(new FileReader(\"filename\"))) {\n        String line;\n        while ((line = bi.readLine()) != null){\n            System.out.println(line);\n        }\n    } catch (IOException e) {\n        //dosomething\n    }\n}\n```\n\n可以使用jad反编译查看一下：\n\n发现编译器帮我们做了：\n\n![image-20220808114543526](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282250315.png)\n\n#### finally  & return\n\n- ffinally代码块一定会执行么？\n- return的结果是否被finally影响？\n- return和finally代码执行顺序，孰先孰后？\n\n##### finally代码块不一定执行\n\n> finally代码块不一定会执行\n\n- 当我们的代码在进入try代码块之前就已经return了，那么整个方法就结束了，finally代码块就不会执行\n- 当虚拟机强制停止的时候  exit(0),finally代码块就不会执行\n\n例：\n\n以下两种方式finally代码块都不会执行\n\n```java\npublic StringBuilder method1(Boolean flag) {\n    StringBuilder sb = new StringBuilder();\n    if (flag) {\n        sb.append(\"方法在try代码块之前return\\n\");\n        return sb;\n    }\n    try {\n\n    } catch (Exception e) {\n        System.out.println(\"进入try代码块\\n\");\n    } finally {\n        System.out.println(\"finally代码块执行\\n\");\n    }\n    return sb;\n}\npublic StringBuilder method2(Boolean flag) {\n    StringBuilder sb = new StringBuilder();\n    if (flag) {\n        System.exit(0);\n    }\n    try {\n\n    } catch (Exception e) {\n        System.out.println(\"进入try代码块\\n\");\n    } finally {\n        System.out.println(\"finally代码块执行\\n\");\n    }\n    return sb;\n}\n\n@Test\npublic void test1() {\n    method1(true);\n    method2(true);\n}\n```\n\n##### finally对return结果的影响\n\n> finally代码可能会对return的结果产生影响。\n>\n> 对于基本数据类型和一些不可变的引用类型return的结果不受finally的影响\n>\n> 对于可变的提供修改方法的引用类型，return的结果会受到finally的影响\n\n- 对于基本数据类型  和  一些不可变的比如说String\n\nfinally代码块执行但是不影响return的结果\n\n```java\npublic int method3() {\n    int i = 0;\n    try {\n        return i;\n    } finally {\n        System.out.println(\"finally代码块执行\");\n        i += 1;\n    }\n}\npublic String method4() {\n    String str = \"123\";\n    try {\n        return str;\n    } finally {\n        System.out.println(\"finally代码块执行\");\n        str += \"abc\";\n    }\n}\n@Test\npublic void test2() {\n    int i = method3();\n    System.out.println(\"method3返回结果：\" + i);\n\n    String str = method4();\n    System.out.println(\"method4返回结果：\" + str);\n}\n```\n\n![image-20220808130934740](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282253522.png)\n\n- 对于可修改的引用类型(比如说StringBuilder)\n\nfinally代码会执行且影响了返回的结果\n\n```java\npublic StringBuilder method5() {\n    StringBuilder sb = new StringBuilder(\"\");\n    try {\n        return sb.append(\"123\");\n    } finally {\n        System.out.println(\"finally代码块执行\");\n        sb.append(\"abc\");\n    }\n}\n\n@Test\npublic void test3() {\n    StringBuilder sb = method5();\n    System.out.println(\"method5返回结果：\" + sb.toString());\n}\n```\n\n![image-20220808131219548](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282253387.png)\n\n> 所以说我们可以得出一个结论：\n\nreturn会记住需要返回结果的字面量信息，对于基本数据类型来说就是值，对于引用类型来说就是引用地址的值。对于基本数据类型和不可变引用类型需要通过`=`等号赋值，那就直接修改了引用，而return所记住的引用指向的对象并没有被修改。那么对于可变引用类型来说，return所记住的引用指向的对象可以在finally中被修改。\n\n##### return和finally代码执行顺序\n\n> 其实在上一个例子中已经有结果了，我们可以发现返回的sb为 123abc。\n>\n> 所以说可以得出的结论是：\n>\n> return  的代码执行在finally代码块之前\n>\n> finally代码执行在return代码之后，在完全return之前\n\n\n\n<hr>\n\n### 集合\n\n> 集合相关简单关系如下图，没有列出所有的集合类\n\n![image-20220809103023147](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282253243.png)\n\n\n\n#### Iterable\n\n- `Iterable`接口提供了一个获取迭代器的抽象方法，各种集合类去实现它，返回各自需要的迭代器`Iterator`。这些迭代器一般作为各种集合的内部类。\n\n- 一个遍历方法  foreach(Consumer action)。各个集合实现\n- 一个获取分离迭代器的方法。①可以split集合，用于可能并行操作的场景。②遍历\n\n以ArrayList为例：\n\n```JAVA\n@Test\npublic void test1() {\n    List<String> list = new ArrayList<>(Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\"));\n\n    list.forEach(System.out::print);\n    System.out.println(\"        foreach\");\n\n    Spliterator<String> spliterator = list.spliterator().trySplit();\n    spliterator.forEachRemaining(System.out::print);\n    System.out.println(\"        spliterator   forEachRemaining\");\n\n    Spliterator<String> spliterator1 = list.spliterator();\n    while (spliterator1.tryAdvance(System.out::print)) ;\n    System.out.println(\"         spliterator   tryAdvance\");\n}\n```\n\n![image-20220809125359887](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282253517.png)\n\n使用trySplit方法将集合分割为多个小集合：每一次trySplit都会跟新 Spliterator的index属性\n\n```java\npublic void test3() {\n    List<String> list = new ArrayList<>(Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\"));\n    Spliterator<String> spliterator = list.spliterator();\n\n    Spliterator<String> spliteratorTemp = null;\n    while (null != (spliteratorTemp = spliterator.trySplit())) {\n        spliteratorTemp.forEachRemaining(System.out::print);\n        System.out.println();\n    }\n    spliterator.forEachRemaining(System.out::print);\n}\n```\n\n![image-20220809145504844](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282253994.png)\n\n#### collection\n\n> Collection接口中除了一些关于集合状态的方法合一些对集合操作的方法外，还有两个获取流的方法\n\n<img src=\"https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282253664.png\" alt=\"image-20220809150217164\" style=\"zoom:50%;\" />\n\n##### 使用stream来对集合进行操作\n\n```java\n@Test\npublic void test1() {\n    System.out.println(\"===============流  转集合===============\");\n    List<String> list = new ArrayList<>(Arrays.asList(\"1\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"));\n    List<String> collect1 = list.stream().collect(Collectors.toList());\n    collect1.stream().forEach(System.out::print);\n    System.out.println();\n\n    System.out.println(\"===============遍历===============\");\n    list.stream().forEach(System.out::print);\n    System.out.println();\n\n    System.out.println(\"===============过滤===============\");\n    List<String> collect2 = list.stream().filter((ele) -> ele.equals(\"2\")).collect(Collectors.toList());\n    collect2.stream().forEach(System.out::print);\n    System.out.println();\n\n    System.out.println(\"===============映射===============\");\n    List<Integer> collect3 = list.stream().map(Integer::valueOf).collect(Collectors.toList());\n    collect3.stream().forEach(System.out::print);\n    System.out.println();\n\n    System.out.println(\"===============求和 求平均值===============\");\n    int sum = list.stream().mapToInt(Integer::valueOf).sum();\n    System.out.println(sum);\n\n    System.out.println(\"===============去重===============\");\n    List<String> collect4 = list.stream().distinct().collect(Collectors.toList());\n    collect4.stream().forEach(System.out::print);\n    System.out.println();\n\n    System.out.println(\"===============判断===============\");\n    final boolean b1 = list.stream().allMatch(ele -> \"2\".equals(ele));\n    final boolean b2 = list.stream().anyMatch(ele -> \"2\".equals(ele));\n    System.out.println(b1 + \" \" + b2);\n    System.out.println();\n\n    System.out.println(\"===============获取option===============\");\n    String s1 = list.stream().findAny().get();\n    String s2 = list.stream().findFirst().get();\n    System.out.println(s1 + \" \" + s2);\n    System.out.println();\n\n    System.out.println(\"===============对每一个元素进行操作===============\");\n    List<String> collect5 = list.stream().peek(ele -> {\n      if (ele.equals(\"2\")){\n          System.out.println(\"xxxx\");\n      }\n    }).collect(Collectors.toList());\n    collect5.stream().forEach(System.out::print);\n    System.out.println();\n\n}\n```\n\n\n\n#### Collectors\n\n> `Collectors`构造器私有化且未提供获取实例的方法，那么此类无法实例化。这是一个工具类，可以加快我们处理集合的效率。\n\n我们经常需要将一个处理过的Stream转化为集合类，需要调用collect()方法，此方法需要一个参数：Collector，实现Collector接口还是很麻烦的，所以Collectors提供了许多静态方法，给我们构建需要的Collector。\n\n+++以下例子基于着两个集合：\n\n```java\nfinal List<String> list1 = Arrays.asList(\"a\", \"ab\", \"abc\", \"abcd\", \"abcd\");\nfinal List<String> list2 = Arrays.asList(\"1\", \"12\", \"123\", \"1234\", \"1234\");\n```\n\n##### toList\n\n> `Collector.toList`方法，查看源码发现，默认转化为ArrayList。\n\n```java\nList<String> collect1 = list1.stream().filter(\"a\"::equals).collect(Collectors.toList());\n```\n\n##### toSet\n\n> `Collector.toSet`方法，查看源码发现，默认转化为HashSet。  转化为元素不重复集合\n\n```java\nfinal Set<String> collect2 = list1.stream().collect(Collectors.toSet());\n```\n\n##### toCollection\n\n> 以上的`toList、toSet`方法转化的是特定的集合，那么如果有特殊需求需要转化为自定义集合的话就需要使用`toCollection`方法。\n\n查看源码发现就是自定义集合类型：\n\n```java\nfinal LinkedList<String> collect3 = list1.stream().collect(Collectors.toCollection(() -> new LinkedList<>()));\n//lambda表达式写法\nfinal LinkedList<String> collect4 = list1.stream().collect(Collectors.toCollection(LinkedList::new));\n```\n\n##### toMap\n\n> 将集合元素转化为map，默认HashMap。`Collectors.toMap()`方法需要两个参数：keyMapper和valueMapper，两个参数都是`Function`接口的实现类，参数是集合元素，返回结果是对应key  value。\n\n```java\nfinal Map<String, Integer> map1 = list1.stream().collect(Collectors.toMap(String::toString, String::length));\n```\n\n> 如果转化后的map的key存在重复元素，会报`java.lang.IllegalStateException`异常。需要我们主动合并。也就是`Collectors.toMap`的几个重载\n\n这个合并的大致思路就是，会将存在重复记录的map节点提出来，然后重复记录的key对应的了两个value作为BinaryOperator接口的参数，返回结果类型和两个参数类型都一样。\n\n比如：上面的集合转化成map{ab=2, a=1, abc=3, abcd=4,abcd=4},这个map是存在key重复记录的，是不允许的，那么需要将这个map分为两个map1{ab=2, a=1, abc=3, abcd=4},map2{abcd=4}。然后将两个map对应key重复的记录的value提出来作为BinaryOperator接口apply(T t,T u)的参数，我们这里做一个相加，即apply(4,4) return 4 + 4;。那么最终的结果为 map{ab=2, a=1, abc=3, abcd=8}。\n\n```java\ntoMap(Function<? super T, ? extends K> keyMapper,\n                                Function<? super T, ? extends U> valueMapper,\n                                BinaryOperator<U> mergeFunction)\n```\n\n```java\nfinal Map<String, Integer> map2 = list1.stream().collect(Collectors.toMap(String::toString, String::length, Integer::sum));\nSystem.out.println(map2);\n```\n\n> 还有一个重载，可以自定义map\n\n```java\nfinal Map<String, Integer> map3 = list1.stream().collect(Collectors.toMap(String::toString, String::length, Integer::sum, LinkedHashMap::new));\n```\n\n##### collectingAndThen()\n\n> 此方法允许我们对转化后的集合再做一次操作\n\n这里的第二个参数，是一个函数式接口实现类，需要注意 第一个泛型 R是第一步流转集合的结果，也是函数式接口Function的apply(T t)方法的参数，第二个参数RR为apply(T t)方法返回结果，也是最终需要返回的结果，可以是任意的。这里返回集合\n\n```java\nFunction<R,RR> finisher\n```\n\n```java\nfinal List<String> collect5 = list1.stream().collect(Collectors.collectingAndThen(Collectors.toList(),\n        (list -> list.stream().filter(\"abc\"::contains).collect(Collectors.toList()))));\ncollect5.forEach(System.out::println);\n```\n\n\n\n##### joining\n\n> 将集合内元素拼接成字符串\n\n参数说明：\n\n第一个参数：分割符号\n\n第二个参数：返回结果字符串前缀\n\n第三个参数：返回结果字符串后缀\n\n```java\nfinal String joinResult = list1.stream().collect(Collectors.joining(\",\", \"<\", \">\"));\nSystem.out.println(joinResult);\n```\n\n\n\n##### counting\n\n> 统计个数\n\n```java\nfinal Long size = list1.stream().collect(Collectors.counting());\nSystem.out.println(size);\n```\n\n\n\n##### summarizingDouble/Long/Int()\n\n> 做统计\n\n这里对集合内字符串长度做统计，得出合、最大、最小值\n\n```java\nfinal IntSummaryStatistics intSummaryStatistics = list1.stream().collect(Collectors.summarizingInt(String::length));\nSystem.out.println(intSummaryStatistics.getSum());\nSystem.out.println(intSummaryStatistics.getMax());\nSystem.out.println(intSummaryStatistics.getMin());\n```\n\n\n\n##### groupBy\n\n> 以一定条件分组，这里以字符串长度分组\n\n```java\n//分组\nfinal Map<Integer, List<String>> map = list1.stream().collect(Collectors.groupingBy(String::length, Collectors.toList()));\nSystem.out.println(map);\n```\n\n##### partitioningBy\n\n> 特殊的分组，将集合分为两组，key值为boolean\n\n```java\n//特殊分组，以boolean作为map的key\nfinal Map<Boolean, List<String>> map1 = list1.stream().collect(Collectors.partitioningBy(ele -> ele.length() > 2\n));\nSystem.out.println(map1);\n```\n\n\n\n#### Set  &  List\n\n> `Set`和`List`接口都是`Collection`接口的子接口，用于存储同一类型的元素。\n\nList：元素按顺序插入，可重复\n\nSet：元素插入无序，不可重复。Set的实现由HashSet、TreeSet，虽然set插入无序但是TreeSet底层原理是红黑树，元素整体上大小有序。\n\n\n\n####  ArrayList  &  LinkedList  & Vector\n\n> 这三个类都是`List`的实现类。\n\n##### ArrayList\n\n> `ArrayList`底层是一个可边长数组，数据连续，当容量补不足的时候会进行扩容，扩1.5倍，使用Sysytem.arrayCopy()进行浅拷贝。\n>\n> ArrayList实现了`RandomAccess`接口，表明支持随机访问，搜索效率高。\n>\n> `elementData`使用`transient`修饰，优化序列化传输和存储\n>\n> 如果说在使用ArrayList之前知道需要存入集合的元素大致个数，可以一次性将集合扩容足`ensureCapacity(int minCapacity) `,避免频繁扩容导致降低集合效率。\n\n重要属性：\n\n- elementData 存放元素的数组\n- size    集合大小（元素个数）\n\n```java\ntransient Object[] elementData;\nprivate int size;\nprivate static final int DEFAULT_CAPACITY = 10;\n//private static final Object[] EMPTY_ELEMENTDATA = {};\n//private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n```\n\n\n\n######  优缺点\n\n优点：\n\n- 搜索效率高\n- 优化了序列话传输和序列化存储。（重写了WriteObject和ReadObject方法，不对null元素序列化传输）\n\n缺点：\n\n- 对插入不友好\n\n插入默认尾插法：如果插入时容量足够，直接在对应位置赋值即可，但是容量如果不足的化，首先需要扩容，扩容时就必须涉及数组的拷贝，效率自然受影响。\n\n如果说插入位置是程序员指定的，那么需要将该位置及其之后的元素都后移一位，然后再赋值，效率也会受影响。\n\n\n\n##### LinkedList\n\n> `LinkedList`除了实现了`List`接口，还实现了`Deque`接口，实现了`offer\\peek\\poll`等方法，对集合的操作更加灵活。\n>\n> `LinkedList`底层是一个双向链表，数据不连续，没有容量限制。\n>\n> 对插入友好，对访问不友好。`LinkedList`不支持随机访问。\n>\n> 链表的访问效率地下，特别的：如果我们每次访问的元素在链表尾部的时候，那么每次遍历都几乎需要循环整个链表。\n\n重要属性:\n\n- size  集合大小\n- first    头节点\n- last    尾节点\n\n```java\ntransient int size = 0;\ntransient Node<E> first;\ntransient Node<E> last;\n```\n\n###### 优缺点\n\n优点：\n\n- 没有容量限制，添加元素无需考虑扩容，且添加元素只需要修改引用，效率较高\n\n缺点：\n\n- 访问效率低下\n\n##### Vector\n\n> `Vector`的实现和`ArrayList`基本相同，主要存在如下不同处:\n\n- Vector  属于强同步类，而ArrayList非同步类\n- Vector默认每次扩容两倍，ArrayList扩容1.5倍\n- Arraylist对序列话传输和存储做了优化，而Vector没有\n\n> Vector关于扩容\n\n容量增长步数`capacityIncrement`如果不设置，默认每次扩两倍，如果设置，每次扩容capacityIncrement。\n\n```java\n//容量增长步数\nprotected int capacityIncrement;\n//扩容关键代码\nint newCapacity = oldCapacity + ((capacityIncrement > 0) ?\n                                 capacityIncrement : oldCapacity);\n```\n\n\n\n#### Collections\n\n> `Collections`的构造函数私有化被`private`修饰，不可实例化，除了构造方法外，存在很多被`static`修饰的静态方法，目的在于对集合进行操作。\n\n- 排序\n\n  > 调用的就是List的sort方法\n\n  ```java\n  //必须是Comparable的子类\n  void sort(List<T> list);\n  //可自定义比较器\n  void sort(List<T> list, Comparator<? super T> c);\n  ```\n\n- 搜索\n\n  > 二分查找。如果支持随机访问且集合不是很大，调用indexedBinarySearch方法，否则调用iteratorBinarySearch方法。\n\n  ```java\n  binarySearch(List<? extends Comparable<? super T>> list, T key);\n  binarySearch(List<? extends T> list, T key, Comparator<? super T> c);\n  ```\n\n  > 返回指定集合，指定元素的出现次数\n\n  ```java\n  static int frequency(Collection<?> c, Object o);\n  ```\n\n  > 返回目标集合在源集合中首次出现的下标。\n  >\n  > 返回目标集合在源集合中首次出现的下标。\n  >\n  > 没有则返回-1\n\n  ```java\n  public static int indexOfSubList(List<?> source, List<?> target) ;\n  public static int lastIndexOfSubList(List<?> source, List<?> target);\n  ```\n\n- 复制集合\n\n  > 将源集合复制到目标集合中\n\n  ```java\n  public static <T> void copy(List<? super T> dest, List<? extends T> src);\n  ```\n\n- 反转\n\n  > 将集合元素反转\n\n  ```java\n  void reverse(List<?> list);\n  ```\n\n  \n\n- 洗牌\n\n  > 打乱现有元素顺序，达到`洗牌`效果\n\n  ```java\n  void shuffle(List<?> list, Random rnd);\n  void shuffle(List<?> list)\n  ```\n\n- 交换\n\n  > 这个方法在reverse中也可能会使用到\n\n  ```java\n  swap(List<?> list, int i, int j);\n  ```\n\n- 填充\n\n  > 填充集合。以某个对象替换集合中的所有元素\n\n  ```java\n  void fill(List<? super T> list, T obj);\n  ```\n\n- 拷贝\n\n  > 将源集合中的元素拷贝到目标集合。`src`是源集合，`dest`是目标集合。\n  >\n  > 目标集合的`size`需要大于等于源集合，否则会报出`IndexOutofBoundsException`异常。\n  >\n  > 拷贝过后目标集合和源集合共享集合内的元素\n\n  ```java\n  void copy(List<? super T> dest, List<? extends T> src)\n  ```\n\n  ```java\n  @Test\n  public void test1() {\n      final StringBuffer sb1 = new StringBuffer(\"a\");\n      final StringBuffer sb2 = new StringBuffer(\"b\");\n      final StringBuffer sb3 = new StringBuffer(\"c\");\n      final StringBuffer sb4 = new StringBuffer(\"d\");\n      final StringBuffer sb5 = new StringBuffer(\"e\");\n      final StringBuffer sb6 = new StringBuffer(\"f\");\n      final List<StringBuffer> sbSource = Arrays.asList(sb1, sb2, sb3, sb4, sb5);\n      final List<StringBuffer> sbTarget = Arrays.asList(sb6, sb6, sb6, sb6, sb6, sb6);\n      Collections.copy(sbTarget, sbSource);\n      sb1.append(\"|update|\");\n  \n      sbTarget.forEach(System.out::print);\n  }\n  ```\n\n- 最大值最小值\n\n  > 获取一个集合的极值，如果元素未实现Comparable接口，需要自定义Comparator。\n\n  ```java\n  <T extends Object & Comparable<? super T>> T min(Collection<? extends T> coll);\n  <T> T min(Collection<? extends T> coll, Comparator<? super T> comp);\n  <T extends Object & Comparable<? super T>> T max(Collection<? extends T> coll);\n  <T> T max(Collection<? extends T> coll, Comparator<? super T> comp);\n  ```\n\n- 集合旋转特定距离\n\n  > 什么意思？相当于集合右移  distance % size()。右边被挤出来的元素添加到集合头部。\n  >\n  > 如果`distance`为正数，整体右移，负数整体左移。\n\n  比如：\n\n  ```java\n  @Test\n  public void test1(){\n      List<Integer> integers = Arrays.asList(0,1, 2, 3, 4, 5, 6, 7, 8, 9);\n      Collections.rotate(integers,5);\n      integers.stream().forEach(System.out::print);\n  }\n  ```\n\n  ![image-20220811130849708](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282253438.png)\n\n  ```java\n  public static void rotate(List<?> list, int distance);\n  ```\n\n- 转化集合\n\n  > 注意转化为不可变集合后，源集合任然可以进行修改操作并且可以直接影响到,不可变集合的不可变性。因为`Collections`转化不可变集合的操作是将源集合作为转换后不可变集合的属性。\n\n  ```java\n  //将目标集合转化成不可变集合，如果调用修改Api则会报出UnsupportedOperationException异常\n  public static <T> Collection<T> unmodifiableCollection(Collection<? extends T> c);\n  public static <K,V> Map<K,V> unmodifiableMap(Map<? extends K, ? extends V> m);\n  //转化为受检查的集合  在添加时会Class.isInstance(o)判断\n  <E> Collection<E> checkedCollection(Collection<E> c,Class<E> type);\n  //转化为同步集合\n  synchronizedCollection(Collection<T> c);\n  ```\n\n- 创建集合\n\n  > 返回的集合类型没有实现add等添加方法，如果做添加元素操作，会报出`UnsupportedOperationException`异常\n\n  ```java\n  //创建只有一个元素的集合\n  public static <T> Set<T> singleton(T o);\n  ```\n\n  > 返回空集合,返回的集合类型没有实现add等添加方法，如果做添加元素操作，会报出`UnsupportedOperationException`异常\n\n  ```java\n   <T> Set<T> emptySet();\n  ```\n\n  > 生成只有一个元素的集合，该集合不可变\n\n  ```java\n  //set\n  <T> Set<T> singleton(T o);\n  <T> List<T> singletonList(T o);\n  <K,V> Map<K,V> singletonMap(K key, V value);\n  ```\n\n  > 生成一个由指定对象的 n 个副本组成的不可变列表\n\n  ```java\n  //n拷贝个数      o 集合元素\n  <T> List<T> nCopies(int n, T o);\n  ```\n\n  > 生成一个线程安全的集合\n  \n  `Collections.SynchronizedCollection`和`Vector`的区别：\n  \n  ①两者实现同步的关键就在于使用`Synchronized`关键字实现，而`Vector`大部分代码使用的是同步方法，也就是锁的`this`。而`Collections.SynchronizedCollection`可以指定锁的对象`mutex`，如果不传默认锁的还是`this`。\n  \n  ②`Vector`的底层是一个对象数组，在其构造函数的重载中，可以直接将一个`Collection`转化为`Vector`，但是如果被转化的集合是一个`LinkedList`的时候，需要改变其底层数据结构，也就是需要调用`toArray()`方法，将链表转化为数组。而`Collections.SynchronizedCollection`是不需要改变集合底层结构的，同样的被转化的集合作为`Collections.SynchronizedCollection`的内部属性。\n  \n  ```java\n  <T> Collection<T> synchronizedCollection(Collection<T> c);\n  //mutex 作为对象监视器。如果主动设置，则锁的是mutex。否则默认锁的this(这也是和Vector的区别)\n  <T> Collection<T> synchronizedCollection(Collection<T> c, Object mutex);\n  ```\n  \n  \n\n#### Set如何保证元素不重复\n\n> `Set`的实现主要有两个，一个是`HashSet`，一个是`TreeSet`。特点是元素不重复\n\n- HashSet\n\n  `HashSet`基于`HashMap`实现，`HashMap`的`key`值不重复，`HashSet`的元素就是`HashMap`的key值。只能存在一个null元素（`hashMap`中，null的hash值为0）。\n\n  其判重方法是：首先使用`hash`值(散列值)判断，如果散列值不相等那么直接就不相等，如果散列值相等再使用`equals()`方法进行安全校验。原因在于：哈希值的比较效率高于对象的`equals()`方法。\n\n- TreeSet\n\n  `TreeSet`基于`TreeMap`实现，`TreeMap`底层是一颗红黑树(红黑树是对平衡二叉查找树的优化)。其内不可存储null元素(会报NPE异常)。\n\n  其判重方式是：①如果元素实现了`Comparable`接口，直接使用元素的`compareTo()`方法。②如果元素没有实现`Comparable`接口必须指定`Comparator`，调用`Comparator.compare()`方法。\n\n  都是子节点与父节点进行比较，比较结果小于0作为左孩子，大于0作为右孩子，等于0替换父节点value值。\n\n\n\n#### hashMap & hashTable\n\n> `HashTable`是一个较为古老的类，是一个线程安全的key - value键值对数据类型，其有一个`Property`子类，一般作为配置文件的工具类。\n>\n> `HashMap`可以认为是单线程环境下`HashTable`的替代品，其在避免哈希冲突、查找效率上都比`HashTable`要强。\n>\n> 一般情况下，`HashTable`已被弃用，单线程环境下使用`HashMap`，多线程环境需要保证线程安全的情况下使用`ConcurrentHashMap`。\n\n##### 区别\n\n- 线程安全\n\n  > `HashMap`非同步，多线程环境下需要同步，则使用`ConcurrentHashMap`。\n  >\n  > `HashTable`同步，使用`Synchronized`保证，同步方法，锁的是`this`。\n\n- 继承关系\n\n  > `HashMap`是`AbstractMap`的子类，并实现了`Map`接口。\n  >\n  > `HashTable`是`Dictionary`的子类(JDK1.0提出的)，并实现了`Map`接口。\n\n- 是否允许null值\n\n  > `HashMap`键和值都可以添加null值，null值作为键只能出现一次(hashMap的`hash()`方法，null对应的是0)，null值作为value可以出现多次(即多个键值对应value都是null)。\n  >\n  > `HashTable`键和值都可以不可以为null值，在`put`的时候，会对值进行空校验，会调用键的`hashCode()`方法。\n\n- 容量Capacity & 扩容机制\n\n  > `HashMap`容量默认`1<<4`(16)，每次扩容2倍，为2^n^。\n  >\n  > `HashTable`容量默认11，每次扩容2n+1。\n\n- hash值\n\n  > `HashMap`对`key`值的`hashCode`进行了哈希扰动，有效的降低了`HashMap`的哈希冲突。\n  >\n  > `HashTable`直接使用的键的`hashCode`\n\n- 遍历方式\n\n  > `HashMap`的遍历可以通过获取`EntryIterator、ValueIterator、KeyIterator`这些迭代器来遍历。\n  >\n  > `HashTable`的遍历：对于`key 和  value`来说，可以通过`keys()和elementa()`方法获取`Enumeration`进行遍历，对于`Map.entry`可以获取`EntrySet`再进行遍历。\n  >\n  > Iterator支持fast - fail，而`Enumeration`不支持。\n\n##### hashTable相关算法\n\n> 先了解`hashTable`的相关算法，相比于`HashMap`容易理解，同时后续和`HashMap`比较着理解，可以感受`HashMap`设计的巧妙。\n\n> 底层是数组+单向链表\n\n- 如何确定元素散列下标\n\n> hashTable使用的元素的哈希值，通过取余的方式获取散列下标。关键代码如下\n\n哈希值和0x7FFFFFFF按位与，是为了防止负数的出现。和tab.length除取余得到的是 (0 -  tab.length)，随机散列到数组中。\n\n```java\nindex = (hash & 0x7FFFFFFF) % tab.length;\n```\n\n- 扩容（reHash）\n\n> 首先了解两个属性`loadFactor`和`threadshold`分别为加载因子和临界值。加载因子默认为0.75，算上哈希冲突，所以说hashmap的存储效率一般不会超过百分之五十。\n\n存在如下关系：\n$$\nthreadshold = table.length * loadFactor\n$$\n\n\n> 扩容的目的是为了避免频繁哈希冲突，扩容的时机是当集合元素个数`count`大于临界值`loadfactor`时，进行扩容，扩为2倍加一，`loadfactor`也随之修改。\n>\n> 扩容的方法是，数组容量扩充，新建一个扩充后长度的数组，将旧数组元素放入新创建的数组。\n\n- 序列化\n\n> 序列话传输的时候会剔除空节点，同时这也是必须的，因为`hashTable`不支持key  或  value中任意的null值。\n\n\n\n##### hashMap相关算法\n\n> `hashMap`底层是数组 + 单向链表 + 红黑树\n>\n> `hashMap`是对单线程下`hashTable`的优化。\n>\n> 主要通过  ①位运算  ②截断链表 ③转换红黑树   进行优化\n\n- hashMap的capacity\n\n> `HashMap`的容量为 2^n^。\n\n通过一系列的移位运算和或运算找到任意数离其最近大于它的2^n^值，比如  5 ---> 8   、 11 -->  16、33 ---> 64。\n\n基本思想就是：\n\n5 的二进制表示为 0101，将高位第一位不为0的及所有低位置为1，即  0111，转换后加一，即 1000   => 8\n\n11的二进制表示为 1011，将高位第一位不为0的及所有低位置为1，即  1111，转换后加一，即 0001 0000   => 16\n\n- 如何确定散列下标\n\n> 前提是：`HashMap`的容量为2^n^。散列下标为哈希值和table.length - 1按位与\n\n`hashTable`是通过除取余的方式，同样的`hashMap`也是，也可以通过除取余的方式。\n\n但是当数组的长度为2^n^时候，除取余  =  hash()  &  table.length - 1。\n\n- hashMap的扰动函数\n\n> `hashTable`对key值的哈希值没做任何处理，会出现一个问题，就是如果key的哈希算法很糟糕的话，会很频繁的出现哈希冲突，通过拉链法解决冲突的话，链表将会拉的很长，且`hashTable`没有截断链表和转化红黑树的操作，如此查询效率将会降低。\n>\n> 所以针对如上`hashMap`做了优化，可以理解为`hashMap`不信任我们写的哈希算法，它自己会做一层处理，基本思想是将高16位和低16位进行按位异或(哈希值是int类型32位)，如此低16位既代表了整个哈希值的特征，在使用扰动后的哈希值来确定散列下标，可有效降低哈希冲突。\n\n- 扩容\n\n> hashMap的扩容方法是`reSize()`，扩容为2倍。\n>\n> 此方法不仅仅只做了扩容操作，它还会将链表缩短(缩短一倍)，比如在原数组(数组长度为len)下标j处有一个链表长度为5，经resize方法后，会将此链表拆为两份，分别为长度为2和长度为3的链表，分别放在 新数组(2 + len)j处和len + j处。\n\n- 转化红黑树\n\n> 当哈希表的链表过长会影响到查询的效率，所以需要转化为红黑树，利用红黑树的有序性质，可以使得查询效率逼近二分查找。\n\n转化红黑树的条件是：当链表长度等于8且table节点数组长度大于等于64\n\n如果不满足table节点数组长度大于64的话，会进行扩容处理，因为扩容存在缩短链表的操作。\n\n##### loadfactory\n\n> 加载因子为何默认为0.75，在hashMap中容量为2^n^，乘3/4刚好没有小数位\n\n\n\n##### 尽量设置初始容量\n\n> 在创建hashMap的时候建议一次性申请足够多的容量，避免频繁扩容，因为每次扩容都需要重建hash表。\n\n那么初始容量设置多少合适呢？\n\n需要考虑装载因子，hashMap的有效容量为实际容量的0.75，所以设置初始化容量的时候申请大小需要大于实际需要大小。 \n\n在hashMap的putall()方法中就有类型实现：\n\n```java\n//s 为需要容量大小， ft为实际申请容量大小\nfloat ft = ((float)s / loadFactor) + 1.0F;\n```\n\n在guaua包下也有类型实现：\n\n```java\npublic static <K extends @Nullable Object, V extends @Nullable Object>\n    HashMap<K, V> newHashMapWithExpectedSize(int expectedSize) {\n  return new HashMap<>(capacity(expectedSize));\n}\nstatic int capacity(int expectedSize) {\n    if (expectedSize < 3) {\n      checkNonnegative(expectedSize, \"expectedSize\");\n      return expectedSize + 1;\n    }\n    if (expectedSize < Ints.MAX_POWER_OF_TWO) {\n      // This is the calculation used in JDK8 to resize when a putAll\n      // happens; it seems to be the most conservative calculation we\n      // can make.  0.75 is the default load factor.\n      return (int) ((float) expectedSize / 0.75F + 1.0F);\n    }\n    return Integer.MAX_VALUE; // any large value\n}\n```\n\n#### Stream\n\n> 可以使用`Stream`来处理集合，结合`Lambda`表达式和函数式编程可以编写出简洁、高效的代码\n\n##### 特点\n\n- 无存储\n\n  > `Stream`不是一种数据结构，它并不存储数据，它只是数据源的一个视图(操作集合的说明书)，数据源可以是一个集合或数组。\n\n- 简洁\n\n  > `Stream`的特性就是为函数式编程而生，结合函数式编程可以编写出简洁高效的代码。\n\n- 惰式执行\n\n  > `Stream`上的操作不会立刻执行，而是在被消费的时候才会真正执行\n\n- 可消费性\n\n  > `Stream`可被消费，且只能被消费一次。一旦遍历过就会失效。想要在此操作必须重写生成流。\n\n  > 如下test2方法stringStream已被遍历过，再次对其操作会报出`java.lang.IllegalStateException: stream has already been operated upon or closed`错误。\n  >\n  > 必须如test3生成新的流。\n\n```java\n@Test\npublic void test2() {\n    final Stream<String> stringStream = Stream.of(\"1\", \"2\", \"3\");\n    stringStream.filter(\"2\"::equals);\n    stringStream.forEach(System.out::println);\n}\n@Test\npublic void test3() {\n    final Stream<String> stringStream = Stream.of(\"1\", \"2\", \"3\");\n    final Stream<String> stringStreamFilter = stringStream.filter(\"2\"::equals);\n    stringStreamFilter.forEach(System.out::println);\n}\n```\n\n\n\n##### Stream操作\n\n> 对于`Stream`流的处理主要有三种关键性操作：创建流、中间操作、最终操作\n\n###### 创建流\n\n- 通过集合类的stream方法创建流\n- 使用Stream.of(T t)创建流\n- 使用Arrays.stream(T[] t)创建流 。 Stream.of(T ...t)底层就是使用此方式\n\n```java\n//通过集合类创建流\nfinal Collection<String> strings = Arrays.asList(\"1\", \"2\", \"3\");\nfinal Stream<String> stream = strings.stream();\n\n//Stream创建流\nfinal Stream<String> stringStream = Stream.of(\"1\", \"2\", \"3\");\nfinal Stream<String> a = Stream.of(\"a\");\n\n//Arrays.stream(T[] t)\nfinal Stream<String> stream1 = Arrays.stream(new String[]{\"1\", \"2\", \"3\"});\n```\n\n\n\n###### 中间操作\n\n> 对`Stream`做处理，包括过滤、映射、排序等\n\n| 操作(Stream opration) | 说明                         | 参数                                    |\n| --------------------- | ---------------------------- | --------------------------------------- |\n| filter                | 过滤                         | Predicate<? super T> predicate          |\n| map                   | 映射                         | Function<? super T, ? extends R> mapper |\n| limit、skip           | 限制                         | long maxSize                            |\n| sorted                | 自然排序或指定比较器         | Comparator<? super T> comparator        |\n| distinct              | 使用元素的equals去除重复元素 |                                         |\n|                       |                              |                                         |\n\n\n\n###### 最终操作\n\n> `Stream`是集合或容器的视图，是对集合或容器的操作描述，但是如果我们想要得到结果的话，就需要使用最终操作来将流转化为我们想要的结果。遍历、统计(个数)、转化集合等。\n\n| 操作    | 说明     | 参数                                 |\n| ------- | -------- | ------------------------------------ |\n| foreach | 遍历     | Consumer<? super T> action           |\n| count   | 计数     |                                      |\n| Collect | 转化集合 | Collector<? super T, A, R> collector |\n\n##### Stream转化\n\n> Stream转化为IntStream、LongStream。。。。\n\n```java\nfinal IntStream intStream = stream.mapToInt(StringBuffer::length);\nfinal DoubleStream doubleStream = stream.mapToDouble(StringBuffer::length);\nfinal LongStream longStream = stream.mapToLong(StringBuffer::length);\n```\n\n\n\n#### 集合工具类\n\n> 许多开源机构为我们提供了操作集合的工具类。\n\n##### apache\n\n> Apache.commons下的commons-collectionsX包对java集合框架(java collection framework)做扩展。\n\n![image-20220818094842448](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282254261.png)\n\n- Bag -  简化了一个对象在集合中存在多个副本的操作\n- BidiMap -  提供双向映射，可通过键查找值，也可以通过值查找键\n- Iterators - 方便迭代\n- Transforming Decorators   在添加元素时，修改集合元素\n- CompositeCollection  需要统一处理多个集合时可用\n\n###### Bag\n\n> `Bag`简化了一个对象存在多个副本的操作。\n\nHashBag  & TreeBag\n\n> hashBag & TreeBag的继承关系如下图所示：\n>\n> TreeBag 相较于HashBag多实现一个接口 ： SortedBag即表现为一个有序的bag。\n>\n> HashBag其内封装了一个HashMap，key是元素，value是元素个数。\n>\n> TreeMap其内封装了一个TreeMap，key是元素，value是元素个数。\n\n![image-20220818151047171](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282254561.png)\n\n\n\n> hashBag&TreeBag的创建。\n\n```java\npublic HashBag() {\n    super(new HashMap<E, MutableInteger>());\n}\npublic HashBag(final Collection<? extends E> coll) {\n    this();\n    addAll(coll);\n}\n\nprivate transient Map<E, MutableInteger> map;\nprotected AbstractMapBag(final Map<E, MutableInteger> map) {\n    super();\n    this.map = map;\n}\n```\n\n> hashBag&TreeBag基本使用\n\n```java\n/**\n * hashBag底层是一个hashMap 元素是key值，添加个数是value\n * 可以通过add(object,nCopies)方法为每个元素添加n个副本\n * 如果add两次则会跟新value值（加一）\n */\nStringBuilder sb1 = new StringBuilder(\"a\");\nStringBuilder sb2 = new StringBuilder(\"b\");\nStringBuilder sb3 = new StringBuilder(\"c\");\nBag<Object> hashBag = new HashBag<>();\n\nhashBag.add(sb1);\nhashBag.add(sb1);\nhashBag.add(sb2, 3);\nhashBag.add(sb3, 3);\nSystem.out.println(\"Bag+元素个数:\" + hashBag.size());\nSystem.out.println(\"Bag中sb1个数:\" + hashBag.getCount(sb1));\nString result1 = hashBag.stream().map(Object::toString).collect(Collectors.joining(\",\", \"[\", \"]\"));\nSystem.out.println(\"HashBag 内容：\" + result1);\n//可以使用Collection作为构造方法参数\nBag<Object> hashBag2 = new HashBag<>(Arrays.asList(\"1\", \"2\", \"3\"));\nString result3 = hashBag2.stream().map(Object::toString).collect(Collectors.joining(\",\", \"[\", \"]\"));\nSystem.out.println(\"hashBag2 内容：\" + result3);\n\n/**\n * TreeBag：底层封装了一个TreeMap。\n * 其实可依发现HashBag中的元素是无序的，那么TreeBag就是一个有序的Bag\n */\nTreeBag<String> treeBag = new TreeBag<>(Arrays.asList(\"99\", \"2\", \"3\", \"7\"));\nString result2 = treeBag.stream().map(Object::toString).collect(Collectors.joining(\",\", \"[\", \"]\"));\nSystem.out.println(\"TreeBag 内容：\" + result2);\n```\n\n\n\nCollectionBag\n\n> `CollectionBag`没有无参构造，必须依赖一个`Bag`类型的参数。`CollectionBag`只是对`Bag`的封装，任何操作实际上操作的是封装的Bag。\n\n```java\n/**\n * CollectionBag的创建依赖于现有Bag，不可使用Collection作为构造方法参数\n *\n * 其内方法是对Bag的一层封装，实际调用的还是Bag的方法\n */\nBag<Object> collectionBag = CollectionBag.collectionBag(hashBag);\nString result4 = collectionBag.stream().map(Object::toString).collect(Collectors.joining(\",\", \"[\", \"]\"));\nSystem.out.println(\"CollectionBag的内容：\" + result4);\n\nBag<Object> collectionBag2 = CollectionBag.collectionBag(treeBag);\nString result5 = collectionBag2.stream().map(Object::toString).collect(Collectors.joining(\",\", \"[\", \"]\"));\nSystem.out.println(\"CollectionBag2的内容：\" + result5);\n```\n\n\n\nPredicatedBag & PredicatedSortedBag\n\n> `PredicatedBag`的构造器依赖一个现有Bag和一个`Predicate`，可以对加入进来的元素进行限制，比如不允许添加空元素。\n\n```java\n/**\n * 创建PredicatedBag也依赖一个现有Bag，以及一个‘判断器’\n */\nPredicatedBag<Object> predicatedBag = PredicatedBag.predicatedBag(collectionBag, Objects::nonNull);\nString result6 = predicatedBag.stream().map(Object::toString).collect(Collectors.joining(\",\", \"[\", \"]\"));\nSystem.out.println(\"predicatedBag的内容:\" + result6);\n```\n\n\n\nSynchronizedBag & SynchronizedSortedBag\n\n```java\n/**\n * SynchronizedBag同步的bag，使用Synchronized同步代码块实现同步。\n * 可以指定锁对象，如果不指定则锁this\n */\nSynchronizedBag<Object> synchronizedBag = SynchronizedBag.synchronizedBag(collectionBag);\nSynchronizedSortedBag<Object> synchronizedSortedBag = SynchronizedSortedBag.synchronizedSortedBag(treeBag);\n```\n\n\n\nTransformedBag\n\n> 对原集合进行转化，一般不会用这个，java8提供的`Stream API`有一个Map方法，可以将结果映射。\n\n- transformingBag 方法，只会对后面add进来的元素进行转换，而对之前的初始化的不会转化\n- transformedBag方法，会对后加的以及一开始初始化的都进行转化\n\n```java\n/**\n * TransformedBag\n */\nBag<Object> bag1 = TransformedBag.transformingBag(hashBag, Object::hashCode);\nbag1.add(\"XX\", 3);\nString result8 = bag1.stream().map(Objects::toString).collect(Collectors.joining(\",\", \"[\", \"]\"));\nSystem.out.println(\"TransformedBag.transformingBag \" + result8);\n\nBag<Object> bag2 = TransformedBag.transformedBag(hashBag, Object::hashCode);\nbag2.add(\"xx\",3);\nString result9 = bag2.stream().map(Objects::toString).collect(Collectors.joining(\",\", \"[\", \"]\"));\nSystem.out.println(\"TransformedBag.transformingBag \" + result9);\n```\n\n\n\nUnmodifiableBag\n\n> 不可修改的Bag。\n\n\n\nBagUtils\n\n> 协助生成bag，其实调用的就是`XXXBag.xxxBag()`方法，每一个Bag类都会有一个静态方法，用于生成Bag。\n\n```java\n/**\n * BagUtils  Bag工具类 协助生成Bag\n */\nfinal Bag<Object> bag = BagUtils.collectionBag(new HashBag<>());\n```\n\n###### BidiMap\n\n> BidiMap -  提供双向映射，可通过键查找值，也可以通过值查找键\n\nDualHashBidiMap\n\n> 双重hashMap。其内封装了两个hashMap，bidimap的put()方法中key-value有任意重复的此条记录会被覆盖\n\n```java\n/**\n * bidimap\n * - bidimap的put()方法中key-value有任意重复的此条记录会被覆盖\n */\n@Test\npublic void testBidiMap() {\n\n    final DualHashBidiMap<String, Integer> dualHashBidiMap = new DualHashBidiMap<>();\n    dualHashBidiMap.put(\"a\", 1);\n    dualHashBidiMap.put(\"b\", 2);\n    dualHashBidiMap.put(\"c\", 3);\n    dualHashBidiMap.put(\"d\", 3);\n    dualHashBidiMap.put(\"e\", 12);\n    dualHashBidiMap.put(\"e\", 123);\n\n    System.out.println(dualHashBidiMap.get(\"a\"));\n    System.out.println(dualHashBidiMap.getKey(1));\n    System.out.println(dualHashBidiMap.getKey(3));\n    System.out.println(dualHashBidiMap.values());\n    System.out.println(dualHashBidiMap.keySet());\n}\n```\n\n```bash\n1\na\nd\n[1, 2, 3, 123]\n[a, b, d, e]\n```\n\n\n\n###### iterators\n\n> `iterators`提供了许多迭代包装类使我们很容易迭代集合，并且支持逆向迭代\n\nArrayItertor\n\n> 数组迭代器，接收一个数组、迭代起始下标、迭代终止下标。\n\n> 只接受迭代数组，因为next()方法会调用，本地静态方法`Array.get(array,index)`\n\n```java\npublic static native Object get(Object array, int index)\n    throws IllegalArgumentException, ArrayIndexOutOfBoundsException;\n```\n\n> 简单使用\n\n```java\n /**\n * ArrayIterator 数组迭代器，接受一个数组、起始下标、终止下标\n */\nIterator<Object> arrayIterator1 = new ArrayIterator<>(Arrays.asList(\"1\", \"2\", \"3\").toArray(),0,2);\nwhile (arrayIterator1.hasNext()) {\n    System.out.println(arrayIterator1.next());\n}\n```\n\n\n\nArrayListIterator\n\n> 接收一个数组，起始下标，终止下标。\n>\n> 对`ArrayIterator`的拓展，支持正向迭代、也支持反向迭代。\n\n```java\n/**\n * ArrayListIterator \n * 支持正向迭代、逆向迭代\n */\nArrayListIterator<Object> arrayListIterator2 = new ArrayListIterator<>(Arrays.asList(\"1\", \"2\", \"3\",\"4\", \"5\", \"6\").toArray(), 2, 6);\nwhile (arrayListIterator2.hasNext()) {\n    System.out.println(arrayListIterator2.next());\n}\nwhile (arrayListIterator2.hasPrevious()) {\n    System.out.println(arrayListIterator2.previous());\n}\n```\n\n\n\nBoundedIterator\n\n> 有边界的迭代器，接收三个参数`Iterator`迭代器、`offeset`偏移量、`max`迭代数量。\n>\n> 如下表示从下标2开始、迭代2个元素，结果是 3、4\n\n```java\nList<String> list = Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\");\nBoundedIterator<String> boundedIterator = new BoundedIterator<>(list.iterator(), 2, 2);\nwhile (boundedIterator.hasNext()) {\n    System.out.println(boundedIterator.next());\n}\n```\n\nCollectionIterator\n\n```java\n//比较器，会影响迭代结果\nprivate Comparator<? super E> comparator = null;\n//迭代器\nprivate List<Iterator<? extends E>> iterators = null;\n//待比较的元素\nprivate List<E> values = null;\n//迭代器是否还有值\nprivate BitSet valueSet = null;\nprivate int lastReturned = -1;\n```\n\n```java\nCollatingIterator(final Comparator<? super E> comp, final Iterator<? extends E>[] iterators)\nCollatingIterator(final Comparator<? super E> comp, final Collection<Iterator<? extends E>> iterators)\n```\n\n> 接收一个或多个迭代器和一个比较器，迭代结果会按一定顺序输出(原集合元素顺序不变)。\n\n```java\nSystem.out.println(\"CollatingIterator\");\nList<String> list1 = Arrays.asList(\"5\", \"4\", \"1\", \"2\", \"3\");\nList<String> list2 = Arrays.asList(\"2\", \"1\", \"c\", \"d\", \"e\");\nCollatingIterator<String> collatingIterator = new CollatingIterator<>(String::compareTo, list1.iterator(), list2.iterator());\nwhile (collatingIterator.hasNext()) {\n    System.out.print(collatingIterator.next());\n}\n```\n\n输出：\n\n> [21]54123[cde]\n\nMapIterator\n\n> util包下的map的迭代，如果想迭代key或value，需要借助entry。\n\n```java\nSystem.out.println(\"MapIterator\");\nfinal HashMap<Object, Object> map = new HashMap<>(8);\nmap.put(\"1\", \"a\");\nmap.put(\"2\", \"b\");\nmap.put(\"3\", \"c\");\nmap.put(\"4\", \"d\");\nmap.put(\"5\", \"e\");\nmap.put(\"6\", \"f\");\nmap.put(\"7\", \"g\");\nmap.put(\"8\", \"h\");\n//entry迭代器\nfinal Iterator<Map.Entry<Object, Object>> iterator =\n        map.entrySet().iterator();\nwhile (iterator.hasNext()) {\n    final Map.Entry<Object, Object> next = iterator.next();\n    System.out.println(\"key值:\" + next.getKey() + \"value值:\" + next.getValue());\n}\n//key迭代器\nmap.keySet().iterator();\n//value迭代器\nmap.values().iterator();\nfinal HashedMap<Object, Object> hashedMap = new HashedMap<>(map);\nfinal MapIterator<Object, Object> hashedMapIterator = hashedMap.mapIterator();\nwhile (hashedMapIterator.hasNext()) {\n    System.out.println(hashedMapIterator.next());\n    System.out.println(\"key值:\" + hashedMapIterator.getKey() + \"value值:\" + hashedMapIterator.getValue());\n}\n```\n\n\n\n###### CollectionUtils\n\n> `cpache`的集合工具类，提供很多有用的方法，此工具类在java8之前很有用，但java8的Stream  api提供了类似功能，因此许多方法都可以用stream代替。\n\nignor  null\n\n添加元素时忽略null值\n\n```java\nfinal List<String> listX = new ArrayList<>(Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\"));\nfinal List<String> listY = new ArrayList<>(Arrays.asList(\"1\", \"2\", \"c\", \"b\", \"5\"));\nSystem.out.println(CollectionUtils.addIgnoreNull(listX, null));\nSystem.out.println(CollectionUtils.addIgnoreNull(listX, \"6\"));\n```\n\nmerge & sort\n\n> 合并排序，如果不指定比较器，则会自然排序，如果指定比较器则按指定比较器来排序\n\n```java\nSystem.out.println(\"merge  and  sort\");\nfinal List<String> collate1 = CollectionUtils.collate(listX, listY);\nSystem.out.println(collate1);\nfinal List<String> collate2 = CollectionUtils.collate(listX, listY, String::compareTo);\nSystem.out.println(collate2);\n```\n\n安全空检查\n\n> 很多时候对集合遍历的时候，需要对集合进行安全空检查，CollectionUtils为我们提供了一套方式\n\n```java\nSystem.out.println(\"安全空检查\");\nSystem.out.println(CollectionUtils.isEmpty(listX));\nSystem.out.println(CollectionUtils.isNotEmpty(listX));\n```\n\n交集  并集  外集\n\n```java\nSystem.out.println(\"交集\" + CollectionUtils.intersection(listX, listY));\nSystem.out.println(\"并集\" + CollectionUtils.union(listX, listY));\nSystem.out.println(\"外集\" + CollectionUtils.subtract(listX, listY));\n```\n\n\n\n###### 小结\n\n> java8的Stream可以适用于大部分的集合操作。\n\n交集 外集 并集\n\n```java\nfinal List<String> collect1 = listX.stream().filter(listY::contains).collect(Collectors.toList());\nSystem.out.println(\"交集\" + collect1);\nfinal List<String> collect2 = listX.stream().filter(ele -> !listY.contains(ele)).collect(Collectors.toList());\nSystem.out.println(\"外集\" + collect2);\n\nSystem.out.println(\"Stream 合并集合\");\nfinal ArrayList<List<String>> lists = new ArrayList<>();\nlists.add(listX);\nlists.add(listY);\nfinal List<Object> collect = lists.stream().flatMap(Collection::stream).collect(Collectors.toList());\nSystem.out.println(\"并集\"+collect);\n```\n\n其他的诸如过滤、排序、转换(映射)等Stream都可以\n\n\n\n#### Arrays.asList(T ...t)\n\n> 使用此方式创建集合需要注意什么？\n\n- 此方式创建的集合是Arrays的一个子类ArrayList，并未实现增删方法，不可对其进行==增删==操作。\n\n  会报出`java.lang.UnsupportedOperationException`\n\n- 可进行修改操作\n\n- 可将其作为参数，构造真正的ArrayList\n\n\n\n#### 集合中的fail -fast\n\n> fail- fast 快速失败，一种一旦检测出系统异常就会立刻上报的机制，此种机制可使系统避免在有安全隐患的情况下继续运行，常用的比如说参数校验。\n>\n> 看一下集合中的fail-fast机制：\n\n常常出现在迭代中，防止下标越界或迭代不完全，以arrayList为例\n\nexpectedModCount此属性在获取迭代器的时候会赋值为modCount，如果在迭代时我们通过修改集合改变modeCount则会报出此异常\n\n```java\nfinal void checkForComodification() {\n    if (modCount != expectedModCount)\n        throw new ConcurrentModificationException();\n}\n```\n\n> 对集合进行增删操作会触发fail-fast机制\n\n```java\nfinal List<String> list = new ArrayList<>(Arrays.asList(\"1\", \"2\", \"3\"));\nfinal Iterator<String> iterator = list.iterator();\nwhile (iterator.hasNext()) {\n  //list.remove(\"1\");\n  //list.add(\"1\");\n  iterator.next();\n}\n```\n\n> foreach也会触发fail-fast机制，因为其底层就是使用迭代器迭代的\n\n如果安装了阿里代码规约插件的话，那么已经帮你提示出来了\n\n```java\nfinal List<String> list = new ArrayList<>(Arrays.asList(\"1\", \"2\", \"3\"));\nfor (String s : list) {\n    list.add(\"a\");\n}\n```\n\n反编译看一下字节码\n\n![image-20220821180247553](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208211804530.png)\n\n\n\n####  集合中的fail - safe\n\n> 为了避免fail-fast机制，可以使用采用fail-safe机制的集合类，这样的类在对集合进行操作的时候不会直接操作集合内容，而是通过拷贝一份，在拷贝的内容上操作，最后需要同步更改，则同步更改。\n\n\n\n##### CopyOnWriteArrayList\n\n> 这就是一个fail-safe集合类。\n>\n> 其内部的add  、reomve、set等操作都使用ReentrantLock保证同步，任何操作都是在拷贝对象数组上进行，最后再替换原集合对象数组。\n\n> COW集合的迭代器:其内部包含了一个源集合对象数组的快照、副本、拷贝(snapshot)，任何迭代都是在此对象数组上完成的。并且由于COW在修改对象数组的时候，COW都会拷贝一份，所以并不会影响迭代器中的拷贝所指向的对象数组\n\n> 使用COW代替ArrayList就不会发生CME异常\n\n```java\nCopyOnWriteArrayList<String> cowList = new CopyOnWriteArrayList<>(Arrays.asList(\"1\",\"2\",\"3\"));\nfor (String s : cowList) {\n    if (\"1\".equals(s)){\n        cowList.remove(s);\n    }\n}\n```\n\n\n\n但是也造成了一个问题：我们对集合的修该，修改对象数组，是对迭代器不可见的，因为在集合修改的时候，会使用System.arrayCopy()方法生成一个新的对象数组。\n\n```java\nCopyOnWriteArrayList<String> cowList = new CopyOnWriteArrayList<>(Arrays.asList(\"1\",\"2\",\"3\"));\nIterator<String> iterator = cowList.iterator();\n//fail-sfae 集合修改\nfor (String s : cowList) {\n    if (\"1\".equals(s)){\n        cowList.remove(s);\n    }\n}\n//已经修改\nSystem.out.println(cowList);\n//但对迭代器不可见\nwhile (iterator.hasNext()) {\n    System.out.println(iterator.next());\n}\n```\n\n打印结果：\n\n```bash\n[2, 3]\n1\n2\n3\n```\n\n\n\n###### 特点\n\n- copy-on-write，写时复制，所有修改操作在快照上操作\n- 同步，使用ReenTrantLock\n- 写时加锁，避免拷贝出多个副本，导致并发写\n- 读时不加锁，读写分离。会导致弱一致性问题：读取的不是最新数据\n\n\n\n##### 循环中remove\n\n> fail-fast机制出现于迭代器中修改集合操作，触发fail-fast机制，导致并发异常。\n\n- forii   普通for循环\n- iterator  的remove方法  （主要思想就是在修改modCount的同时修改expectedModCount）\n- fail-safe集合（fail-safe集合的迭代器一般不支持remove方法，直接使用集合的remove方法）\n- 增强for：fail-fast机制在next方法中调用，在修改集合后避免使用next方法即可\n\n```java\nList<String> list = new ArrayList<>(Arrays.asList(\"1\",\"2\",\"3\"));\nfor (String s : list) {\n    if (\"1\".equals(s)){\n        list.remove(s);\n    }\n    break;\n}\nSystem.out.println(list);\n```\n\n\n\n### IO\n\n> 文件操作是编程一部分，学习一下IO流。\n\n####  字符流&字节流\n\n> 从名称来看区别在于流的传输方式：字节  or    字符。\n\n有了字节流为何还需要字符流？\n\n字符流可以认为是字节流＋编码方式。编码方式指导字节流如何处理字节，将其组合成字符。原因就在于方便操作，对于中文可能不同的编码方式得到的字节数据是不同的，那么使用字节流读取可能出现乱码的情况，那么有了字符流可以指定编码，指导字节流读几个字节作为一个汉字。\n\n\n\n##### 位、字节、字符\n\n- Bit   最小二进制单位，0或1.\n- Byte  字节，1 Byte = 8 Bit，取值 [-128,127]\n- Char 字符，1Char = 16Bit，人能直观认识的最小单位，取值 [0,2^16^-1]\n\n##### 字节流\n\n> 操作字节，用于读取单个字节或字节数组，直接对文件进行操作，无需缓冲区（读出来的数据直接就可以用）。\n>\n> 主要操作类是：InputStream和OutputStream的子类\n\nInputStream常用子类：\n\n- FileInputStream：文件输入流，用于读取文件信息到内存中。\n- ByteArrayInputStream：字节数组输入流\n- ObjectInputStream: 对象输入流\n- FilterInputStream  过滤流\n\n\n\nOutputStream常用子类：\n\n- FileOutputStram:文件输出流，用于将数据输出到文件中\n- ByteArrayOutputStream:字节数组输出流\n- ObjectOutputStream:对象输出流\n- FilterOutputStream  \n\n###### FileInputStream & FileOutputStream\n\n> 用于读取文件信息到内存和将内存中的数据输出到文件\n\n查看一下FileInputStream  api\n\n```java\n//文件描述实例，由java创建，不用我们创建\nprivate final FileDescriptor fd;\n//文件路径\nprivate final String path;\n//用于读取、写入、映射和操作文件的通道。与FileInputStream唯一关联。底层，不用管\nprivate FileChannel channel = null;\n//对象锁，阻塞io，使用Synchronized关键字阻塞\nprivate final Object closeLock = new Object();\n//资源是否关闭\nprivate volatile boolean closed = false;\n\n//使用文件名创建一个文件输入流会调用FileInputStream(File file)方法\npublic FileInputStream(String name) throws FileNotFoundException；\npublic FileInputStream(File file) throws FileNotFoundException；\n//打开流，本地方法由c\\C++编写，无需主动调用，构造方法已经调用，且是私有方法\nprivate native void open0(String name) throws FileNotFoundException;\nprivate void open(String name) throws FileNotFoundException {open0(name);}\n//从流中读取一个字节，声明式异常，需要主动处理\npublic int read() throws IOException；\nprivate native int read0() throws IOException\n//从流中读取off开始读取len个字符到字符数组中指定下标处,并返回读取长度。一般来说从0开始\nprivate native int readBytes(byte b[], int off, int len) throws IOException;\npublic int read(byte b[]) throws IOException {\n    return readBytes(b, 0, b.length);\n}\n//跳过指定长度字符，返回跳过长度。移动指针\npublic long skip(long n) throws IOException {\n  return skip0(n);\n}\nprivate native long skip0(long n) throws IOException;\n//剩余字节数\npublic int available() throws IOException {\n  return available0();\n}\nprivate native int available0() throws IOException;\n//关闭流，必须关闭资源\npublic void close() throws IOException；\n```\n\n查看一下FileOutputStream  api\n\n```java\n//是否追加文件内容。默认false，即覆盖\nprivate final boolean append;\npublic FileOutputStream(String name) throws FileNotFoundException；\npublic FileOutputStream(String name, boolean append) throws FileNotFoundException；\npublic FileOutputStream(File file) throws FileNotFoundException；\npublic FileOutputStream(File file, boolean append) throws FileNotFoundException；\n//open  open0\n//写入文件，字节byte可直接转化为int，安全不会溢出，没有负数\nprivate native void write(int b, boolean append) throws IOException;\nprivate native void writeBytes(byte b[], int off, int len, boolean append) throws IOException;\n```\n\n\n\n> 常用操作：这里使用try with resource语法糖，编译器会自动帮我们关闭资源，可以反编译查看\n\n```java\n@Test\npublic void inputStreamTest1() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile/test.txt\";\n    try (FileInputStream fin = new FileInputStream(filePath)) {\n        //跳过指定长度字节\n        final long skip = fin.skip(3L);\n        System.out.println(skip);\n        final byte[] bytes = new byte[5];\n        //从1开始读取4个字节，放入字节数组指定下标处\n        final int read = fin.read(bytes, 1, 4);\n        System.out.println(read);\n        for (byte aByte : bytes) {\n            System.out.println(Character.valueOf((char) aByte));\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n@Test\npublic void outputStreamTest1() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile/test.txt\";\n    try (final FileOutputStream fop = new FileOutputStream(filePath, true)) {\n        fop.write(\"可爱\".getBytes());\n        fop.write(\"abc\".getBytes());\n        //刷新流，将此之前的所有数据给操作系统，让操作系统写入硬件设备\n        fop.flush();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n###### ByteArrayInputStream & ByteArrayOutputStream\n\n> 字节数组输入输出流。内部组合一个字节数组，用于缓冲数据。\n\n```java\n@Test\npublic void byteArrayInputStreamTest1() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile/test.txt\";\n    try (final FileOutputStream fop = new FileOutputStream(filePath, true);\n         final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(\"abcd\".getBytes(StandardCharsets.UTF_8))) {\n        System.out.println((char)byteArrayInputStream.read());\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n@Test\npublic void byteArrayOutputStreamTest1() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile/test.txt\";\n    try (final FileOutputStream fop = new FileOutputStream(filePath, true);\n         final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(1024)) {\n        //写入到字节数组\n        byteArrayOutputStream.write(\"可可爱爱\".getBytes());\n        //一次性写入到，另一个输出流\n        byteArrayOutputStream.writeTo(fop);\n        //刷新流，将此之前的所有数据给操作系统，让操作系统写入硬件设备\n        fop.flush();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n###### ObjecInputStream & ObjectOutputStream\n\n> 对象输入输出流，一般用于序列化操作，又称为序列化流和反序列化流。ObjectOutputStream用于将对象序列化输出到文件中，持久化保存，ObjecInputStream用于将对象从文件中读出来。\n>\n> 一般用于数据传输，或当某个对象实例生命周期已经结束，但是需要保存其状态，以便下此直接反序列化恢复的情况。\n\n首先作为字节流，它拥有字节流的所有相关操作\n\n```java\n@Test\npublic void objectOutputStreamTest1() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile/objectTest.txt\";\n    try (final ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(filePath,false))) {\n        //写入到字节数组\n        objectOutputStream.write(\"xxx\".getBytes());\n        //刷新流，将此之前的所有数据给操作系统，让操作系统写入硬件设备\n        objectOutputStream.flush();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n作为对象流，设计目的就是为了操作对象:\n\n- class类必须实现Serializable接口，否则会报出`java.io.NotSerializableException`异常\n- 序列号serialVersionUID对应唯一类，不可随意修改，在反序列化时会去匹配。如果修改则报出`java.io.InvalidClassException`异常\n- 被transient修饰的属性在序列化时会被忽略\n\n例子：\n\n```java\n@Data\n@Accessors(chain = true)\nclass Person   implements Serializable {\n    private static final long serialVersionUID = -8861126921891657698L;\n  \n    String str1;\n    transient String str2;\n    final String str3 = \"123\";\n    static String str4;\n    int age;\n    Date birthday;\n}\n@Test\npublic void objectInputStreamTest1() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile/objectTest.txt\";\n    try (final ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(filePath))) {\n        final Person o = (Person) objectInputStream.readObject();\n        System.out.println(o);\n    } catch (IOException | ClassNotFoundException e) {\n        e.printStackTrace();\n    }\n}\n@Test\npublic void objectOutputStreamTest2() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile/objectTest.txt\";\n    try (final ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(filePath, false))) {\n        final Person person = new Person();\n        person.setStr1(\"str1\")\n                .setStr2(\"str2\")\n                .setAge(1)\n                .setBirthday(Calendar.getInstance().getTime());\n        objectOutputStream.writeObject(person);\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n\n\n###### FilterInputStream & FilterOutputStream\n\n> 过滤流，装饰器模式，可以对字节流进行包装实现额外功能。\n\n过滤流常用子类：\n\n- DateInputStream ：基本数据类型流，提供基本数据类型读取写入操作方法\n- BufferedInputStream : 缓冲输出流,其内维护一个字节数组，避免每次都和文件交互\n- PushbackInputStream\n- LineNumberInputStream\n\n> DateInputStream ,基本数据类型流，提供对基本数据类型写入、读取操作方法，其对基本字节流做了一个封装，约定如何写入字节，底层还是调用基本字节流写入字节。比如int占32位，4个字节，那么通过移位运算将其拆分为四个字节逐个写入字节，读取时逐个读取，并按写入规则转化数据。\n\n例一：\n\n```java\n@Test\npublic void dataOutputStreamTest1() {\n    String filePath = \"D:\\\\File\\\\Desktop\\\\blogXX\\\\foot\\\\testfile\\\\dataStreamFile.txt\";\n    try (final DataOutputStream dataOutputStream = new DataOutputStream(new FileOutputStream(filePath, false))) {\n        //作为字节流，拥有字节流相关操作，写入字节或字节数组\n        //dataOutputStream.write(\"开开心心\".getBytes(StandardCharsets.UTF_8));\n        dataOutputStream.writeUTF(\"可可爱爱\");\n        dataOutputStream.writeUTF(\"可可爱爱\");\n        dataOutputStream.writeUTF(\"开开心心\");\n        dataOutputStream.flush();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n@Test\npublic void dataInputStreamTest1() {\n    String filePath = \"D:\\\\File\\\\Desktop\\\\blogXX\\\\foot\\\\testfile\\\\dataStreamFile.txt\";\n    try (final DataInputStream dataInputStream = new DataInputStream(new FileInputStream(filePath))) {\n        while (dataInputStream.available()>0){\n            System.out.println(dataInputStream.readUTF());\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n\n\n> BufferedOutputStream  缓冲输出流，其内部维护一个字节数组，数据首先存放于字节数组，当调用flush方法或字节数组已经满了的情况，将字节数组中的字节一次性写入文件。如此不必频繁通过io通道和文件打交道。\n>\n> BufferedInputStream 缓冲输入流，内部有一个缓冲数组，数据读出来先存放于缓存数组中，当真正需要的时候将数据拷贝出来。\n\n例二：\n\n```java\n@Test\npublic void bufferedOutputStreamTest1() {\n    String filePath = \"D:\\\\File\\\\Desktop\\\\blogXX\\\\foot\\\\testfile\\\\bufferStreamFile.txt\";\n    try (final FilterOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(filePath, false), 1024)) {\n        //作为字节流，拥有字节流相关操作，写入字节或字节数组\n        bufferedOutputStream.write(\"abcde\".getBytes(StandardCharsets.UTF_8));\n        bufferedOutputStream.flush();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n@Test\npublic void bufferedInputStreamTest1() {\n    String filePath = \"D:\\\\File\\\\Desktop\\\\blogXX\\\\foot\\\\testfile\\\\bufferStreamFile.txt\";\n    try (final FilterInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(filePath))) {\n         byte[] bytes = new byte[1024];\n        while (bufferedInputStream.available() > 0) {\n            bufferedInputStream.read(bytes);\n            System.out.println(Arrays.toString(bytes));\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n\n\n#####  字符流\n\n> 操作字符，需要缓冲区，操作Reader、Writer的子类\n\n![image-20220824221348711](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282254476.png)\n\nRead常用子类：\n\n- InptStreamReader ：将字节输入流转为字符输入流\n- StreamDecoder:流解码器\n\n- FileReader  文件输入流\n- BufferedReader：缓存字符输入流\n\nWriter常用子类\n\n- OutputStreamWriter:将字符输出流转化为字节输出流\n\n- FileWriter   文件输出流\n- BufferedReader  缓存字符输出流\n\n\n\n###### InputSteamReader & OutputStreamWriter\n\n> 字节字符转化流。以规定的流解码器去读取字节数组，最后和转化为字符输出，我们只需要指定编码集。\n\n例一：\n\n```java\n@Test\npublic void testFileOutputStream1() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile\";\n    try (final OutputStreamWriter outputStreamWriter = new OutputStreamWriter(new FileOutputStream(new File(filePath, \"dataStreamFile.txt\")), StandardCharsets.UTF_8)) {\n        outputStreamWriter.write(\"hhhhhhhhhhhh哈哈哈哈\");\n        outputStreamWriter.flush();\n    } catch (IOException e) {\n    }\n}\n@Test\npublic void testFileInputStream1() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile\";\n    try (final InputStreamReader inputStreamReader = new InputStreamReader(new FileInputStream(new File(filePath, \"dataStreamFile.txt\")), StandardCharsets.UTF_8)) {\n        final char[] buffer = new char[1024];\n        int len = 0;\n        while ((len = inputStreamReader.read(buffer)) > 0) {\n            System.out.println(String.valueOf(buffer, 0, len));\n        }\n    } catch (IOException e) {\n    }\n}\n```\n\n\n\n###### FileReader  & FileWriter\n\n> 文件输入输出流，操作文件的便利类。\n>\n> 对InputStreamReader的封装。无需指定字符集，默认使用系统文件字符集。\n\n查看系统文件字符集：\n\n```java\n\nfinal String s = AccessController.doPrivileged(\n\tnew GetPropertyAction(\"file.encoding\"));\nSystem.out.println(s);\n```\n\n![image-20220824231942206](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282254532.png)\n\n```java\n@Test\npublic void testFileWriter1() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile\";\n    try (final FileWriter fileWriter = new FileWriter(new File(filePath,\"dataStreamFile.txt\"))){\n        fileWriter.write(\"12331\");\n        //追加写入，返回this，类似于StringBuilder 的append\n        fileWriter.append(\"xxxxxx\").append(\"追加\");\n        //将流刷入操作系统，让操作系统去写入硬件，最终结果是否写入成功由操作系统决定\n        //如果不刷新，流也不关闭，数据不会写入硬件\n        fileWriter.flush();\n    }catch (IOException e){\n    }\n}\n@Test\npublic void testFileReader1() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile\";\n    try(final FileReader fileReader = new FileReader(new File(filePath,\"dataStreamFile.txt\"))){\n        final char[] buffer = new char[1024];\n        int len  = 0;\n        while ((len = fileReader.read(buffer)) > 0) {\n            System.out.println(String.valueOf(buffer,0, len));\n        }\n    }catch (IOException e){\n    }\n}\n```\n\n###### BufferedReader & BufferedWriter\n\n> 缓冲字符流，上面的FileRead存在不可自定义字符编码的问题，那么使用BufferedReader可完美解决此问题。\n>\n> BufferedReader 是对OutputStreamReader的增强和包装，其内提供了读取一行字符的方法，以及将所有字符读出以Stream<String>流的方式返回。以上都是基于字符数组实现，默认容量是8192。\n\n例子：\n\n```java\n@Test\npublic void testBufferedWriter1() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile\";\n    try (final BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(filePath, \"dataStreamFile.txt\")), StandardCharsets.UTF_8))) {\n        bufferedWriter.write(\"可可爱爱\");\n        bufferedWriter.write(\"快快乐乐\");\n        bufferedWriter.write('a');\n        bufferedWriter.write(96);\n        bufferedWriter.write(new char[]{'x','x'});\n        bufferedWriter.write(\"\\n\");\n        bufferedWriter.write(\"\\t\");\n        //新起一行\n        bufferedWriter.newLine();\n        bufferedWriter.write(\"开开心心\");\n    } catch (IOException e) {\n\n    }\n}\n\n@Test\npublic void testBufferedReader1() {\n  String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile\";\n  try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(new File(filePath, \"dataStreamFile.txt\")), StandardCharsets.UTF_8))) {\n    final char[] chars = new char[1];\n    final int read = bufferedReader.read();\n    System.out.println(new String(chars, 0, 1));\n    String buffer = \"\";\n    while ((buffer = bufferedReader.readLine()) != null) {\n      System.out.println(buffer);\n    }\n    //一次性读出来\n    BufferedReader bufferedReader1 = new BufferedReader(new InputStreamReader(new FileInputStream(new File(filePath, \"dataStreamFile.txt\")), StandardCharsets.UTF_8));\n    bufferedReader1.lines().forEach(System.out::println);\n  } catch (IOException e) {\n\n  }\n}\n```\n\n\n\n###### 字符流需要手动flush\n\n> 如果操作字符流方法内没有自动帮我们flush，那么想要将数据刷入文件需要手动flush\n\n```java\n@Test\npublic void testFlush() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/myfoot/foot/testfile\";\n    OutputStreamWriter outputStreamWriter = null;\n    try {\n        outputStreamWriter = new OutputStreamWriter(new FileOutputStream(new File(filePath, \"dataStreamFile.txt\")));\n        //如此写入不了，没有flush 也没有 关闭流\n        outputStreamWriter.write(\"你好呀\");\n    } catch (IOException e) {\n    }\n}\n```\n\n\n\n\n\n##### 字节流与字符流转化\n\n> java io包下除了字节流与字符流以外，还包含一组字节流-字符流转化流。\n\nInputStreamReader，是Reader的子类属于字符流，可以将输入的字节流转化为输入的字符流。\n\nOutputStreamWriter，是Writer的子类属于字符流，可以将输出的字符流转换为输出的字节流。\n\n##### 输入输出流\n\n> 输入输出流是相对于参考系来说的，此参考系为存储数据的介质，往介质中存数据则为输入流，从介质中读出数据则为输出流。\n\n比如：\n\n将文件中数读出来，存到内存中，则为输入流，使用FileInputStream、FileReader\n\n将内存中的数据输出到文件中，则为输出流，使用FileOutputStream、FileWriter\n\n\n\n### 反射\n\n> 反射式java为程序员提供的强大机制，赋予程序可以在运行期间，知道任意类的所有属性和方法，调用或修改任意对象的属性和方法的能力。\n>\n> Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。而这也是Java被视为动态语言的一个关键性质。\n\n#### Class类\n\n> Class类用于封装加载到jvm中的类(包括接口和类)。当一个类被装载进jvm就会生成一个与之唯一对应的Class对象，通过这个Class对象我们就知道此类的所有信息。\n>\n> 在程序运行时，jvm会检查所需加载的类对应的Class对象是否已经加载，如果没有加载，jvm会根据类名查找对应的Class文件，并将其加载入jvm，jvm会保证每个class类只会生成唯一对应的class对象。\n\n获取Class对象的方式：\n\n- 对象.getClass()方法\n- 类名.class\n- Class.forName(\"class类全路径\")  第二个参数表示是否触发初始化，默认触发，且只触发一次\n\n```java\n@Test\npublic void test() {\n    final ClassPerson classPerson = new ClassPerson();\n    //对象.getClass\n    final Class<? extends ClassPerson> aClass = classPerson.getClass();\n    //类名.class\n    final Class<ClassPerson> classPersonClass = ClassPerson.class;\n    try {\n        //Class.forName  第二个参数boolean值表示是否触发初始化\n        final Class<?> aClass1 = Class.forName(\"com.roily.booknode.javatogod._04reflect.ClassPerson\");\n        final Class<?> aClass2 = Class.forName(\"com.roily.booknode.javatogod._04reflect.ClassPerson\", true, ClassLoader.getSystemClassLoader());\n   \t\t   System.out.println(VM.current().addressOf(aClass1));\n            System.out.println(VM.current().addressOf(aClass2));\n        } catch (Exception e) {\n        }\n        System.out.println(VM.current().addressOf(aClass));\n        System.out.println(VM.current().addressOf(classPersonClass));\n}\n```\n\n![image-20220825100540111](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208252320148.png)\n\n\n\n#### 反射能干什么\n\n- 使用反射创建实例对象\n- 使用反射获取一个实例对象，所属类的所有信息(类信息[父类、接口、注解]、属性、方法[包括私有方法、构造方法])\n\n\n\n##### 使用反射创建实例\n\n> 除了new关键字可创建实例对象，反射机制也可创建实例。\n>\n> 主要有两种方式：\n>\n> ①class.newInstance()\n>\n> ②获取构造方法，执行构造方法\n\n###### isInstance\n\nisInstance()方法是instanceOf 关键字的平替，如果返回true则可正常转化类型\n\n```java\n/**\n * Class 类Api isInstance\n * isInstance方法，是instanceOf的平替\n */\n@Test\npublic void testIsInstance() {\n    System.out.println(\"如果Object参数为该类实例，返回true\" + ClassPerson.class.isInstance(new ClassPerson()));\n    System.out.println(\"如果Object参数为该类或其任意子类的实例，返回true\" + ClassPerson.class.isInstance(new ClassSon()));\n    System.out.println(\"如果Object参数为该接口实现类，返回true\" + InterfaceTest.class.isInstance(new InterfaceTestImpl()));\n    //如果是数组类型，可强制转化不报CastException异常\n    final Object[] objects = new Object[1024];\n    System.out.println(objects.getClass().isInstance(new Integer[11]));\n}\n```\n\n###### newInstance\n\nnewInstance()方法创建实例：\n\n```java\npublic class ClassPerson {\n    public ClassPerson() {\n         System.out.println(\"公开构造器\");\n    }\n}\npublic class ClassPersonPrivate {\n    private ClassPersonPrivate() {\n        System.out.println(\"私有构造器\");\n    }\n}\n```\n\n> 如果此类的构造器是public的，则可使用class.newInstance()方法创建实例，且会触发类的初始化。\n>\n>  如果此类的构造器是private的，则不可使用class.newInstance()方法创建实例，会报java.lang.IllegalAccessException异常。\n\n```java\n/**\n * 如果此类的构造器是public的，则可使用class.newInstance()方法创建实例\n * 切会触发类的初始化\n */\n@Test\npublic void testNewInstance1() throws InstantiationException, IllegalAccessException {\n    final ClassPerson classPerson = ClassPerson.class.newInstance();\n    System.out.println(classPerson);\n}\n/**\n * 如果此类的构造器是private的，则不可使用class.newInstance()方法创建实例\n * 会报java.lang.IllegalAccessException异常\n */\n@Test\npublic void testNewInstance2() throws InstantiationException, IllegalAccessException {\n    final ClassPersonPrivate classPersonPrivate = ClassPersonPrivate.class.newInstance();\n    System.out.println(classPersonPrivate);\n}\n```\n\n\n\n###### getConstractor\n\n> 获取任意Class对象的非私有构造器，可以指定构造参数\n\n```java\n/**\n * Class的getConstructor方法可以获取，任意类的非私有构造器\n * 可以指构造参数\n */\n@Test\npublic void testGetConstructor() throws Exception {\n    final Class<ClassPerson> classPersonClass = ClassPerson.class;\n    //无参构造\n    final Constructor<ClassPerson> constructorWithOutParams = classPersonClass.getConstructor(null);\n    final ClassPerson classPerson1 = constructorWithOutParams.newInstance(null);\n    System.out.println(classPerson1);\n    //有参构造\n    final Constructor<ClassPerson> constructorWithParams = classPersonClass.getConstructor(String.class);\n    final ClassPerson classPerson2 = constructorWithParams.newInstance(\"小可爱\");\n    System.out.println(classPerson2);\n}\n```\n\n![image-20220825110704311](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208252320961.png)\n\n> 当然对于private私有构造器，不可以获取。\n>\n> 会报出`java.lang.NoSuchMethodException`异常\n\n```java\n@Test\npublic void testGetConstructor2() throws Exception {\n    final Constructor<ClassPersonPrivate> constructor = ClassPersonPrivate.class.getConstructor(null);\n    constructor.newInstance(null);\n}\n```\n\n###### getDeclaredConstructor\n\n> 获取任意类的构造器，如果是private的需要设置为可访问的\n\n```java\n/**\n * Class的getDeclaredConstructor方法可以获取，任意类的构造器\n * 可以指构造参数,如果是私有需要设置可访问,否则会爆出IllegalAccessException异常\n */\n@Test\npublic void testGetDeclaredConstructor1() throws Exception {\n    final Constructor<ClassPerson> declaredConstructor1 = ClassPerson.class.getDeclaredConstructor(null);\n    declaredConstructor1.newInstance(null);\n    final Constructor<ClassPersonPrivate> declaredConstructor2 = ClassPersonPrivate.class.getDeclaredConstructor(null);\n    //设置可访问\n    declaredConstructor2.setAccessible(true);\n    declaredConstructor2.newInstance(null);\n}\n```\n\n\n\n##### 属性、方法\n\n> 使用反射操作属性、方法\n\n###### 属性\n\n> 获取属性Field\n\n```java\n//修改name属性为pubilc\npublic String name;\n```\n\n> 使用`getField()`方法只能获取`public`属性。\n>\n> 使用`getDeclaredField()`获取所有属性，设置`setAccessible(true)`可对非pulic属性进行访问\n\n```java\n@Test\npublic void testField1() throws Exception {\n    //getField获取public 属性\n    final Field name = ClassPerson.class.getField(\"name\");\n    System.out.println(\"field name :  => \" + name.getName());\n    System.out.println(\"field type :  => \" + name.getType());\n}\n@Test\npublic void testField2() throws Exception {\n    final Field[] fields =  ClassPerson.class.getDeclaredFields();\n    Arrays.asList(fields).forEach(field -> field.setAccessible(true));\n    for (Field field : fields) {\n        System.out.println(\"field name :  => \" + field.getName());\n        System.out.println(\"field type :  => \" + field.getType());\n    }\n}\n```\n\n> 可通过反射动态修改对象属性\n\n```java\n@Test\npublic void testField3() throws Exception {\n    final ClassPerson classPerson = new ClassPerson();\n    System.out.println(\"ClassPerson =>\" + classPerson);\n    //得到所有\n    final Field[] fields = classPerson.getClass().getDeclaredFields();\n    Arrays.asList(fields).forEach(field -> {\n        field.setAccessible(true);\n        Object obj;\n        switch (field.getName()) {\n            case \"name\":\n                obj = \"name\";\n                break;\n            case \"age\":\n                obj = 20;\n                break;\n            case \"num\":\n                obj = 10;\n                break;\n            case \"values\":\n                obj = new String[]{\"values\"};\n                break;\n            default:\n                obj = null;   break;\n        }\n        try {\n            field.set(classPerson,obj);\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n    });\n    System.out.println(classPerson);\n}\n```\n\n![image-20220825184025386](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208252320662.png)\n\n###### 方法\n\n> 通过反射调用方法\n\n```java\n@Test\npublic void testMethod1() throws Exception {\n    final ClassPerson classPerson = new ClassPerson();\n    System.out.println(\"ClassPerson =>\" + classPerson);\n    //获取public方法\n    final Method methodWithoutParam = classPerson.getClass().getMethod(\"publicMethod\");\n    System.out.println(\"方法名:=>\" + methodWithoutParam.getName());\n    methodWithoutParam.invoke(classPerson);\n    //获取public方法\n    final Method methodWithParam = classPerson.getClass().getMethod(\"publicWithParamMethod\", String.class, int.class);\n    System.out.println(\"方法名:=>\" + methodWithParam.getName());\n    methodWithParam.invoke(classPerson, \"str\", 100);\n}\n```\n\n![image-20220825185606816](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208252320034.png)\n\n\n\n##### 使用反射获取其他信息\n\n> 使用反射获取其他信息\n\n```java\n/**\n * 使用反射获取其他信息\n */\n@Test\npublic void testGetOtherInfo() throws FileNotFoundException {\n    final String string = new String();\n    final Class<TestClass> testClassClass = TestClass.class;\n    System.out.println(\"类名  => \" + testClassClass.getSimpleName());\n    System.out.println(\"类全限定名  => \" + testClassClass.getName());\n    System.out.println(\"包名  => \" + testClassClass.getPackage());\n    //获取类加载器，我们写的类，一般都是应用类加载器，也叫app加载器\n    System.out.println(\"类加载器  =>\");\n    //其他加载器，扩展类加载器ext,引导类加载器我们得不到会返回null\n    System.out.println(\"扩展类加载器 =>\" + testClassClass.getClassLoader().getParent());\n    System.out.println(\"扩展类加载器 =>\" + testClassClass.getClassLoader().getParent().getParent());\n    //注意如果注解的保留策略需设置为@Retention(RetentionPolicy.RUNTIME)\n    System.out.println(\"runtime注解，运行期由VM保留  => \" + testClassClass.getAnnotation(AnnotationTest.class));\n    for (Class<?> anInterface : testClassClass.getInterfaces()) {\n        System.out.println(\"获取接口  => \" + anInterface);\n    }\n    System.out.println(\"获取父类  => \" + testClassClass.getSuperclass());\n    System.out.println(\"获取类路径下，也就是classes根目录下的某个资源文件输入流   => \" + testClassClass.getResourceAsStream(\"/test.properties\"));\n\n}\n```\n\n![image-20220825234832246](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208252348911.png)\n\n#### 工厂模式 + 反射实现ioc\n\n> `Spring IOC`的实现就是基于反射 + 工厂模式实现的。\n\n\n\n##### 不使用反射\n\n> 不使用反射利用工厂模式创建bean，这里就以简单工厂模式实现\n\n```java\npublic interface Fruit {\n    /**\n     * 描述\n     */\n    void describe();\n}\npublic class Apple implements Fruit{\n    String name;\n    @Override\n    public void describe() {\n        System.out.println(this.name);\n    }\n}\npublic class Banana implements Fruit{\n    String name;\n    @Override\n    public void describe() {\n        System.out.println(this.name);\n    }\n}\npublic class Orange implements Fruit{\n    String name;\n    @Override\n    public void describe() {\n        System.out.println(this.name);\n    }\n}\n```\n\n```java\npublic class MyCustomizeFactory {\n\t\t//bean工厂\n    final static HashMap<String, Object> mapFactory = new HashMap<>();\n    public static Fruit getInstance(String beanName) {\n        Fruit fruit = (Fruit) mapFactory.get(beanName);\n        if (!ObjectUtils.isEmpty(fruit)) {\n            return fruit;\n        }\n        switch (beanName) {\n            case \"Apple\":\n                fruit = new Apple(beanName);\n                break;\n            case \"Orange\":\n                fruit = new Orange(beanName);\n                break;\n            case \"Banana\":\n                fruit = new Banana(beanName);\n                break;\n            default:\n                System.out.println(\"error\");\n                break;\n        }\n        mapFactory.put(beanName, fruit);\n        return fruit;\n    }\n}\n```\n\n> 测试\n\n```java\npublic static void main(String[] args) {\n    final Fruit apple = MyCustomizeFactory.getInstance(\"Apple\");\n    System.out.println(apple);\n    final Fruit banana = MyCustomizeFactory.getInstance(\"Banana\");\n    System.out.println(banana);\n}\n```\n\n> 如此实现存在一个问题：如果添加实现类的话需要修改工厂代码，不符合开闭原则\n\n![image-20220826002732640](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208260027034.png)\n\n##### 使用反射\n\n> 我们只需要知道此类的全限定名即可通过反射创建此对象\n\n```java\npublic static Fruit getInstanceWithReflect(String name, String className) {\n        Fruit fruit = (Fruit) mapFactory.get(className);\n        if (!ObjectUtils.isEmpty(fruit)) {\n            return fruit;\n        }\n        try {\n            fruit = (Fruit) Class.forName(className).newInstance();\n        } catch (Exception e) {\n            System.out.println(\"error\");\n        }\n        mapFactory.put(name, fruit);\n        return fruit;\n    }\n```\n\n> 测试\n\n```java\n final Fruit apple = MyCustomizeFactory.getInstanceWithReflect(\"apple\",\"com.roily.booknode.javatogod._04reflect.factoryioc.Apple\");\n        System.out.println(apple.getClass());\n        final Fruit banana = MyCustomizeFactory.getInstanceWithReflect(\"banana\",\"com.roily.booknode.javatogod._04reflect.factoryioc.Banana\");\n        System.out.println(banana.getClass());\n        final Fruit orange = MyCustomizeFactory.getInstanceWithReflect(\"orange\",\"com.roily.booknode.javatogod._04reflect.factoryioc.Orange\");\n        System.out.println(orange.getClass());\n```\n\n> 结合配置文件，一次性创建工厂，之后只需去工厂取bean即可\n\n创建bean配置文件\n\n![image-20220826005204288](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208260052813.png)\n\n工厂类添加方法\n\n```java\npublic static Fruit getInstanceWithReflect(String name) {\n    return (Fruit) mapFactory.get(name);\n}\n```\n\n测试：\n\n程序运行触发初始化，对应bean只创建一次放入工厂，想要就去拿\n\n```java\nstatic {\n    final InputStream in = ClientTest.class.getResourceAsStream(\"/bean.properties\");\n    final Properties properties = new Properties();\n    try {\n        properties.load(in);\n        properties.keySet().forEach(ele -> MyCustomizeFactory.getInstanceWithReflect((String) ele, (String) properties.get(ele)));\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\npublic static void main(String[] args) {\n    final Fruit apple = MyCustomizeFactory.getInstanceWithReflect(\"Apple\");\n    System.out.println(apple.getClass());\n    final Fruit banana = MyCustomizeFactory.getInstanceWithReflect(\"Banana\");\n    System.out.println(banana.getClass());\n    final Fruit orange = MyCustomizeFactory.getInstanceWithReflect(\"Orange\");\n    System.out.println(orange.getClass());\n}\n```\n\n![image-20220826005421217](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208260054512.png)\n\n### 范型\n\n> Java范型时JDK5引入的特性，允许在定义类、接口和方法的时候可以使用类型参数。声明的类型参数会在使用的时候替换为具体的类型。\n>\n> 范型是java提供的语法糖，我们所定义的范型在编译期间都会被类型擦除，使用泛型可提高代码的复用性。Java的集合框架都使用了范型，我们平常所定义的List<String>、List<Iteger>这两个集合类型是相同的，在编译的时候会进行类型擦除，擦除后的类型变为原始类型List。\n\n#### 类型擦除(type erasue)\n\n##### 例子\n\n> 写几个例子，反编译查看\n\n例一：\n\n```java\nfinal List<String> list = new ArrayList<>(10);\nlist.add(\"可可爱爱\");\nSystem.out.println(list.get(0));\n```\n\n反编译后：\n\n```java\nList list = new ArrayList(10);\nlist.add(\"\\u53EF\\u53EF\\u7231\\u7231\");\nSystem.out.println((String)list.get(0));\n```\n\n> 编译过后List<String>的类型被擦除，也就是说只有List类型，而不存在List<String>这个类型。中间对于元素的具体操作，通过类型转化实现。\n\n例二：\n\n```java\n/**\n * 指定范型类型，那么CompareTo方法也必须指定类型，如果不指定那么就会替换为其左边界Object\n * 编译后Comparable<MyNumericValue>的类型被擦除，变为Comparable<Object>\n * 那么直接导致未能实现compareTo方法\n * 编译器检测到了，就给生成一个桥接方法compareTo(Object object)\n */\nclass MyNumericValue implements Comparable<MyNumericValue> {\n    private int value;\n    @Override\n    public int compareTo(MyNumericValue o) {\n        return this.value - o.value;\n    }\n}\nclass MyNumericValue2 implements Comparable {\n    private int value;\n    @Override\n    public int compareTo(Object o) {\n        return 0;\n    }\n}\n```\n\n反编译查看：\n\n```java\nclass MyNumericValue implements Comparable {\n    MyNumericValue() {\n    }\n    public int compareTo(MyNumericValue o) {\n        return value - o.value;\n    }\n    public volatile int compareTo(Object obj) {\n        return compareTo((MyNumericValue) obj);\n    }\n    private int value;\n}\n//\nclass MyNumericValue2 implements Comparable {\n    MyNumericValue2() {\n    }\n    public int compareTo(Object o) {\n        return 0;\n    }\n    private int value;\n}\n```\n\n> 对于一些范型接口的使用，如果接口的抽象方法的入参、出参是范型类型的话，如果在类型擦除时导致未能实现接口方法时，需要编译器生成桥接方法，通过此桥接方法调用原始方法。\n\n例三：\n\n```java\npublic <T extends List<E>, E extends Comparable<E>> void max(List<E> list) {\n    E max = list.get(0);\n    for (E e : list) {\n        if (e.compareTo(max) > 0) {\n            max = e;\n        }\n    }\n    System.out.println(\"最大值=>\" + max);\n}\n```\n\n反编译查看：\n\n```java\npublic void max(List list) {\n    Comparable max = (Comparable) list.get(0);\n    Iterator iterator = list.iterator();\n    do {\n        if (!iterator.hasNext())\n            break;\n        Comparable e = (Comparable) iterator.next();\n        if (e.compareTo(max) > 0)\n            max = e;\n    } while (true);\n    System.out.println((new StringBuilder()).append(\"\\u6700\\u5927\\u503C=>\").append(max).toString());\n}\n```\n\n>  E extends Comparable<E>限定了范型边界，那么首先将所有的范型E替换为最左边界 Comparable<E>，然后进行类型擦除得到最终擦除后的结果 Comparable。\n>\n> 增强for循环底层使用的是迭代器进行遍历。\n\n##### 小结\n\n> 类型擦除指的是通过类型参数合并，将范型类型实例关联到一份字节码文件上，编译器只为范型类生成一份字节码文件。\n>\n> 类型擦除的过程中jvm会将范型java代码转化为普通java代码，编译器直接操作的是字节码。\n\n#### 范型带来的问题\n\n> java的违范型机制，类似于语法糖，它方便了我们编写代码，并提高了代码的可复用性，那么复杂的工作就是由jvm待做。\n\n###### 重载\n\n> 重载的条件是方法名相同、参数列表不同。那么如果对于相同的方法名，使用List<String>、List<Integer>，可以进行重载么？\n>\n> 显然是不行的，因为之前我们就说过jvm中只有List这一种类型，并不存在List<String>、List<Integer>,因为编译会进行类型擦除，\n\nidea直接提示，两个方法拥有相同的范型，编译不可通过。\n\n`'method1(List<String>)' clashes with 'method1(List<Integer>)'; both methods have same erasure`\n\n```java\npublic void method1(List<String> list){\n}\npublic void method1(List<Integer> list){\n}\n```\n\n#### 范型通配符\n\n##### 常用泛型符号\n\n> 范型符号都有对应含义，常用范型符号如下：\n\n- E     element    (在集合框架中表示元素的意思)\n\n- T     Type    java类\n- K     key   (键值)\n- V     value   （value值）\n- N   number    数值类型\n- ？   未知java类型（无限制通配符类型）\n\n> 对于普通泛型符号(除？以外)，必须预先声明类型才可以使用，也就是在我们使用的时候必须确定类型，否则编译报错。\n\n<img src=\"https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208281522005.png\" alt=\"image-20220828152230268\" style=\"zoom:50%;\" />\n\n> 而对于?通配符来说无需事先声明，表示任意类型。正是因为无需声明类型，那么对于编译器来说它不知道如何对类型进行强转，就造成了此方式的泛型无法添加元素，且获取得到的元素也只能是Object类型。\n>\n> 如下List<?> list 表示此方法可以接受任意类型的集合对象\n\n```java\nclass  TestClass2 {\n    public void test(List<?> list){\n        //list.add(\"\");\n        final Object o = list.get(0);\n        System.out.println(o);\n    }\n    public static void main(String[] args) {\n        final TestClass2 testClass2 = new TestClass2();\n        testClass2.test(new ArrayList<Integer>(Arrays.asList(1,2)));\n        testClass2.test(new ArrayList<String>(Arrays.asList(\"1\",\"2\")));\n        testClass2.test(new ArrayList<Comparable>(Arrays.asList(1,2)));\n    }\n}\n```\n\n##### 限定通配符\n\n> 对于非限定通配符来说，也有不好的地方，它不限制类型，那么在方法逻辑中想使用指定类型的方法时需要强制转化，如此可能出现`ClassCastException`异常。\n\n```java\nclass TestClassC<T> {\n    T t;\n    public void test(T t1,T t2){\n        final Comparable t1c = (Comparable) t1;\n        System.out.println(t1c.compareTo(t2));\n    }\n}\n```\n\n\n\n> 如上我们可以限定test的参数类型为Comparable的实现类。所以java为我们引入了限定通配符\n\n限定通配符对类型进行限制，java中有两种限定通配符：\n\n- 表示上界，<? extends T>\n\n  > 泛型类型必须为T或T的派生类（可以是接口、也可以是子类）这里没有用任何意义上的继承关系。\n  >\n  > <? extends T>表示可接收任意T即T的派生类类型。\n  >\n  > 用于取值。\n\n![image-20220828164524819](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208281645961.png)\n\n- 表示下界,<？  super T>,   即类型必须为T或T的父类型\n\n  > 泛型类型必须为T或T的父类。\n  >\n  > <? super T>表示可接收任意T即T的父类类型。\n  >\n  > 用于存值。\n\n![image-20220828165307611](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208281653029.png)\n\n> 指定类型就不行了，因为String不是Fruit的父类类型\n\n![image-20220828165336604](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208281653641.png)\n\n> 关于存取值问题\n\n![image-20220828170849157](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208282256806.png)\n\n小结：\n\n> 如果对于泛型没有限制，并且集合类型支持存取的话，直接使用非限定通配符T E等。\n>\n> 如果对于泛型有限制，则使用限定通配符 extents支持取，super支持存。\n>\n> ？对于取是不友好的，因为？表示任意java类型，那么取出来的一定是Object，而Object没有意义，强转存在ClassCastExpression异常风险。\n\n### 设计模式\n\n> 简单了解\n\n#### 代理模式\n\n> 框架的灵魂就是代理＋反射，代理和反射几乎是所有框架的基础。了解一下代理模式。\n\n##### 静态代理\n\n> 要求代理角色和真实角色实现同一接口、代理角色将真实角色组合进来、代理角色对真实角色方法进行增强。\n\n###### 简单实现\n\n- 定义抽象接口\n\n  ```java\n  public interface SellGoods {\n      void doSell();\n  }\n  ```\n\n- 定义真实角色\n\n  ```java\n  public class GoodsOwner implements SellGoods {\n      @Override\n      public void doSell() {\n          System.out.println(\"小杨哥的品牌方\");\n      }\n  }\n  ```\n\n- 代理角色\n\n  ```java\n  @Data\n  public class XiaoYangGe implements SellGoods {\n      //小杨哥代理的品牌方\n      private SellGoods sellGoods;\n      @Override\n      public void doSell() {\n          prev();\n          sellGoods.doSell();\n          last();\n      }\n      private void prev(){\n          System.out.println(\"测评、口碑、流量\");\n      }\n      private void last(){\n          System.out.println(\"质保\");\n      }\n      @Test\n      public void test(){\n          //代理对象\n          final XiaoYangGe xiaoYangGe = new XiaoYangGe();\n          //代理对象组合真实对象\n          xiaoYangGe.setSellGoods(new GoodsOwner());\n          //代理对象对真实对象做增强\n          xiaoYangGe.doSell();\n      }\n  }\n  ```\n\n![image-20220829140457256](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208300005131.png)\n\n###### 优缺点\n\n优点：\n\n- 简单、直观\n\n缺点：\n\n- 只能代理一类角色，不通用，不利于扩展\n\n\n\n##### 动态代理\n\n> 动态代理的目的就是为了解决静态代理的却点。达到通用且易于扩展。\n\n分为\n\n- jdk动态代理\n\n- CGLIB动态代理\n\nJdk动态代理，借助Proxy类和InvocationHandler接口，实现动态生成代理对象的能力。\n\nCglib动态代理，运行时在内存中生成一个子类对象，实现对目标对象的代理。\n\n注意点：\n\njdk动态代理有一个限制，那就是被代理类必须实现一个或多个接口。\n\n如果被代理类没有实现接口的化可以使用Cglib动态代理。\n\n###### jdk动态代理\n\n> jdk动态代理需要借助一个类Proxy和一个接口InvocationHandler。\n>\n> Proxy用于生成代理对象，InvocationHandler称为代理对象的调用处理程序。\n\n以下实现将 SellGoods 替换为 Object，则可以代理所有实现接口的类的实例。\n\n实现：\n\n```java\n@Data\npublic class SellGoodsInvocationHandler implements InvocationHandler {\n    //代理谁？\n    private SellGoods sellGoods;\n    /**\n     * 生成代理对象\n     */\n    public Object newProxyInstance() {\n        return Proxy.newProxyInstance(sellGoods.getClass().getClassLoader(), sellGoods.getClass().getInterfaces(), this);\n    }\n    /**\n     * 代理对象对真实对象增强\n     *\n     * @param proxy  代理对象\n     * @param method 被代理对象method实例，内部包含被代理对象方法信息\n     * @param args   method参数\n     * @return\n     * @throws Throwable\n     */\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        //代理对象实现接口\n        System.out.println(\"代理对象实现接口:\");\n        for (Class<?> anInterface : proxy.getClass().getInterfaces()) {\n            System.out.println(anInterface.getName());\n        }\n        prev();\n        //invoke 第一个参数：被代理对象实例，第二个参数，被代理对象方法参数\n        Object returnVal = method.invoke(sellGoods,args);\n        last();\n        return returnVal;\n    }\n    private void prev() {\n        System.out.println(sellGoods.getClass().getName() + \"类被代理，前置方法\");\n    }\n    private void last() {\n        System.out.println(sellGoods.getClass().getName() + \"类被代理，后置方法\");\n    }\n    @Test\n    public void test(){\n        final SellGoodsInvocationHandler sellGoodsInvocationHandler = new SellGoodsInvocationHandler();\n        sellGoodsInvocationHandler.setSellGoods(new GoodsOwner());\n        final SellGoods sellGoodsProxy = (SellGoods)sellGoodsInvocationHandler.newProxyInstance();\n        sellGoodsProxy.doSell();\n    }\n}\n```\n\n![image-20220829171302109](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208300005024.png)\n\n###### CGLIB\n\n> 当JDK动态代理用不了了，可以用CGLIB动态代理。\n>\n> CGLIB(Code Generation Library) 是一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。\n>\n> CGLIB动态代理是通过继承来实现对目标对象的增强的，所以某个被final修饰的方法，是无法被代理的。\n\n实现：\n\n> 一个类，被代理类，一个被final修饰的方法，一个普通方法\n\n```java\npublic class Obj {\n    /**\n     * 定义两个方法\n     * 一个是普通方法，一个是被final修饰的方法\n     */\n    final public void doSomeThing() {\n        System.out.println(\"被final修饰的方法\");\n    }\n\n    public void doOtherThing() {\n        System.out.println(\"普通方法\");\n    }\n}\n```\n\n> 拦截器\n\n```java\npublic class MyMethodInterceptor implements MethodInterceptor {\n    /**\n     * 拦截方法\n     *\n     * @param o           the enhanced obj  已被增强对象\n     * @param method      intercepted Method 被拦截方法\n     * @param objects     参数列表，基本类型会替换为包装类型\n     * @param methodProxy 代理方法\n     */\n    @Override\n    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n        System.out.println(\"被代理方法名称:\" + method.getName());\n        System.out.println(\"=====开始增强=====\");\n        final Object o1 = methodProxy.invokeSuper(o, objects);\n        System.out.println(\"=====增强结束=====\");\n        return o1;\n    }\n}\n```\n\n> 生成代理对象\n\n```java\n@Data\npublic class CgLibProxy {\n    private Class<? extends Object> object;\n    public Object getProxy() {\n        //创建Enhancer对象，类似于JDK动态代理的Proxy类\n        Enhancer enhancer = new Enhancer();\n        //设置目标类的字节码文件,很明显使用反射实现\n        enhancer.setSuperclass(object);\n        //设置借助哪个拦截器实现（也就是做哪些增强）\n        enhancer.setCallback(new MyMethodInterceptor());\n        //这里的creat方法就是正式创建代理类\n        return enhancer.create();\n    }\n}\n```\n\n> 测试：\n\n- 可实现增强\n- 不可增强被final修饰的方法\n\n```java\npublic static void main(String[] args) {\n    //在指定目录下生成动态代理类，我们可以反编译看一下里面到底是一些什么东西\n    System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, \"D:\\\\java\\\\java_workapace2\");\n    CgLibProxy cgLibProxy = new CgLibProxy();\n    cgLibProxy.setObject(Obj.class);\n    //这里的creat方法就是正式创建代理类\n    Obj proxy = (Obj)cgLibProxy.getProxy();\n    //调用代理类的final方法\n    proxy.doSomeThing();\n    //调用代理类的非final方法\n    proxy.doOtherThing();\n}\n```\n\n\n\n### 序列化\n\n> 序列化是指将对象的状态信息转化为可存储或可传输的形式的过程。用于网络传输和RPC调用过程中的信息媒介。反序列化是序列化的逆过程。\n\n#### java的序列化\n\n> java中对象信息都存储与jvm运行时堆内存中，一旦jvm停止运行，java对象信息也将丢失。序列化是一种持久化手段，可以将对象信息以文件的信息存储于磁盘中，当我们想再次使用的时候可以将序列化的信息读出来，反序列化还原对象信息。\n\n- java想要实现序列化必须实现Serializable接口\n- java序列化存储的是对象信息，只存储成员变量信息，类变量信息不会被存储\n- 借助ObjectOutputStream和ObjectInputStream对对象进行序列化和反序列化\n- 序列化与反序列化要求SerialVersionUID序列化与反序列化前后必须相同\n- Transient表示瞬时的意思，即被它修饰的属性不会参与序列化过程\n- 可以在类中添加writeObject和readObject方法来定制对象的序列化和反序列化\n- 可序列化类的子类都可序列化\n\n##### Serializable接口\n\n> Java中想要实现序列化必须实现Serializable接口。如果没有实现序列化接口却尝试使用序列化的话会报出`NotSerializableException`异常。\n>\n> `Serializable`接口没有任何方法，类似于一个标识接口，但是想要实现序列化必须实现此接口。当我们没有定制序列化时默认使用`ObjectOutputStream的defaultWriteObject()`和`InputOutputStream的defaultReadObject()`方法进行序列化。\n>\n> 序列化时想要序列化父类属性，那么父类也必须实现序列化接口\n\n例子：序列化时想要序列化父类属性，那么父类也必须实现序列化接口\n\n```java\n@Data\npublic class ClassParent implements Serializable {\n  private static final long serialVersionUID = 1L;\n    public String value1;\n}\n@Data\n@ToString(callSuper = true)\nclass ClassSon extends ClassParent {\n  private static final long serialVersionUID = 1L;\n    public String value2;\n}\n\n```\n\n```java\n/**\n * 想要序列化父类属性，父类也需要实现序列化接口\n */\n@Test\npublic void test2() {\n    String filePath = \"/Users/rolyfish/Desktop/MyFoot/foot/testfile\";\n    final ClassSon classSon = new ClassSon();\n    classSon.setValue1(\"Parent\");\n    classSon.setValue2(\"Son\");\n    try (final ObjectOutputStream objectOutputStream =\n                 new ObjectOutputStream(new FileOutputStream(new File(filePath, classSon.getClass().getSimpleName() + \".txt\")))) {\n        objectOutputStream.writeObject(classSon);\n        objectOutputStream.flush();\n    } catch (IOException e) {\n    }\n\n    try (final ObjectInputStream objectInputStream =\n                 new ObjectInputStream(new FileInputStream(new File(filePath, classSon.getClass().getSimpleName() + \".txt\")))) {\n        final Object o = objectInputStream.readObject();\n        System.out.println(o);\n    } catch (IOException e) {\n    } catch (ClassNotFoundException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n![image-20220830010017176](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208300100164.png)\n\n##### Externalizable\n\n> `Externalizable`接口继承自`Serializable`接口，与`Serializable`接口不同的是`Externalizable`接口定义了两个方法，在使用`Externalizable`接口进行序列化操作的时候必须实现这两个方法，否则序列化操作后所有属性都会变成默认值。\n\n注意：\n\n使用`Externalizable`接口进行序列化的时候，会调用类的无参构造器，再将对象的属性填充到此对象中，所以说使用`Externalizable`接口进行序列化需要一个public的无参构造器。\n\n例子：\n\n```java\n@Data\npublic class ClassExternalizable implements Externalizable {\n    private static final long serialVersionUID = -7287239868922811345L;\n    String value;\n    @Override\n    public void writeExternal(ObjectOutput out) throws IOException {\n        out.writeObject(value);\n    }\n    @Override\n    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        this.value = (String) in.readObject();\n    }\n    @Test\n    public void test2() {\n        String filePath = \"/Users/rolyfish/Desktop/MyFoot/foot/testfile\";\n        final ClassExternalizable classExternalizable = new ClassExternalizable();\n        classExternalizable.setValue(\"ClassExternalizable\");\n        try (final ObjectOutputStream objectOutputStream =\n                     new ObjectOutputStream(new FileOutputStream(new File(filePath, ClassExternalizable.class.getSimpleName() + \".txt\")))) {\n            objectOutputStream.writeObject(classExternalizable);\n            objectOutputStream.flush();\n        } catch (IOException e) {\n        }\n        try (final ObjectInputStream objectInputStream =\n                     new ObjectInputStream(new FileInputStream(new File(filePath, ClassExternalizable.class.getSimpleName() + \".txt\")))) {\n            final Object o = objectInputStream.readObject();\n            System.out.println(o);\n        } catch (IOException e) {\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n![image-20220830013944110](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208300139614.png)\n\n##### SeriaVersionUID\n\n> 序列号，在序列化的时候会将类的序列号存储，在反序列化的时候会检查序列号是否一致，如果一致才会进行接下来的序列化操作。如果不一致则会抛出`InvalidCastException`异常。\n\n例子：\n\n> 先执行testWrite ，然后修改SerialVersionUID，再执行testRead\n\n```java\n@Data\npublic class ClassSerialVersionUID implements Serializable {\n    private static final long serialVersionUID = 2221061315871513751L;\n\n    String value;\n    @Test\n    public void testWrite() {\n        String filePath = \"/Users/rolyfish/Desktop/MyFoot/foot/testfile\";\n        final ClassSerialVersionUID classSerialVersionUID = new ClassSerialVersionUID();\n        classSerialVersionUID.setValue(\"classSerialVersionUID\");\n        try (final ObjectOutputStream objectOutputStream =\n                     new ObjectOutputStream(new FileOutputStream(new File(filePath, ClassSerialVersionUID.class.getSimpleName() + \".txt\")))) {\n            objectOutputStream.writeObject(classSerialVersionUID);\n            objectOutputStream.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n```java\n@Data\npublic class ClassSerialVersionUID implements Serializable {\n    private static final long serialVersionUID = 123123151L;\n    String value;\n    @Test\n    public void testRead() {\n        String filePath = \"/Users/rolyfish/Desktop/MyFoot/foot/testfile\";\n        try (final ObjectInputStream objectInputStream =\n                     new ObjectInputStream(new FileInputStream(new File(filePath, ClassSerialVersionUID.class.getSimpleName() + \".txt\")))) {\n            final ClassSerialVersionUID classSerialVersionUID = (ClassSerialVersionUID) objectInputStream.readObject();\n            System.out.println(classSerialVersionUID);\n        } catch (IOException | ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n> 会报出InvalidCastException异常，且友好提示二进制流中的序列号id和本地类中的序列号id不一致。\n\n![image-20220830015417052](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208300154672.png)\n\n\n\n###### SerialVersionUID哪来的\n\n> 如果在编写java类时没有显示定义一个`SerialVersionUID`，那么编译器会为根据Class类的属性特征生成一个序列号，如果此类不发生改变那么经过多次编译也不会报错，如果此类发生改变（添加字段、修改字段），那么在反序列化时会报错。所以说一般我们会自定义一个序列号\n\n借助idea生成序列号：\n\n在设置的检查项可以设置缺省序列号时的告警级别，\n\n![image-20220830020226044](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208300202768.png)\n\n编写class类不添加序列号会有警告提示：\n\n快捷键 opt + enter\n\n![image-20220830020400580](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208300204003.png)\n\n\n\n##### 定制序列化策略\n\n> java在序列化的时候会首相检查，当前类是否存在`writeObject`和`readObject`方法，如果有则优先使用自定义的序列化策略，否则才会使用默认的`defaultWriteObject  和 defaultReadObject`方法。\n>\n> 所以定制序列化策略也就是自己添加`writeObject 和 readObject`方法。\n\n###### ArrayList\n\n> 首先可以查看一下ArrayList的序列化策略。\n>\n> ArrayList底层是一个对象数组，且该属性被transient修饰，也就是不参与序列化，那么他是如何保存对象信息的呢？就是自定义序列化策略，ArrayList添加了`writeObject 和 readObject`方法。且ArrayList优化了序列化策略，它只会保存非null元素，而null元素则会被忽略。\n\n###### 自定义序列化策略\n\n> 上面我们聊Externalizable时就已经涉及了。\n\n```java\n@Data\npublic class ClassCustomizeSerializable implements Serializable {\n    private static final long serialVersionUID = 2936590571416558935L;\n    transient Date date;\n    String value;\n    private void writeObject(ObjectOutputStream out)\n            throws java.io.IOException {\n        out.writeObject(Optional.ofNullable(date).orElse(Calendar.getInstance().getTime()));\n        out.writeObject(value);\n    }\n    private void readObject(ObjectInputStream in)\n            throws java.io.IOException, ClassNotFoundException {\n        final Object o1 = in.readObject();\n        final Object o2 = in.readObject();\n        date = (Date) ((o1 instanceof Date) ? o1 : o2);\n        value = (String) ((o1 instanceof String) ? o1 : o2);\n    }\n    @Test\n    public void test() {\n        final ClassCustomizeSerializable classCustomizeSerializable = new ClassCustomizeSerializable();\n        classCustomizeSerializable.setValue(\"classCustomizeSerializable\");\n        String filePath = \"/Users/rolyfish/Desktop/MyFoot/foot/testfile\";\n        try (final ObjectOutputStream objectOutputStream =\n                     new ObjectOutputStream(new FileOutputStream(new File(filePath, ClassCustomizeSerializable.class.getSimpleName() + \".txt\")))) {\n            objectOutputStream.writeObject(classCustomizeSerializable);\n            objectOutputStream.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        try (final ObjectInputStream objectInputStream =\n                     new ObjectInputStream(new FileInputStream(new File(filePath, ClassCustomizeSerializable.class.getSimpleName() + \".txt\")))) {\n            ClassCustomizeSerializable o = (ClassCustomizeSerializable) objectInputStream.readObject();\n            System.out.println(o);\n        } catch (IOException | ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n![image-20220830022442495](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208300224278.png)\n\n### 注解\n\n> Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。\n\n从以下几点了解：\n\n- 注解语法\n- 元注解\n- java内置注解\n- 注解的继承性\n- 简单使用\n\n#### 注解语法\n\n> 注解的定义很简单，使用`@interface`声明，表示一个注解。\n\n```java\npublic @interface MyDefinitionAnnotation {\n}\n```\n\n> 反编译查看，可得结论\n>\n> - 所定义的注解就是一个接口\n> - 此接口继承自`Annotation`接口\n>\n> 所以定义注解时无需关系底层实现，编译器和虚拟机会帮我们完成底层的实现。\n\njad反编译：\n\n```java\npublic interface MyDefinitionAnnotation extends Annotation{\n}\n```\n\n\n\n#### 元注解\n\n> 元注解起到对其他注解进行说明的作用，可以定义其他注解\n\n元注解有四个：\n\n- @Target\n- @Retention\n- @Documented\n- @Inherited\n\n##### @Documented&@Inherited \n\n> 这两个注解分别表示，是否在JavaDoc中保存注解和是否允许子类继承父类注解。\n>\n> 这两个注解没有内部属性，都被\n>\n> ```java\n> @Retention(RetentionPolicy.RUNTIME)\n> @Target(ElementType.ANNOTATION_TYPE)\n> ```\n>\n> 注释，保留策略为Runtime，即会被VM加载进内存，可反射获取、类型属性为`ElementType.ANNOTATION_TYPE`即只可定义在注解上。\n\n##### @Target\n\n> @Target注解只可用于注解类型上、可保留进javadoc、保留策略为RUNTIME。\n>\n> 此注解有一个属性，为数组表示被@Target修饰的注解可用于什么地方，如果不使用@Targer注释则表示该注解可用于任何地方。\n\n```java\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.ANNOTATION_TYPE)\npublic @interface Target {\n    ElementType[] value();\n}\n```\n\n> ElementType枚举值说明：\n\n常用的：TYPE、FIELD、METHOD\n\n```java\npublic enum ElementType {\n    /** Class, interface (including annotation type), or enum declaration */\n    //标注此注解可用于 类、接口、注解、以及枚举上（注解就是接口、枚举就是类）\n    TYPE,\n    /** Field declaration (includes enum constants) */\n    //标注此注解可用于字段属性上\n    FIELD,\n    /** Method declaration */\n    //标注此注解可用于方法上\n    METHOD,\n    /** Formal parameter declaration */\n    //标注此注解可用于方法参数上，比如@Valid @RequestBody\n    PARAMETER,\n    /** Constructor declaration */\n    //标注此注解可用于构造方法上\n    CONSTRUCTOR,\n    /** Local variable declaration */\n     //标注此注解可用于本地变量\n    LOCAL_VARIABLE,\n    /** Annotation type declaration */\n     //标注此注解可用于注解上，元注解都有此属性\n    ANNOTATION_TYPE,\n    /** Package declaration */\n    //可用于package-info.java中\n    PACKAGE,\n    /**\n     * Type parameter declaration\n     *\n     * @since 1.8\n     */\n    TYPE_PARAMETER,\n    /**\n     * Use of a type\n     *\n     * @since 1.8\n     */\n    TYPE_USE\n}\n```\n\n##### @Retention\n\n> 保留策略，注解只是保留在代码中、还是编译进class文件中、还是在运行期间保留在虚拟机中（可以通过反射访问）\n>\n> 有一个RetentionPolicy value属性，RetentionPolicy 是一个枚举类型。\n\n```java\npublic enum RetentionPolicy {\n    //表示只保留在javaDoc中，会被编译器忽略，被编译器忽略自然也不会加载进虚拟机\n    SOURCE,\n    //表示会被编译器编译生成class文件，但不会由VM在运行时保留\n    CLASS,\n    //会编译、也会由VM在运行时保留，注解为此保留策略可通过反射获取注解信息\n    RUNTIME\n}\n```\n\n\n\n####  java内置注解\n\n> Java内部定义了一套注解，共有10个，6 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中，\n>\n> 除了三面提供的四个元注解(四个元注解都在 java.lang.annotation中)，还有6个在`java.lang`包下。\n\n##### Deprecated\n\n> 注释于构造器、属性、本地变量、方法、包、接口、方法上，表示过时的意思。\n>\n> 使用过时的类、方法、属性等，会有一个横线标识、不影响使用。\n\n```java\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})\npublic @interface Deprecated {\n}\n```\n\n\n\n##### @SuppressWarnings\n\n> @SuppressWarnings(\"all\")，抑制警告，`all`代表抑制所有警告，包括未检测警告、过时警告等。\n\n\n\n#####  @Override\n\n> 注解于方法上，表示重写方法。\n\n##### @SafeVarargs\n\n> 注释于构造方法或方法上，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告\n\n\n\n##### @FunctionalInterface\n\n> 注释于接口上，表示为一个函数式接口。\n\n##### @Repeatable\n\n> 注释于注解上，表示该注解可重复声明多次。\n\n![image-20220830204849836](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208312252848.png)\n\n使用:\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic   @interface Persons {\n   Person[] value();\n}\n```\n\n```java\n@Repeatable(Persons.class)\npublic  @interface Person{\n    String role() default \"\";\n}\n```\n\n```java\n@Person(role = \"男的\")\n@Person(role = \"打工族\")\npublic class MeClass {\n}\n```\n\n\n\n#### 注解的继承\n\n> 注解的继承是指什么意思？\n\n首先看一个例子：\n\n结论表明如果一个注解被@Inherited 注释的话，那么子类可以继承得到父类的注解\n\n```java\n@Target(value = ElementType.TYPE)\n@Retention(value = RetentionPolicy.RUNTIME)\n@Inherited // 声明注解具有继承性\n@interface AnnotationInherited {\n    String value() default \"\";\n}\n```\n\n```java\n@AnnotationInherited\npublic class SuperClass {\n}\npublic class SonClass extends SuperClass{\n}\n```\n\n```java\npublic static void main(String[] args) {\n    System.out.println(Arrays.asList(SonClass.class.getAnnotations()));\n}\n```\n\n![image-20220831224956656](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208312250324.png)\n\n\n\n#### 简单使用\n\n> 定义一个注解最重要的就是设置@Target和@Retention。分别表示该注解可以放在哪里和该注解的保留策略。\n\n- RetentionPolicy.RUNTIME   会编译、也会由VM在运行时保留，注解为此保留策略可通过反射获取注解信息\n- @Target如果不指定，表示该注解可放于任何地方。如果指定那么就只可以放在指定地方\n\n```java\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\npublic @interface MyDefinitionAnnotation {\n}\n```\n\n##### 通过反射获取注解信息\n\n> 如果不设置@Retention(RetentionPolicy.RUNTIME)的话是获取不到注解信息的\n\n```java\n@MyDefinitionAnnotation\npublic class MyTestClass {   \n}\npublic static void main(String[] args) {\n    final Annotation[] annotations = MyTestClass.class.getAnnotations();\n    for (Annotation annotation : annotations) {\n        System.out.println(annotation.annotationType().getSimpleName());\n    }\n}\n```\n\n![image-20220830230013493](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208312252822.png)\n\n##### 注解可定义属性并赋默认值\n\n> 注解可定义属性并可以给属性赋予默认值，可以通过属性来控制，类、方法、字段的行为。\n\n以下例子我们通过AnnotationWithValue注解实现了类似于@Value注解的作用\n\n```java\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface AnnotationWithValue {\n\n    String value() default \"默认值\";\n\n}\n```\n\n```java\n@Data\npublic class TestClass {\n\n    @AnnotationWithValue(value = \"注解赋值\")\n    public String value1;\n\n    @AnnotationWithValue\n    public String value2;\n\n    @Test\n    public void test() throws NoSuchFieldException, IllegalAccessException {\n\n        final TestClass testClass = new TestClass();\n        final Field value1 = TestClass.class.getField(\"value1\");\n        final String str1 = value1.getAnnotation(AnnotationWithValue.class).value();\n        value1.set(testClass,str1);\n        final Field value2 = TestClass.class.getField(\"value2\");\n        final String str2 = value2.getAnnotation(AnnotationWithValue.class).value();\n        value2.set(testClass,str2);\n        System.out.println(testClass);\n    }\n}\n```\n\n![image-20220831000337366](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208312252339.png)\n\n\n\n#### 注解+反射实现自动装配\n\n> Spring的自动装配原理就是  注解 + 反射，自动装配就是获取字段上的@Value、@AutoWrite注解并进行赋值操作。实现的步骤如下：\n\n- 想使用反射创建对象的化，即必须获取待装配的，类的全限定名。即如何扫描待装配的类\n- 自定义一套注解\n- 最后就是创建bean并装配属性\n\n#####  如何扫描类\n\n> 如何扫描待装配的类。这里的思路是，首先有一个启动类，获取启动类所在目录及其子目录下所有类全限定名称，放入一个List中。\n>\n> 方式为文件操作。\n\n下面的方法目的是为了获取启动类所在目录，以便后面扫描此路径。\n\n- 获取路径\n- 将 .  替换为 \\\n\n```java\npublic static void run() throws FileNotFoundException {\n    //获取类路径，到****/classes/\n    final String classPath = ResourceUtils.getURL(\"classpath:\").getPath();\n    //获取package名com.xx.xx.xx\n    final String packageName = ScannerPackage.class.getPackage().getName();\n    //replace正则匹配进行替换，. --> \\\\.   File.separator 在win下为\\会被当成转译字符\n    final String packageNameNew =\n            packageName.replaceAll(\"\\\\.\", Matcher.quoteReplacement(File.separator));\n    //当前类所在包路径\n    String rootPath = String.join(\"\", classPath, packageNameNew);\n    final File rootFile = new File(rootPath);\n    dir(Collections.singletonList(rootFile));\n    for (String path : classPaths) {\n        System.out.println(path);\n    }\n}\n```\n\n记录所有类全限定名称：\n\n```java\npublic static List<String> classPaths = new ArrayList<>();\n/**\n * 扫描某路径下的所有文件\n */\npublic static void dir(List<File> dirList) {\n    //遍历当前类，将文件分组，文件夹一组、非文件夹一组。非文件夹记录进集合，文件夹继续操作\n    final HashMap<Boolean, List<File>> fileMap =\n            dirList.stream().collect(Collectors.groupingBy(File::isDirectory, HashMap::new, Collectors.toList()));\n    //文件\n    final List<File> fileList = fileMap.get(false);\n    final List<File> dir2List = fileMap.get(true);\n    files(Optional.ofNullable(fileList).orElse(Collections.emptyList()));\n    if (!CollectionUtils.isEmpty(dir2List)) {\n        //文件夹\n        for (File file : dir2List) {\n            dir(Arrays.asList(Optional.ofNullable(file.listFiles()).orElse(new File[0])));\n        }\n    }\n}\npublic static void files(List<File> fileList) {\n    final List<String> fileNameList = fileList.stream().map(file -> {\n        //得到 com/xx/xx\n        final String str1 = file.getPath().split(\"classes\" + Matcher.quoteReplacement(File.separator))[1];\n        final String str2 = str1.replaceAll(Matcher.quoteReplacement(File.separator), \".\");\n        final String str3 = str2.substring(0, str2.lastIndexOf(\".\"));\n        return str3;\n    }).collect(Collectors.toList());\n    classPaths.addAll(fileNameList);\n}\n```\n\n测试一下：\n\n```java\npublic static void main(String[] args) throws FileNotFoundException {\n    run();\n}\n```\n\n![image-20220831161805033](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208312252895.png)\n\n\n\n##### 自定义一套注解\n\n> 我们已经获取启动类所在目录下的所有类的全限定的名称，那么创建类已经不是问题了。\n>\n> 接下来定义一套自己的注解。\n\n\n\n######  RolyValue\n\n> 模拟@Value\n\n```java\n/**\n * @Date: 2022/08/31/15:55\n * @Description: @Value替代品   可用于方法、字段上\n */\n@Target({ElementType.FIELD,ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface RolyValue {\n    String value() default \"\";\n}\n```\n\n> 测试一下\n\n创建一个Bean对象，存在三个属性\n\n```java\npublic class RolyValueBean {\n    @RolyValue(value = \"RolyValue给的值value1\")\n    String value1;\n    @RolyValue(value = \"RolyValue给的值value2\")\n    String value2;\n    \n    String value3;\n   //toString\n}\n```\n\n单元测试，循环给字段赋值：\n\n如果字段不是public的则需要设置AccessAble\n\n```java\n@Test\npublic void testRolyValue() throws IllegalAccessException {\n    final RolyValueBean rolyValueBean = new RolyValueBean();\n    System.out.println(\"原对象: ==>\" + rolyValueBean);\n    final Field[] declaredFields = rolyValueBean.getClass().getDeclaredFields();\n    for (Field declaredField : declaredFields) {\n        if (!declaredField.isAccessible()) {\n            declaredField.setAccessible(true);\n        }\n        final RolyValue rolyValue = declaredField.getAnnotation(RolyValue.class);\n        if (null != rolyValue) {\n            declaredField.set(rolyValueBean, rolyValue.value());\n        }\n    }\n    System.out.println(\"处理后: ==>\" + rolyValueBean);\n}\n```\n\n![image-20220831163503151](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208312253378.png)\n\n###### RolyComponent\n\n> 自定义组件注解，模拟@Component。\n\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface RolyComponent {\n\n}\n```\n\n\n\n###### RolyBean\n\n> 模拟@Bean\n\n```java\n@Target({ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface RolyBean {\n\t//bean名称\n    String value() default \"\";\n}\n```\n\n\n\n###### RolyValid\n\n> 模拟@Valid 。此注解作用于方法字段上，判断方法类型。\n\n```java\n@Target({ElementType.PARAMETER})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface RolyValid {\n    Class<? extends Object> value() default Object.class;\n}\n```\n\n测试:\n\n定义这么一个方法：使用@RolyValid限定此方法参数类型为String。这里故意给一个StringBuilder\n\n```java\npublic void method(@RolyValid(value = String.class) StringBuilder sb){\n}\n```\n\n```java\npublic void testRolyValid() throws IllegalAccessException {\n    final Method[] declaredMethods = RolyValueBean.class.getDeclaredMethods();\n    for (Method declaredMethod : declaredMethods) {\n        if (declaredMethod.isAccessible()) {\n            declaredMethod.setAccessible(true);\n        }\n        final Parameter[] parameters = declaredMethod.getParameters();\n        for (Parameter parameter : parameters) {\n            final RolyValid declaredAnnotation = parameter.getDeclaredAnnotation(RolyValid.class);\n            if (null != declaredAnnotation) {\n                if (!parameter.getType().equals(declaredAnnotation.value())) {\n                    throw new RuntimeException(declaredMethod.getName() +\n                            \"方法参数不合法:\" +\n                            \"require:\" + declaredAnnotation.value() +\n                            \"given:\" + parameter.getType());\n                }\n            }\n        }\n    }\n}\n```\n\n![image-20220831170816999](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208312253494.png)\n\n\n\n##### 实现\n\n> 目录结构：\n\n![image-20220831231917742](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208312319401.png)\n\n\n\n> 定义两个个待初始化类\n\n```java\n@RolyComponent\npublic class UserDao {\n    @RolyValue(\"@RolyValue给的值\")\n    String name;\n    //没有设置属性\n    String other;\n}\n@RolyService\npublic class UserService {\n    @RolyValue(\"@RolyValue给的值\")\n    String name;\n    String other;\n}\n```\n\n> bean工厂或者叫做上下文，负责初始化bean并加入容器。\n\n下面省略的方法即是获取启动类所在目录的class全限定名称，在上文都有提到\n\n```java\npublic class BeanFactory {\n    //扫描启动类所在包下所有类，将类的全限定名称保存在此list中\n    public static List<String> classPaths = new ArrayList<>();\n    //bean工厂\n    private static Map<String, Object> beanFactory = new HashMap<>();\n    static {\n        try {\n            init();\n            initBean();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void init() throws FileNotFoundException {\n       。。。\n    }\n\n    /**\n     * 扫描某路径下的所有文件\n     */\n    public static void dir(List<File> dirList) {\n   。。。\n    }\n\n    public static void files(List<File> fileList) {\n     。。。\n    }\n\n    public static void initBean() {\n        System.out.println(\"+++++++++++++创建类放入bean容器中++++++++++++\");\n        for (String classPath : classPaths) {\n            createBeanByName(classPath);\n        }\n        System.out.println(\"++++++++++++++++++++++++++++++++++++++++++\");\n    }\n\n    private static void createBeanByName(String classPath) {\n        Class<?> beanClass;\n        try {\n            //默认触发初始化\n            beanClass = Class.forName(classPath);\n            //判断是否需要创建\n            if (!shouldInit(beanClass)) {\n                return;\n            }\n            final Object bean = beanClass.newInstance();\n            //注入属性\n            initProperty(bean);\n            beanFactory.put(beanClass.getSimpleName(), bean);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void initProperty(Object bean) throws IllegalAccessException {\n        //获取所有的Field\n        final List<Field> fields = Arrays.asList(bean.getClass().getDeclaredFields());\n\n        for (Field field : fields) {\n            //设置允许访问\n            if (!field.isAccessible()) {\n                field.setAccessible(true);\n            }\n            //获取RolyValue注解的属性\n            final RolyValue declaredAnnotation = field.getDeclaredAnnotation(RolyValue.class);\n            if (null != declaredAnnotation) {\n                field.set(bean, declaredAnnotation.value());\n            }\n\n        }\n    }\n\n    /**\n     * 判断beanClass是否需要 自动注入 也就是是否包含@RolyComponent注解\n     *\n     * @param beanClass\n     * @return\n     */\n    public static boolean shouldInit(Class beanClass) {\n\n        final List<Annotation> annotations = Arrays.asList(beanClass.getDeclaredAnnotations());\n        if (annotations.isEmpty()) {\n            return false;\n        } else {\n            final List<? extends Class<? extends Annotation>> annotationTypes = annotations.stream().map(Annotation::annotationType).collect(Collectors.toList());\n            if (annotationTypes.contains(RolyComponent.class)) {\n                return true;\n            }\n            for (Annotation annotation : annotations) {\n                if (annotation.annotationType() == RolyComponent.class) {\n                    return true;\n                }\n                return shouldInit(annotation.annotationType());\n            }\n        }\n        return false;\n    }\n    public static Map<String, Object> objList() {\n        return beanFactory;\n    }\n    public static Object getObjByName(String name) {\n\n        return beanFactory.get(name);\n    }\n}\n```\n\n> 启动类，负责触发类的初始化\n\n这里容器里的bean都是单例的，也可以自定义Scope注解来设置bean声明周期\n\n```java\npublic class DemoApplication {\n    /**\n     * 启动类\n     */\n    public static void main(String[] args) throws FileNotFoundException, ClassNotFoundException {\n        Class.forName(\"com.roily.booknode.javatogod._07Annotation.a03.demo.BeanFactory\");\n        System.out.println(BeanFactory.objList());\n        System.out.println(\"容器中的bean实例都是单例的:\" + BeanFactory.getObjByName(\"UserDao\") == BeanFactory.getObjByName(\"UserDao\"));\n    }\n}\n```\n\n![image-20220831231756424](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202208312317518.png)\n\n\n\n### 时间处理\n\n#### 时区\n\n> 人们一般通过日出日落来定义时间，地球是圆的各个地方日出日落时间不等，所以定义时区概念，一个区域使用同一个时区。\n>\n> 地球被划分为24个时区，相邻时区之间时间相差一小时。（向西减一小时、向东加一小时）所以我们比漂亮国等西方国家时间要快。\n>\n> 但是呢，我们国家东西跨度很大，差不多横跨5个时区，但是为了方便管理，我们国家统一使用东八区。\n\n#### 时间戳\n\n> 时间戳是指格林威治时间1970-01-01 00：00：00（北京时间1970-01-01 08：00：00）起至现在的总毫秒数\n\n```java\nfinal Date time = Calendar.getInstance().getTime();\nfinal long timeStamp = time.getTime();\nSystem.out.println(\"当前时间：=>\" + time);\nSystem.out.println(\"当前时间戳：=>\" + timeStamp);\nfinal Date date = new Date(timeStamp + 1000);\nSystem.out.println(\"使用时间戳创建日期：=>\" + date);\n```\n\n![image-20220901111621031](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202209042254952.png)\n\n#### 格林威治时间\n\n> 英文简称GMT。\n>\n> 用GMT + 8表示中国时间，中国位于东八区，时间比格林威治时间快8小时。\n>\n> GMT 已经被 UTC取代，可以理解为一个东西。\n\nCST（China Standard Time）中国标准时间。\n\nCST  =  GMT/UTC + 8\n\n\n\n#### 时间格式化\n\n> 可以实现Date ---> String，String  ---> Date。\n>\n> 可以将日期对象\n\n##### SimpleDateFormat\n\n> 使用SimpleDateFormat的format方法，将一个Date类型转化成String类型，并且可以指定输出格式。\n\n```java\nfinal Date time = Calendar.getInstance().getTime();\nfinal SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\nfinal String format = simpleDateFormat.format(time);\nSystem.out.println(format);\n```\n\n![image-20220901124353128](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202209042253108.png)\n\n##### 自定义输出格式\n\n> 可以使用SimpleDateFormat自定义日期格式化输出格式。首先了解一下DateFormat给的模式字母。\n\nA~Z 和a~z。其他未使用到的字母作为保留。\n\n![image-20220901130030922](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202209042253534.png)\n\n> 常用的一个格式就是 年年年年-月月-日日  时时：分分：秒秒 对应模式字母表示就是：`yyyy-MM-dd hh:mm:ss`。\n>\n> 大小写不要混淆，大小写字母也对应着不同表示。\n>\n> 模式字母的个数代表输出字符串的长度。\n\n例子：\n\n```java\nfinal Date time = Calendar.getInstance().getTime();\nSystem.out.println(\"date的toString：===>\" + time);\n\nSystem.out.println(\"模式字符串:==>>  yyyy-MM-dd HH:mm:ss\");\nSimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\nSystem.out.println(simpleDateFormat.format(time));\n\n//从后往前截取  2022 ==>> 22\nSystem.out.println(\"模式字符串:==>>  yy-M-dd HH:mm:ss\");\nsimpleDateFormat = new SimpleDateFormat(\"yy-M-dd HH:mm:ss\");\nSystem.out.println(simpleDateFormat.format(time));\n\n//w代表周  大写代表月中的周 小写代表年中的周\nSystem.out.println(\"模式字符串:==>>  yyyy-MM-dd WW周/月 ww周/年 HH:mm:ss\");\nsimpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd WW周/月 ww周/年 HH:mm:ss\");\nSystem.out.println(simpleDateFormat.format(time));\n\n//d代表天  大写代表年中的天 小写代表月中的天\nSystem.out.println(\"模式字符串:==>>   yyyy-MM-dd DD天/年 dd天/月 HH:mm:ss\");\nsimpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd DD天/年 dd天/月 HH:mm:ss\");\nSystem.out.println(simpleDateFormat.format(time));\n\n//F代表月份中的星期（不好用） 一般用EE代表周几\nSystem.out.println(\"模式字符串:==>>  yyyy-MM-dd FF/月 EE/周 HH:mm:ss\");\nsimpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd FF/月 EE/周 HH:mm:ss\");\nSystem.out.println(simpleDateFormat.format(time));\n\n//a上下午标志 am pm\nSystem.out.println(\"模式字符串:==>>  yyyy-MM-dd aa HH:mm:ss\");\nsimpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd aa HH:mm:ss\");\nSystem.out.println(simpleDateFormat.format(time));\n\n//小时数 HH 24小时制 hh 12小时制\nSystem.out.println(\"模式字符串:==>>  yyyy-MM-dd HH:mm:ss aa hh:mm:ss\");\nsimpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss aa hh:mm:ss\");\nSystem.out.println(simpleDateFormat.format(time));\n\n//ss秒数  SS毫秒数\nSystem.out.println(\"模式字符串:==>>  yyyy-MM-dd HH:mm:ss aa hh:mm:ss\");\nsimpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss SS毫秒\");\nSystem.out.println(simpleDateFormat.format(time));\n\n//时区信息\nSystem.out.println(\"模式字符串:==>>  yyyy-MM-dd zzzz ZZZZ\");\nsimpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd zzzz ZZZZ\");\nSystem.out.println(simpleDateFormat.format(time));\n```\n\n![image-20220901132440802](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202209042253376.png)\n\n##### 输出其他时区时间\n\n> 指定时区输出时间。。\n\n我们比纽约快了12小时\n\n```java\nSimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss 时区:zzzz\");\nSystem.out.println(\"系统时区:===>>\" + simpleDateFormat.format(Calendar.getInstance().getTime()));\nsimpleDateFormat.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"));\nSystem.out.println(\"America/New_York:===>>\" + simpleDateFormat.format(Calendar.getInstance().getTime()));\n```\n\n![image-20220901133221969](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202209042253676.png)\n\n\n\n#####  DateFormart非线程安全\n\n> DateFormat是非线程安全类，如果将DateFormait作为全局共享的格式化时间类的话，需要加锁。\n>\n> JDK文档明确指出，SimpleDateFormat不应该在多线程环境下使用。\n\n![image-20220902170545946](java成神之路(基础).assets/image-20220902170545946.png)\n\nSimpleDateFormat非线程安全，必须为每一个线程创建独立的实例。如果必须同步使用一个日期格式，必须在外部加锁。\n\n![image-20220902171057527](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202209042253473.png)\n\n具体原因就是Format个方法，每一个SimpleDateFormat内部维护一个Calandar实例，如果当前线程设置了calandar，没来得及返回，另一个线程就获得了该SimpleDateFormat实例，如此就会造成线程安全问题。\n\n测试：\n\n定义一个全局的SimpleDateFormat，作为全局共享的格式化时间工具类.\n\n定义两个线程安全额的HashSet用于存放Calender和格式化后的日期字符串\n\n定义1000个线程去格式化时间\n\n> 可以发现格式化后的日期字符串没有达到预期数量，也就是多线程环境下，当前线程可能获取其他线程的数据。\n\n```java\npublic class TestDFIsNotSyn {\n    /**\n     * 定义一个全局的SimpleDateFormat\n     */\n    private static final SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n    final static Set<Calendar> calendars = Collections.synchronizedSet(new HashSet<>());\n    final static Set<String> dates = Collections.synchronizedSet(new HashSet<>());\n    public static void main(String[] args) throws InterruptedException {\n        for (int i = 0; i < 1000; i++) {\n            int finalI = i;\n            new Thread(() -> {\n                Calendar calendar = Calendar.getInstance();\n                calendar.add(Calendar.DATE, finalI);\n                calendars.add(calendar);\n                final String format = simpleDateFormat.format(calendar.getTime());\n                dates.add(format);\n            }).start();\n        }\n        Thread.sleep(5000);\n        System.out.println(calendars.size());\n        System.out.println(dates.size());\n    }\n}\n```\n\n![image-20220901183737158](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202209042253994.png)\n\n#### java中时间处理\n\n> java旧的关于时间处理的类Date涉及存在较大缺陷，因此后续版本中添加了Calendar和TimeZone类来完善对于时间的处理。\n\n##### 旧\n\n> 旧版本的时间处理类`java.util.Date`存在较大缺陷\n\n- 结构很乱，在`java.util`和`java.sql`包下都存在`Date`类，名称相同，可读性不好。并且对于日期进行格式化的类在`java.text`包下。\n- 不支持时区设置，`Java.util.Date`不提供国际化处理\n\n\n\n##### 新\n\n> java8中对时间处理进行了完善。集中在`java.time`包下\n\n- Instant：时间戳\n- Duration：时间段\n- LocalDate：日期\n- LocalTime：时间\n- LocalDateTime：时间  日期\n- Period：日期段\n- \n\n```java\nfinal Duration durationDay = Duration.ofDays(1);\nSystem.out.println(\"间隔一天，多少秒：\" + durationDay.get(durationDay.getUnits().get(0)));\nSystem.out.println(24 * 60 * 60);\n\nfinal Duration durationMin = Duration.ofMinutes(5);\nSystem.out.println(\"间隔5分钟，多少秒：\" + durationMin.get(durationMin.getUnits().get(0)));\nSystem.out.println(5 * 60);\n\nfinal Duration plus = durationMin.plus(1, durationDay.getUnits().get(0));\nSystem.out.println(\"加一秒，多少秒：\" + plus.get(plus.getUnits().get(0)));\n\nfinal Duration minus = durationDay.minus(Duration.ofMinutes(10).getSeconds(), durationDay.getUnits().get(0));\nSystem.out.println(\"减10分钟\" + minus.getSeconds());\n```\n\n- LocalDate：只包含日期 年月日\n\n```java\nSystem.out.println(\"当下日期:=>\"+LocalDate.now());\nSystem.out.println(\"自定义日期:=>\"+LocalDate.of(1999, Month.FEBRUARY,1));\nSystem.out.println(\"withXXX修改日期:=>\"+LocalDate.of(1999, Month.FEBRUARY,1).withMonth(12));\n```\n\n- LocalTime：当下时间   时分秒 精确到毫秒\n\n```java\nSystem.out.println(\"当下时间:=>\"+ LocalTime.now());\nSystem.out.println(\"自定义时间:=>\"+LocalTime.of(12, 0,1,1));\nSystem.out.println(\"withXXX修改时间:=>\"+LocalTime.of(12, 0,1,1).withHour(13));\n```\n\n- LocalDateTime：localdate + localTime    年月日 时分秒\n\n```java\nSystem.out.println(\"当下时间:=>\"+ LocalDateTime.now().toString().replaceAll(\"T\",\" \"));\nSystem.out.println(\"自定义时间:=>\"+LocalDateTime.of(LocalDate.now(),LocalTime.now()));\nSystem.out.println(\"withXXX修改时间:=>\"+LocalDateTime.of(LocalDate.now(),LocalTime.now()).withDayOfMonth(1));\n```\n\n- Period： 日期段\n\n```java\nfinal Period period = Period.of(1, 05, 20);\nSystem.out.println(\"创建时期:=>\" + period);\n\nfinal Period between = Period.between(LocalDate.of(1999, 5, 20), LocalDate.of(2022, 9, 2));\nSystem.out.println(\"间隔日期,用于计算年龄:=>\" + between);\n\nfinal Period period1 = period.withDays(10);\nSystem.out.println(\"withday修改day: =>\" + period1);\n\nfinal Period period2 = period.plusDays(1);\nSystem.out.println(\"plus加一天、minu减一天: =>\" + period2);\n```\n\n- ZoneOffset：时区偏移量\n\n```java\nSystem.out.println(\"默认时区偏移量：+》\" + ZoneOffset.systemDefault());\n```\n\n- ZonedDateTime:带时区的时间\n\n```java\nSystem.out.println(\"带时区的时间：=》\" + ZonedDateTime.now());\n```\n\n- Clock\n\n```java\nSystem.out.println(\"默认时钟:+>\" + Clock.systemDefaultZone());\nfinal Clock America = Clock.system(ZoneId.of(\"America/Los_Angeles\"));\nSystem.out.println(\"美国时钟:+>\" + America);\nfinal LocalDateTime now = LocalDateTime.now(America);\nSystem.out.println(\"美国时间:+>\" + now);\n```\n\n\n\n### 编码\n\n> 编码规则是字节到字符、字符到字节的规则。如果规则不统一则会出现乱码的现在想。\n\n#### ASCLL\n\n> ASCII（ American Standard Code for InformationInterchange， 美国信息交换标准代码） 是基于拉丁字母的⼀套电脑编码系统， 主要⽤于显⽰现代英语和其他西欧语⾔。\n\n标准ASCII 码也叫基础ASCII码， 使⽤7 位⼆进制数（ 剩下的1位⼆进制为0） 来表⽰所有的⼤写和⼩写字母， 数字0 到9、 标点符号， 以及在美式英语中使⽤的特殊控制字符。\n\n其中：\n\n0～31及127(共33个)是控制字符或通信专⽤字符（ 其余为可显⽰字符） ， 如控制符： LF（ 换⾏） 、 CR（ 回车） 、 FF（ 换页） 、 DEL（ 删除） 、 BS（ 退格)、 BEL（ 响铃） 等； 通信专⽤字符： SOH（ ⽂头） 、 EOT（ ⽂尾） 、 ACK（ 确认） 等；\n\nASCII值为8、 9、 10 和13 分别转换为退格、 制表、 换⾏和回车字符。 它们并没有特定的图形显⽰， 但会依不同的应⽤程序，⽽对⽂本显⽰有不同的影响\n\n32～126(共95个)是字符(32是空格） ， 其中48～57为0到9⼗个阿拉伯数字。\n\n65～90为26个⼤写英⽂字母， 97～122号为26个⼩写英⽂字母， 其余为⼀些标点符号、 运算符号等。\n\n\n\n#### Unicode\n\n> Unicode又称万国码，是计算机领域的一项标准，囊括了世界上大部分文字系统。\n\nASCII码，只有256个字符，美国人倒是没啥问题了，他们用到的字符几乎都包括了，但是世界上不只有美国程序员啊，所以需要一种更加全面的字符集。\n\nUnicode（中文：万国码、国际码、统一码、单一码）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得计算机可以用更为简单的方式来呈现和处理文字。\n\nUnicode伴随着通用字符集的标准而发展，同时也以书本的形式对外发表。Unicode至今仍在不断增修，每个新版本都加入更多新的字符。目前最新的版本为2018年6月5日公布的11.0.0，已经收录超过13万个字符（第十万个字符在2005年获采纳）。Unicode涵盖的数据除了视觉上的字形、编码方法、标准的字符编码外，还包含了字符特性，如大小写字母。\n\nUnicode发展由非营利机构统一码联盟负责，该机构致力于让Unicode方案取代既有的字符编码方案。因为既有的方案往往空间非常有限，亦不适用于多语环境。\n\nUnicode备受认可，并广泛地应用于计算机软件的国际化与本地化过程。有很多新科技，如可扩展置标语言（Extensible Markup Language，简称：XML）、Java编程语言以及现代的操作系统，都采用Unicode编码。\n\nUnicode可以表示中文。\n\n\n\n#### 有了Unicode为啥还需要UTF-8\n\n> Unicode 是字符集。UTF-8 是编码规则。\n>\n> 由于Unicode囊括了大部分文字系统，所以对于单个文字的表示可能占有3到4个字节，而对于英文字符和一些简单的文字系统，就必须高位补0，极大浪费内存。\n>\n> UTF-8使用可变长度字节来储存 Unicode字符，例如ASCII字母继续使用1字节储存，重音文字、希腊字母或西里尔字母等使用2字节来储存，而常用的汉字就要使用3字节。辅助平面字符则使用4字节\n\n广义的 Unicode 是一个标准，定义了一个字符集以及一系列的编码规则，即 Unicode 字符集和 UTF-8、UTF-16、UTF-32 等等编码规则。\n\nUnicode 是字符集。UTF-8 是编码规则。\n\nunicode虽然统一了全世界字符的二进制编码，但没有规定如何存储。\n\n如果Unicode统一规定，每个符号就要用三个或四个字节表示，因为字符太多，只能用这么多字节才能表示完全。\n\n一旦这么规定，那么每个英文字母前都必然有二到三个字节是0，因为所有英文字母在ASCII中都有，都可以用一个字节表示，剩余字节位置就要补充0。\n\n如果这样，文本文件的大小会因此大出二三倍，这对于存储来说是极大的浪费。这样导致一个后果：出现了Unicode的多种存储方式。\n\nUTF-8就是Unicode的一个使用方式，通过他的英文名Unicode Tranformation Format就可以知道。\n\n==UTF-8使用可变长度字节来储存 Unicode字符，例如ASCII字母继续使用1字节储存，重音文字、希腊字母或西里尔字母等使用2字节来储存，而常用的汉字就要使用3字节。辅助平面字符则使用4字节。==\n\n一般情况下，同一个地区只会出现一种文字类型，比如中文地区一般很少出现韩文，日文等。所以使用这种编码方式可以大大节省空间。比如纯英文网站就要比纯中文网站占用的存储小一些。\n\n#### UTF8、UTF16、UTF32区别\n\nUnicode 是容纳世界所有文字符号的国际标准编码，使用四个字节为每个字符编码。\n\nUTF 是英文 Unicode Transformation Format 的缩写，意为把 Unicode 字符转换为某种格式。UTF 系列编码方案（UTF-8、UTF-16、UTF-32）均是由 Unicode 编码方案衍变而来，以适应不同的数据存储或传递，它们都可以完全表示 Unicode 标准中的所有字符。目前，这些衍变方案中 UTF-8 被广泛使用，而 UTF-16 和 UTF-32 则很少被使用。\n\nUTF-8 使用一至四个字节为每个字符编码，其中大部分汉字采用三个字节编码，少量不常用汉字采用四个字节编码。因为 UTF-8 是可变长度的编码方式，相对于 Unicode 编码可以减少存储占用的空间，所以被广泛使用。\n\nUTF-16 使用二或四个字节为每个字符编码，其中大部分汉字采用两个字节编码，少量不常用汉字采用四个字节编码。UTF-16 编码有大尾序和小尾序之别，即 UTF-16BE 和 UTF-16LE，在编码前会放置一个 U+FEFF 或 U+FFFE（UTF-16BE 以 FEFF 代表，UTF-16LE 以 FFFE 代表），其中 U+FEFF 字符在 Unicode 中代表的意义是 ZERO WIDTH NO-BREAK SPACE，顾名思义，它是个没有宽度也没有断字的空白。\n\nUTF-32 使用四个字节为每个字符编码，使得 UTF-32 占用空间通常会是其它编码的二到四倍。UTF-32 与 UTF-16 一样有大尾序和小尾序之别，编码前会放置 U+0000FEFF 或 U+0000FFFE 以区分。\n\n\n\n#### 有了UTF8为什么还需要GBK？\n\n其实UTF8确实已经是国际通用的字符编码了，但是这种字符标准毕竟是外国定的，而国内也有类似的标准指定组织，也需要制定一套国内通用的标准，于是GBK就诞生了。\n\n\n\n#### GBK、GB2312、GB18030之间的区别\n\n三者都是支持中文字符的编码方式，最常用的是GBK。\n\n以下内容来自CSDN，介绍的比较详细。\n\nGB2312（1980年）：16位字符集，收录有6763个简体汉字，682个符号，共7445个字符； 优点：适用于简体中文环境，属于中国国家标准，通行于大陆，新加坡等地也使用此编码； 缺点：不兼容繁体中文，其汉字集合过少。\n\nGBK（1995年）：16位字符集，收录有21003个汉字，883个符号，共21886个字符； 优点：适用于简繁中文共存的环境，为简体Windows所使用（代码页cp936），向下完全兼容gb2312，向上支持 ISO-10646 国际标准 ；所有字符都可以一对一映射到unicode2.0上； 缺点：不属于官方标准，和big5之间需要转换；很多搜索引擎都不能很好地支持GBK汉字。\n\nGB18030（2000年）：32位字符集；收录了27484个汉字，同时收录了藏文、蒙文、维吾尔文等主要的少数民族文字。 优点：可以收录所有你能想到的文字和符号，属于中国最新的国家标准； 缺点：目前支持它的软件较少。\n\n\n\n#### URL编解码\n\n网络标准RFC 1738做了硬性规定 :只有字母和数字[0-9a-zA-Z]、一些特殊符号“$-_.+!*'(),”[不包括双引号]、以及某些保留字，才可以不经过编码直接用于URL;\n\n除此以外的字符是无法在URL中展示的，所以，遇到这种字符，如中文，就需要进行编码。\n\n所以，把带有特殊字符的URL转成可以显示的URL过程，称之为URL编码。\n\n反之，就是解码。\n\nURL编码可以使用不同的方式，如escape，URLEncode，encodeURIComponent。\n\n\n\n#### Big Endian和Little Endian\n\n字节序，也就是字节的顺序，指的是多字节的数据在内存中的存放顺序。\n\n在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如：如果C/C++中的一个int型变量 a 的起始地址是&a = 0x100，那么 a 的四个字节将被存储在存储器的0x100, 0x101, 0x102, 0x103位置。\n\n根据整数 a 在连续的 4 byte 内存中的存储顺序，字节序被分为大端序（Big Endian） 与 小端序（Little Endian）两类。\n\nBig Endian 是指低地址端 存放 高位字节。 Little Endian 是指低地址端 存放 低位字节。\n\nJava采用Big Endian来存储数据、C\\C++采用Little Endian。在网络传输一般采用的网络字节序是BIG-ENDIAN。和Java是一致的。\n\n所以在用C/C++写通信程序时，在发送数据前务必把整型和短整型的数据进行从主机字节序到网络字节序的转换，而接收数据后对于整型和短整型数据则必须实现从网络字节序到主机字节序的转换。如果通信的一方是JAVA程序、一方是C/C++程序时，则需要在C/C++一侧使用以上几个方法进行字节序的转换，而JAVA一侧，则不需要做任何处理，因为JAVA字节序与网络字节序都是BIG-ENDIAN，只要C/C++一侧能正确进行转换即可（发送前从主机序到网络序，接收时反变换）。如果通信的双方都是JAVA，则根本不用考虑字节序的问题了。\n\n\n\n### 语法糖\n\n> 语法糖（Syntactic Sugar），也称糖衣语法，是指编程语言提供一种简易语法，这种语法不会改变程序逻辑，因此借助语法糖可编写出简洁的代码。\n>\n> 以下了解java语法糖。\n\n#### 解语法糖\n\nJava虚拟机并不支持语法糖。这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。\n\nJava 中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。本文主要来分析下这些语法糖背后的原理。一步一步剥去糖衣，看看其本质。\n\n\n\n#### Switch支持String与枚举\n\n> switch可支持的数据类型有：char, byte, short, int, Character, Byte, Short, Integer, String, or an enum\n\nchar只占用1个字节8位，可以和int平替，switch的时候也是先将char转为int再进行switch的：\n\n```java\nchar c1 = 'a';\nswitch (c1) {\n    case 'a':\n        break;\n}\n```\n\n反编译得到：\n\n```java\nchar c1 = 'a';\nswitch(c1){\ncase 97: // 'a'\n    break;\n}\n```\n\n\n\n##### switch支持String\n\n> switch可以认为只支持int类型。\n>\n> switch对于String的支持，是首先获取String类型的hashCode，对hashCode进行switch，再通过equals进行安全校验\n\n```java\nString str = \"abc\";\nswitch (str) {\n    case \"123\":\n        break;\n    case \"abc\":\n        break;\n    default:\n        break;\n}\n```\n\n反编译:\n\n```java\nString str = \"abc\";\nString s = str;\nbyte byte0 = -1;\nswitch(s.hashCode())\n{\ncase 48690: \n    if(s.equals(\"123\"))\n        byte0 = 0;\n    break;\ncase 96354: \n    if(s.equals(\"abc\"))\n        byte0 = 1;\n    break;\n}\nswitch(byte0)\n{\ncase 0: // '\\0'\ncase 1: // '\\001'\ndefault:\n    return;\n}\n```\n\n\n\n##### switch支持enum\n\n> switch可以认为只支持int类型。\n>\n> switch对于enum的支持，首先enum只是继承自Enum类的特殊Java类，编译器会为每一个枚举项设置对应编号，在switch的时候会使用此编号进行switch\n\n```java\nenum Season{\n    SPRING,SUMMER;\n}\n```\n\n```java\npublic void switchSupportEnum(Season season) {\n    switch (season) {\n        case SPRING:\n            break;\n        case SUMMER:\n            break;\n        default:\n            break;\n    }\n}\n```\n\n分别反编译枚举和switch方法：\n\n枚举：\n\n以下可获取信息：\n\n- 枚举类是继承自Enum的特殊java类，编译器会将其还原至jvm支持的编码规范\n- 枚举类中，每一个枚举项都是一个public static final的静态常量，且还有一个静态常量数组。这些属性都会在静态代码块钟完成初始化\n- 构造方法有两个字段：name和ordinal，分别表示枚举项名称和枚举项编号\n\n```java\nfinal class Season extends Enum\n{\n    public static Season[] values()\n    {\n        return (Season[])$VALUES.clone();\n    }\n    public static Season valueOf(String name)\n    {\n        return (Season)Enum.valueOf(com/roily/booknode/javatogod/_09sugar/Season, name);\n    }\n    private Season(String s, int i)\n    {\n        super(s, i);\n    }\n\n    public static final Season SPRING;\n    public static final Season SUMMER;\n    private static final Season $VALUES[];\n    static \n    {\n        SPRING = new Season(\"SPRING\", 0);\n        SUMMER = new Season(\"SUMMER\", 1);\n        $VALUES = (new Season[] {\n            SPRING, SUMMER\n        });\n    }\n}\n```\n\nswitch方法：\n\n编译器会自动生成一个静态内部类，静态内部类中会初始化一个int数组，此int数组会和枚举的ordinal编号一一对应，最后完成switch\n\n```java\npublic void switchSupportEnum(Season season){\n    static class _cls1{\n        static final int $SwitchMap$com$roily$booknode$javatogod$_09sugar$Season[];\n        static {\n            $SwitchMap$com$roily$booknode$javatogod$_09sugar$Season = new int[Season.values().length];\n            $SwitchMap$com$roily$booknode$javatogod$_09sugar$Season[Season.SPRING.ordinal()] = 1;\n            $SwitchMap$com$roily$booknode$javatogod$_09sugar$Season[Season.SUMMER.ordinal()] = 2;\n        }\n    }\n    switch(_cls1..SwitchMap.com.roily.booknode.javatogod._09sugar.Season[season.ordinal()]){\n    case 1: // '\\001'\n    case 2: // '\\002'\n    default:\n        return;\n    }\n}\n```\n\n\n\n#### 范型\n\n> java范型使得一份字节码可表示多种类型，有可重用的作用。比如List<String>和List<Integer>都映射到唯一字节码List。不存在List<String>和List<Integer>类型，在加载进jvm时，回进行类型擦除，变为原始类型，在需要的时候进行类型强转。\n\n> 通常情况下，一个编译器处理泛型有两种方式：`Code specialization`和`Code sharing`。C++和C#是使用`Code specialization`的处理机制，而Java使用的是`Code sharing`的机制。\n\n- Code specialization \n\n  为每一个范型创建单独字节码\n\n-   Code sharing\n\n  所有范型共享一份字节码\n\n> Code sharing方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（`type erasue`）实现的。\n\n> 类型擦除的主要过程如下： 1.将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。 2.移除所有的类型参数。\n\n```java\npublic void method1(List<String> list){\n    final String s = list.get(0);\n    list.add(\"123\");\n}\n/**\n * extends适合get\n * @param list\n */\npublic void method2(List<? extends String> list){\n    final String s = list.get(0);\n    list.add(null);\n}\n/**\n * extends适合add\n * @param list\n */\npublic void method3(List<? super String> list){\n    //得到obj没有意义\n    final Object o =  list.get(0);\n    //强转可能会造成，Cast异常\n    final Comparable s = (Comparable) list.get(0);\n    list.add(\"null\");\n\n}\n```\n\njad反编译：\n\n```java\npublic void method1(List list)\n{\n    String s = (String)list.get(0);\n    list.add(\"123\");\n}\n\npublic void method2(List list)\n{\n    String s = (String)list.get(0);\n    list.add(null);\n}\n\npublic void method3(List list)\n{\n    Object o = list.get(0);\n    Comparable s = (Comparable)list.get(0);\n    list.add(\"null\");\n}\n```\n\n\n\n#### 自动装箱拆箱\n\n> java允许基本数据类型的包装类型直接指向基本数据类型，基本数类型直接指向基本数据类型包装类型。\n>\n> 此过程称为装箱、拆箱\n\n自动装箱的过程会调用 valueOf方法\n\n自动拆箱过程会调用xxxValue()方法\n\n```java\n//自动装箱\nInteger i = 10;\n//自动拆箱\nint i2 = i;\n//自动拆箱\nInteger i3 = 10;\nfor (Integer integer = 0; integer < i3; integer++) {\n}\n```\n\n反编译：\n\n```java\nInteger i = Integer.valueOf(10);\nint i2 = i.intValue();\nInteger i3 = Integer.valueOf(10);\nfor(Integer integer = Integer.valueOf(0); integer.intValue() < i3.intValue();)\n{\n    Integer integer1 = integer;\n    Integer integer2 = integer = Integer.valueOf(integer.intValue() + 1);\n    Integer _tmp = integer1;\n}\n```\n\n#### 可变长参数\n\n> 方法的参数可设置为可变长参数，允许添加个数不同的参数。但可变长参数必须设置才方法参数的最后一个，使用三个点定义。\n>\n> 当调用此方法时，会将可变长参数转化为数组，再调用此方法\n\n```java\nvoid method2(String str, Integer... integers) {\n\n}\n```\n\n```java\ntransient void method2(String s, Integer ainteger[]){\n}\n```\n\n\n\n#### 内部类\n\n> 普通内部类和静态内部类，都属于语法糖。允许再一个类内部定义其他类，一但编译成功就会生成多份字节码。以下例子就会生成\n>\n> TestInnerClass.class   \n>\n> TestInnerClass$StaticInnerClass.class\n>\n> TestInnerClass$InnerClass.class\n>\n> 三份字节码\n\n```java\npublic class TestInnerClass {\n    class InnerClass{\n    }\n    static class StaticInnerClass{\n    }\n}\n```\n\n\n\n#### 条件编译\n\n> 根据条件编译代码。属于编译器编译期间对代码的优化。\n\n```java\n//包装类型需要转换所以无论如何都会编译\nfinal Boolean flag1 = false;\nif (flag1) {\n    System.out.println(\"flag1\");\n}else {\n    System.out.println(\"flag1   xxxx\");\n}\n\n//基本数据类型，无需转化，编译期间就知道对应值，会舍弃其中一个分支\nfinal boolean flag2 = true;\nif (flag2) {\n    System.out.println(\"flag2\");\n}else {\n    System.out.println(\"flag2   XXX\");\n}\n\n//flag3为false  编译器会舍弃这个分之\nfinal boolean flag3 = false;\nif (flag3) {\n    System.out.println(\"flag3\");\n}else {\n    System.out.println(\"flag3  xxx\");\n}\n```\n\n反编译：\n\n可以发现对于编译期间就可得知的值，编译器会做出条件编译优化：\n\n```java\nBoolean flag1 = Boolean.valueOf(false);\nif(flag1.booleanValue())\n    System.out.println(\"flag1\");\nelse\n    System.out.println(\"flag1   xxxx\");\nboolean flag2 = true;\nSystem.out.println(\"flag2\");\nboolean flag3 = false;\nSystem.out.println(\"flag3  xxx\");\n```\n\n#### Assert断言\n\n> 一般用于方法入参检查\n\n```java\npublic void testAssert(int num, StringBuilder sb) {\n    assert num > 0 && null != sb;\n}\n```\n\n反编译：\n\n需要开启断言，如果不满足条件将抛出异常。\n\n```java\npublic void testAssert(int num, StringBuilder sb)\n{\n    if(!$assertionsDisabled && (num <= 0 || null == sb))\n        throw new AssertionError();\n    else\n        return;\n}\n```\n\n#### 数值字面量\n\n> 无论是整数还是浮点数允许插入下划线方便阅读，编译时会去掉下划线\n\n```java\nint num1 = 100_0_0_000;\n//一般以千为单位\nint num2 = 10_000_000;\nfloat f = 10_000.0_100_100_001f;\n```\n\n反编译\n\n```java\nint num1 = 0x989680;\nint num2 = 0x989680;\nfloat f = 10000.01F;\n```\n\n\n\n#### 增强for循环\n\n> 增强for循环提供简单的遍历方式，底层使用迭代器，所以说禁止在增强for循环中对使用集合api元素进行增删操作。\n>\n> 只能使用迭代器提供的添加方法\n\n```java\nfinal ArrayList<String> strings = new ArrayList<>(Arrays.asList(\"1\", \"2\", \"3\"));\nfor (String string : strings) {\n    System.out.println(string);\n}\n\nSystem.out.println(\"---------------\");\n//即便添加元素，当前迭代也是迭代不出来的。光标会后移\nfinal ListIterator<String> iterator = strings.listIterator();\nwhile (iterator.hasNext()){\n    final String next = iterator.next();\n    System.out.println(next);\n    if (next.equals(\"2\")){\n        iterator.add(\"a\");\n    }\n}\n```\n\n反编译增强for循环：\n\n```java\nArrayList strings = new ArrayList(Arrays.asList(new String[] {\n    \"1\", \"2\", \"3\"\n}));\nString string;\nfor(Iterator iterator2 = strings.iterator(); iterator2.hasNext(); System.out.println(string))\n    string = (String)iterator2.next();\n```\n\n\n\n#### try with resources\n\n> 在进行资源连接以及关闭操作时，需要手动在finally代码块中独立进行，即便使用apache工具类提供的关闭资源方法也非常麻烦。\n>\n> 因此java提供try  with  resources方式，可以自动为我们关闭资源，前提是资源的创建需要在try()括号内。\n\n普通资源关闭操作：\n\n繁琐，需要多重try  cache\n\n```java\nString filePath = \"E://1.txt\";\nFileReader fr = null;\ntry {\n    fr = new FileReader(filePath);\n}catch (IOException e){\n}finally {\n    try {\n        IOUtils.close(fr);\n    } catch (IOException e) {\n    }\n}\n```\n\n使用try with resources:\n\n代码就简洁了很多\n\n```java\nString filePath = \"E://1.txt\";\ntry(FileReader fr = new FileReader(filePath)) {\n}catch (IOException e){\n}\n```\n\n反编译查看：我们偷的懒，编译器都帮我们做了\n\n```java\npublic void method1()\n{\n    String filePath = \"E://1.txt\";\n    try\n    {\n        FileReader fr = new FileReader(filePath);\n        Throwable throwable = null;\n        if(fr != null)\n            if(throwable != null)\n                try\n                {\n                    fr.close();\n                }\n                catch(Throwable throwable1)\n                {\n                    throwable.addSuppressed(throwable1);\n                }\n            else\n                fr.close();\n    }\n    catch(IOException ioexception) { }\n}\n```\n\n\n\n#### Lambda表达式\n\n> Lambda表达式，是java8特性，合理使用一下可以写出简洁高效的代码。\n>\n> 外部类 --> 内部类 --> 静态内部类  --> 匿名内部类 --> lambda表达式，一步步的简化接口实现的方式。\n>\n> 但是Lambda并不是匿名内部类的语法糖，lambda表达式的实现，是借助于Jvm提供的几个Api实现的。\n\n```java\nComparator<String> c = (v1,v2)->{\n  return   v1.compareTo(v2);\n};\n```\n\n反编译：使用CRF，jad不可以反编译lambda表达式，太久不更新了：\n\nCRF的使用：\n\n- 下载CRF.jar包\n-  使用  java -jar CRF.jar  XXXX.class --option  \n\nCRF存在很多可选参数，可使用 ` java -jar .\\cfr-0.152.jar --help`查看\n\n使用`java -jar .\\cfr-0.152.jar .\\TestLambda.class --decodelambdas false`命令反编译：\n\n可以发现会调用`LambdaMetafactory.metafactory`此方法，并且在第3、5个参数声明入参类型和出参数类型，在第四个参数指定方法实现。\n\n```java\npublic class TestLambda {\n    public void method1() {\n        Comparator c = (Comparator)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;Ljava/lang/Object;)I, lambda$method1$0(java.lang.String java.lang.String\n        ), (Ljava/lang/String;Ljava/lang/String;)I)();\n    }\n    private static /* synthetic */ int lambda$method1$0(String v1, String v2) {\n        return v1.compareTo(v2);\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/foot/读书笔记/java成神之路(基础)/java成神之路(基础).md b/foot/读书笔记/java成神之路(基础)/java成神之路(基础).md
---- a/foot/读书笔记/java成神之路(基础)/java成神之路(基础).md	(revision 36a8bc24bcb1b277f6ca18df242eb3c1409df7ad)
-+++ b/foot/读书笔记/java成神之路(基础)/java成神之路(基础).md	(date 1662478611302)
-@@ -7843,25 +7843,135 @@
- 
- 
- 
-+### BigDecimal
-+
-+> BigDecimal用于解决浮点数精度问题。
-+
-+#### (0.1d + 0.2d) ！= 0.3d
-+
-+> 浮点数存在精度问题，只能表示大概数值，不能精确表示
-+
-+现象：
-+
-+```java
-+double d1 = 0.1d;
-+double d2 = 0.2d;
-+System.out.println(d1 + d2);
-+System.out.println((d1 + d2) == 0.3d);
-+```
-+
-+![image-20220906002546839](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202209060025441.png)
-+
-+#### 借助BigDecimal
-+
-+> 借助bigDecimal解决浮点数精度问题
-+
-+```java
-+double d1 = 0.1d;
-+double d2 = 0.2d;
-+double d3 = 0.3d;
-+final BigDecimal bigDecimal1 = BigDecimal.valueOf(d1);
-+final BigDecimal bigDecimal2 = BigDecimal.valueOf(d2);
-+
-+final BigDecimal result = bigDecimal1.add(bigDecimal2);
-+System.out.println(result);
-+System.out.println(result.compareTo(BigDecimal.valueOf(d3)) == 0);
-+```
-+
-+![image-20220906003717302](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202209060037744.png)
-+
-+#### BigDecimal使用CompareTo判等
-+
-+> BigDecimal的判等，首先 `==`肯定不能用，equals方法会首先比较精度1.0和1.00的scale不等，直接返回false，应该使用CompareTo方式进行判等。
-+
-+```java
-+final BigDecimal bigDecimal1 = new BigDecimal("1.0");
-+final BigDecimal bigDecimal2 = new BigDecimal("1.00");
-+
-+System.out.println(bigDecimal1 == bigDecimal2);
-+System.out.println(bigDecimal1.equals(bigDecimal2));
-+System.out.println(bigDecimal1.compareTo(bigDecimal2) == 0);
-+```
- 
-+![image-20220906004444580](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202209060044591.png)
- 
-+当使用int、double定义BigDecimal时equals返回true，当使用String定义BigDecimal时可能返回false。
- 
-+因为使用String定义BigDecimal时，若精度不同，也就是多了几个0，字符数组的长度是不同的，那么BigDecimal的Scale即精度就会不同，而equals时回收先进行scale的对比。
- 
-+equals的javadoc也给出解释：
- 
-+当前BigDecimal和指定对象进行equals的时候，不同于compareTo，equals方法只有在两个BigDecimal的值和精度都相等的情况下两个对象才相等(因此2.0 不等于 2.00)。前提是使用String定义BigDecimal。
- 
-+```doc
-+Compares this BigDecimal with the specified Object for equality. Unlike compareTo, this method considers two compareTo objects equal only if they are equal in value and scale (thus 2.0 is not equal to 2.00 when compared by this method)
-+```
- 
- 
- 
-+#### BigDecimal原理
- 
-+> BigDecimal类似于科学计数法，其内部维护了一个无标度数值和一个标度。
- 
-+BigDecimal中标度使用Scale表示。
- 
-+当scale为0或整数时，表示该数小数点右边位数；当scale为负数时，即表示该数为无标度数值后加n个0。
- 
-+123.123 的无标度数为123123，标度为3。
- 
-+> 那么就可以表示二进制数不能表示的数
- 
-+0.1 无标度数为1，标度为1。
- 
- 
- 
-+##### 构造函数
- 
-+> BigDecimal有如下几种构造方法，这些构造方法的Scale的表示是不同的。
-+
-+- int和long都是正整数，没有小数部分，他们的scale为0
-+- double的scale由其具体表示值决定
-+- string的scale由具体表示值决定
-+
-+```java
-+BigDecimal(int)
-+BigDecimal(double) 
-+BigDecimal(long) 
-+BigDecimal(String)
-+```
-+
-+可以debug看一下如下代码：
-+
-+使用BigDecimal表示0.1d，并不精确，原因在浮点数的精度问题
-+
-+```java
-+double d1 = 0.1d;
-+final BigDecimal bigDecimal = new BigDecimal(d1);
-+System.out.println(bigDecimal);
-+```
-+
-+![image-20220906012031070](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202209060123055.png)
-+
-+但是如果此浮点数是可准确表示的，那么Bigdecimal也没有问题。但是BigDecimal就是为了解决精度问题的，在不存在精度问题才可准确表示，意义何在？
-+
-+![image-20220906012306647](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202209060123915.png)
-+
-+> 使用Bigdecimal(String)来创建Bigdecimal,可准确表示
-+
-+![image-20220906012608197](https://xiaochuang6.oss-cn-shanghai.aliyuncs.com/java%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/202209060126818.png)
-+
-+
-+
-+##### 小结
-+
-+> 创建Bigdecimal使用如下方式：
-+
-+valueof(val)会调用Double.toString(val)保证进度准确
-+
-+```java
-+Bigdecimal(String str);
-+Bigdecimal.valueof(double val);
-+```
- 
- 
- 
-Index: .idea/workspace.xml
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"bed07c71-5aa6-478f-ad22-84a18b2955be\" name=\"Changes\" comment=\"0830\">\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\n    </list>\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\n  </component>\n  <component name=\"GitSEFilterConfiguration\">\n    <file-type-list>\n      <filtered-out-file-type name=\"LOCAL_BRANCH\" />\n      <filtered-out-file-type name=\"REMOTE_BRANCH\" />\n      <filtered-out-file-type name=\"TAG\" />\n      <filtered-out-file-type name=\"COMMIT_BY_MESSAGE\" />\n    </file-type-list>\n  </component>\n  <component name=\"ProjectId\" id=\"2Ccb78KeUVafiMzq9wsiAXSh4AU\" />\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\">\n    <property name=\"RunOnceActivity.OpenProjectViewOnStart\" value=\"true\" />\n    <property name=\"RunOnceActivity.ShowReadmeOnStart\" value=\"true\" />\n    <property name=\"WebServerToolWindowFactoryState\" value=\"false\" />\n    <property name=\"last_opened_file_path\" value=\"$PROJECT_DIR$\" />\n    <property name=\"settings.editor.selected.configurable\" value=\"preferences.pluginManager\" />\n  </component>\n  <component name=\"RecentsManager\">\n    <key name=\"MoveFile.RECENT_KEYS\">\n      <recent name=\"D:\\File\\Desktop\\blogXX\\foot\\.idea\" />\n      <recent name=\"D:\\File\\Desktop\\blogXX\\foot\" />\n      <recent name=\"$PROJECT_DIR$/foot/读书笔记/java成神之路(基础)\" />\n    </key>\n  </component>\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"bed07c71-5aa6-478f-ad22-84a18b2955be\" name=\"Changes\" comment=\"\" />\n      <created>1659104649873</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1659104649873</updated>\n      <workItem from=\"1659104651612\" duration=\"169000\" />\n      <workItem from=\"1659435026542\" duration=\"147000\" />\n      <workItem from=\"1659890507701\" duration=\"105000\" />\n      <workItem from=\"1659969602475\" duration=\"1918000\" />\n      <workItem from=\"1660143366549\" duration=\"1366000\" />\n      <workItem from=\"1660490810386\" duration=\"1601000\" />\n      <workItem from=\"1660660411651\" duration=\"2249000\" />\n      <workItem from=\"1660832696278\" duration=\"3859000\" />\n      <workItem from=\"1661667836964\" duration=\"1497000\" />\n      <workItem from=\"1661787423056\" duration=\"1709000\" />\n      <workItem from=\"1661953837429\" duration=\"1655000\" />\n      <workItem from=\"1662190268090\" duration=\"1208000\" />\n      <workItem from=\"1662308623396\" duration=\"31000\" />\n      <workItem from=\"1662311748618\" duration=\"18000\" />\n      <workItem from=\"1662390195820\" duration=\"637000\" />\n    </task>\n    <task id=\"LOCAL-00001\" summary=\"0802work\">\n      <created>1659435136175</created>\n      <option name=\"number\" value=\"00001\" />\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1659435136175</updated>\n    </task>\n    <task id=\"LOCAL-00002\" summary=\"jvm\">\n      <created>1659890561272</created>\n      <option name=\"number\" value=\"00002\" />\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1659890561272</updated>\n    </task>\n    <task id=\"LOCAL-00003\" summary=\"collectors\">\n      <created>1660067029357</created>\n      <option name=\"number\" value=\"00003\" />\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1660067029357</updated>\n    </task>\n    <task id=\"LOCAL-00004\" summary=\"collectors\">\n      <created>1660582779319</created>\n      <option name=\"number\" value=\"00004\" />\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1660582779319</updated>\n    </task>\n    <task id=\"LOCAL-00005\" summary=\"collectors\">\n      <created>1660668957167</created>\n      <option name=\"number\" value=\"00005\" />\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1660668957167</updated>\n    </task>\n    <task id=\"LOCAL-00006\" summary=\"0818\">\n      <created>1660756297486</created>\n      <option name=\"number\" value=\"00006\" />\n      <option name=\"presentableId\" value=\"LOCAL-00006\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1660756297486</updated>\n    </task>\n    <task id=\"LOCAL-00007\" summary=\"0819\">\n      <created>1660842079046</created>\n      <option name=\"number\" value=\"00007\" />\n      <option name=\"presentableId\" value=\"LOCAL-00007\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1660842079046</updated>\n    </task>\n    <task id=\"LOCAL-00008\" summary=\"0828\">\n      <created>1661698651586</created>\n      <option name=\"number\" value=\"00008\" />\n      <option name=\"presentableId\" value=\"LOCAL-00008\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1661698651586</updated>\n    </task>\n    <task id=\"LOCAL-00009\" summary=\"0830\">\n      <created>1661797521570</created>\n      <option name=\"number\" value=\"00009\" />\n      <option name=\"presentableId\" value=\"LOCAL-00009\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1661797521570</updated>\n    </task>\n    <task id=\"LOCAL-00010\" summary=\"0830\">\n      <created>1661960203620</created>\n      <option name=\"number\" value=\"00010\" />\n      <option name=\"presentableId\" value=\"LOCAL-00010\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1661960203620</updated>\n    </task>\n    <task id=\"LOCAL-00011\" summary=\"0830\">\n      <created>1662311762550</created>\n      <option name=\"number\" value=\"00011\" />\n      <option name=\"presentableId\" value=\"LOCAL-00011\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1662311762550</updated>\n    </task>\n    <option name=\"localTasksCounter\" value=\"12\" />\n    <servers />\n  </component>\n  <component name=\"TypeScriptGeneratedFilesManager\">\n    <option name=\"version\" value=\"3\" />\n  </component>\n  <component name=\"Vcs.Log.History.Properties\">\n    <option name=\"COLUMN_ID_ORDER\">\n      <list>\n        <option value=\"Default.Root\" />\n        <option value=\"Default.Author\" />\n        <option value=\"Default.Date\" />\n        <option value=\"Default.Subject\" />\n        <option value=\"Space.CommitStatus\" />\n      </list>\n    </option>\n  </component>\n  <component name=\"Vcs.Log.Tabs.Properties\">\n    <option name=\"TAB_STATES\">\n      <map>\n        <entry key=\"MAIN\">\n          <value>\n            <State />\n          </value>\n        </entry>\n      </map>\n    </option>\n    <option name=\"oldMeFiltersMigrated\" value=\"true\" />\n  </component>\n  <component name=\"VcsManagerConfiguration\">\n    <MESSAGE value=\"0802work\" />\n    <MESSAGE value=\"jvm\" />\n    <MESSAGE value=\"collectors\" />\n    <MESSAGE value=\"0818\" />\n    <MESSAGE value=\"0819\" />\n    <MESSAGE value=\"0828\" />\n    <MESSAGE value=\"0830\" />\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"0830\" />\n  </component>\n</project>
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/.idea/workspace.xml b/.idea/workspace.xml
---- a/.idea/workspace.xml	(revision 36a8bc24bcb1b277f6ca18df242eb3c1409df7ad)
-+++ b/.idea/workspace.xml	(date 1662399821579)
-@@ -1,8 +1,8 @@
- <?xml version="1.0" encoding="UTF-8"?>
- <project version="4">
-   <component name="ChangeListManager">
--    <list default="true" id="bed07c71-5aa6-478f-ad22-84a18b2955be" name="Changes" comment="0830">
--      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
-+    <list default="true" id="bed07c71-5aa6-478f-ad22-84a18b2955be" name="Changes" comment="0905">
-+      <change beforePath="$PROJECT_DIR$/foot/读书笔记/java成神之路(基础)/java成神之路(基础).md" beforeDir="false" afterPath="$PROJECT_DIR$/foot/读书笔记/java成神之路(基础)/java成神之路(基础).md" afterDir="false" />
-     </list>
-     <option name="SHOW_DIALOG" value="false" />
-     <option name="HIGHLIGHT_CONFLICTS" value="true" />
-@@ -31,6 +31,7 @@
-     <property name="WebServerToolWindowFactoryState" value="false" />
-     <property name="last_opened_file_path" value="$PROJECT_DIR$" />
-     <property name="settings.editor.selected.configurable" value="preferences.pluginManager" />
-+    <property name="vue.rearranger.settings.migration" value="true" />
-   </component>
-   <component name="RecentsManager">
-     <key name="MoveFile.RECENT_KEYS">
-@@ -62,6 +63,7 @@
-       <workItem from="1662308623396" duration="31000" />
-       <workItem from="1662311748618" duration="18000" />
-       <workItem from="1662390195820" duration="637000" />
-+      <workItem from="1662399803500" duration="19000" />
-     </task>
-     <task id="LOCAL-00001" summary="0802work">
-       <created>1659435136175</created>
-@@ -140,7 +142,14 @@
-       <option name="project" value="LOCAL" />
-       <updated>1662311762550</updated>
-     </task>
--    <option name="localTasksCounter" value="12" />
-+    <task id="LOCAL-00012" summary="0905">
-+      <created>1662399811759</created>
-+      <option name="number" value="00012" />
-+      <option name="presentableId" value="LOCAL-00012" />
-+      <option name="project" value="LOCAL" />
-+      <updated>1662399811759</updated>
-+    </task>
-+    <option name="localTasksCounter" value="13" />
-     <servers />
-   </component>
-   <component name="TypeScriptGeneratedFilesManager">
-@@ -177,6 +186,7 @@
-     <MESSAGE value="0819" />
-     <MESSAGE value="0828" />
-     <MESSAGE value="0830" />
--    <option name="LAST_COMMIT_MESSAGE" value="0830" />
-+    <MESSAGE value="0905" />
-+    <option name="LAST_COMMIT_MESSAGE" value="0905" />
-   </component>
- </project>
-\ No newline at end of file
